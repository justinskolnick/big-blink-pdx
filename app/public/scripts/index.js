/* eslint-disable */
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to2, from3, except, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      (function() {
        function performWorkUntilDeadline() {
          if (isMessageLoopRunning) {
            var currentTime = exports.unstable_now();
            startTime = currentTime;
            var hasMoreWork = true;
            try {
              a: {
                isHostCallbackScheduled = false;
                isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
                isPerformingWork = true;
                var previousPriorityLevel = currentPriorityLevel;
                try {
                  b: {
                    advanceTimers(currentTime);
                    for (currentTask = peek3(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                      var callback2 = currentTask.callback;
                      if ("function" === typeof callback2) {
                        currentTask.callback = null;
                        currentPriorityLevel = currentTask.priorityLevel;
                        var continuationCallback = callback2(
                          currentTask.expirationTime <= currentTime
                        );
                        currentTime = exports.unstable_now();
                        if ("function" === typeof continuationCallback) {
                          currentTask.callback = continuationCallback;
                          advanceTimers(currentTime);
                          hasMoreWork = true;
                          break b;
                        }
                        currentTask === peek3(taskQueue) && pop(taskQueue);
                        advanceTimers(currentTime);
                      } else pop(taskQueue);
                      currentTask = peek3(taskQueue);
                    }
                    if (null !== currentTask) hasMoreWork = true;
                    else {
                      var firstTimer = peek3(timerQueue);
                      null !== firstTimer && requestHostTimeout(
                        handleTimeout,
                        firstTimer.startTime - currentTime
                      );
                      hasMoreWork = false;
                    }
                  }
                  break a;
                } finally {
                  currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
                }
                hasMoreWork = void 0;
              }
            } finally {
              hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
            }
          }
        }
        function push(heap, node2) {
          var index = heap.length;
          heap.push(node2);
          a: for (; 0 < index; ) {
            var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
            if (0 < compare(parent, node2))
              heap[parentIndex] = node2, heap[index] = parent, index = parentIndex;
            else break a;
          }
        }
        function peek3(heap) {
          return 0 === heap.length ? null : heap[0];
        }
        function pop(heap) {
          if (0 === heap.length) return null;
          var first = heap[0], last = heap.pop();
          if (last !== first) {
            heap[0] = last;
            a: for (var index = 0, length2 = heap.length, halfLength = length2 >>> 1; index < halfLength; ) {
              var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
              if (0 > compare(left, last))
                rightIndex < length2 && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
              else if (rightIndex < length2 && 0 > compare(right, last))
                heap[index] = right, heap[rightIndex] = last, index = rightIndex;
              else break a;
            }
          }
          return first;
        }
        function compare(a, b) {
          var diff = a.sortIndex - b.sortIndex;
          return 0 !== diff ? diff : a.id - b.id;
        }
        function advanceTimers(currentTime) {
          for (var timer = peek3(timerQueue); null !== timer; ) {
            if (null === timer.callback) pop(timerQueue);
            else if (timer.startTime <= currentTime)
              pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
            else break;
            timer = peek3(timerQueue);
          }
        }
        function handleTimeout(currentTime) {
          isHostTimeoutScheduled = false;
          advanceTimers(currentTime);
          if (!isHostCallbackScheduled)
            if (null !== peek3(taskQueue))
              isHostCallbackScheduled = true, requestHostCallback();
            else {
              var firstTimer = peek3(timerQueue);
              null !== firstTimer && requestHostTimeout(
                handleTimeout,
                firstTimer.startTime - currentTime
              );
            }
        }
        function shouldYieldToHost() {
          return exports.unstable_now() - startTime < frameInterval ? false : true;
        }
        function requestHostCallback() {
          isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        }
        function requestHostTimeout(callback2, ms) {
          taskTimeoutID = localSetTimeout(function() {
            callback2(exports.unstable_now());
          }, ms);
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        exports.unstable_now = void 0;
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var localPerformance = performance;
          exports.unstable_now = function() {
            return localPerformance.now();
          };
        } else {
          var localDate = Date, initialTime = localDate.now();
          exports.unstable_now = function() {
            return localDate.now() - initialTime;
          };
        }
        var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
        if ("function" === typeof localSetImmediate)
          var schedulePerformWorkUntilDeadline = function() {
            localSetImmediate(performWorkUntilDeadline);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var channel = new MessageChannel(), port = channel.port2;
          channel.port1.onmessage = performWorkUntilDeadline;
          schedulePerformWorkUntilDeadline = function() {
            port.postMessage(null);
          };
        } else
          schedulePerformWorkUntilDeadline = function() {
            localSetTimeout(performWorkUntilDeadline, 0);
          };
        exports.unstable_IdlePriority = 5;
        exports.unstable_ImmediatePriority = 1;
        exports.unstable_LowPriority = 4;
        exports.unstable_NormalPriority = 3;
        exports.unstable_Profiling = null;
        exports.unstable_UserBlockingPriority = 2;
        exports.unstable_cancelCallback = function(task) {
          task.callback = null;
        };
        exports.unstable_continueExecution = function() {
          isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback());
        };
        exports.unstable_forceFrameRate = function(fps) {
          0 > fps || 125 < fps ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
        };
        exports.unstable_getCurrentPriorityLevel = function() {
          return currentPriorityLevel;
        };
        exports.unstable_getFirstCallbackNode = function() {
          return peek3(taskQueue);
        };
        exports.unstable_next = function(eventHandler) {
          switch (currentPriorityLevel) {
            case 1:
            case 2:
            case 3:
              var priorityLevel = 3;
              break;
            default:
              priorityLevel = currentPriorityLevel;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_pauseExecution = function() {
        };
        exports.unstable_requestPaint = function() {
        };
        exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
          switch (priorityLevel) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              priorityLevel = 3;
          }
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = priorityLevel;
          try {
            return eventHandler();
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
        exports.unstable_scheduleCallback = function(priorityLevel, callback2, options2) {
          var currentTime = exports.unstable_now();
          "object" === typeof options2 && null !== options2 ? (options2 = options2.delay, options2 = "number" === typeof options2 && 0 < options2 ? currentTime + options2 : currentTime) : options2 = currentTime;
          switch (priorityLevel) {
            case 1:
              var timeout2 = -1;
              break;
            case 2:
              timeout2 = 250;
              break;
            case 5:
              timeout2 = 1073741823;
              break;
            case 4:
              timeout2 = 1e4;
              break;
            default:
              timeout2 = 5e3;
          }
          timeout2 = options2 + timeout2;
          priorityLevel = {
            id: taskIdCounter++,
            callback: callback2,
            priorityLevel,
            startTime: options2,
            expirationTime: timeout2,
            sortIndex: -1
          };
          options2 > currentTime ? (priorityLevel.sortIndex = options2, push(timerQueue, priorityLevel), null === peek3(taskQueue) && priorityLevel === peek3(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options2 - currentTime))) : (priorityLevel.sortIndex = timeout2, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, requestHostCallback()));
          return priorityLevel;
        };
        exports.unstable_shouldYield = shouldYieldToHost;
        exports.unstable_wrapCallback = function(callback2) {
          var parentPriorityLevel = currentPriorityLevel;
          return function() {
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = parentPriorityLevel;
            try {
              return callback2.apply(this, arguments);
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          };
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      (function() {
        function defineDeprecationWarning(methodName, info) {
          Object.defineProperty(Component4.prototype, methodName, {
            get: function() {
              console.warn(
                "%s(...) is deprecated in plain JavaScript React classes. %s",
                info[0],
                info[1]
              );
            }
          });
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function warnNoop(publicInstance, callerName) {
          publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
          var warningKey = publicInstance + "." + callerName;
          didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
            "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
            callerName,
            publicInstance
          ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
        }
        function Component4(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function ComponentDummy() {
        }
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE2:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE2:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x2) {
                }
            }
          return null;
        }
        function isValidElementType(type) {
          return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE2 || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE2 || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId) ? true : false;
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign3({}, props, { value: prevLog }),
              info: assign3({}, props, { value: prevInfo }),
              warn: assign3({}, props, { value: prevWarn }),
              error: assign3({}, props, { value: prevError }),
              group: assign3({}, props, { value: prevGroup }),
              groupCollapsed: assign3({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign3({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix2)
            try {
              throw Error();
            } catch (x2) {
              var match2 = x2.stack.trim().match(/\n( *(at )?)/);
              prefix2 = match2 && match2[1] || "";
              suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix2 + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher = null;
          previousDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x2) {
                        var control = x2;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample2) {
                  if (sample2 && control && "string" === typeof sample2.stack)
                    return [sample2.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeUnknownElementTypeFrameInDEV(type) {
          if (null == type) return "";
          if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(
              type,
              !(!prototype || !prototype.isReactComponent)
            );
          }
          if ("string" === typeof type) return describeBuiltInComponentFrame(type);
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if ("object" === typeof type)
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE2:
                return type = describeNativeComponentFrame(type.render, false), type;
              case REACT_MEMO_TYPE2:
                return describeUnknownElementTypeFrameInDEV(type.type);
              case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x2) {
                }
            }
          return "";
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function hasValidKey(config2) {
          if (hasOwnProperty.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config2.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement2(type, key, self, source, owner, props) {
          self = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          newKey = ReactElement2(
            oldElement.type,
            newKey,
            void 0,
            void 0,
            oldElement._owner,
            oldElement.props
          );
          newKey._store.validated = oldElement._store.validated;
          return newKey;
        }
        function validateChildKeys(node2, parentType) {
          if ("object" === typeof node2 && node2 && node2.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node2))
              for (var i = 0; i < node2.length; i++) {
                var child = node2[i];
                isValidElement2(child) && validateExplicitKey(child, parentType);
              }
            else if (isValidElement2(node2))
              node2._store && (node2._store.validated = 1);
            else if (i = getIteratorFn(node2), "function" === typeof i && i !== node2.entries && (i = i.call(node2), i !== node2))
              for (; !(node2 = i.next()).done; )
                isValidElement2(node2.value) && validateExplicitKey(node2.value, parentType);
          }
        }
        function isValidElement2(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function validateExplicitKey(element, parentType) {
          if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = true;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
              var stack = describeUnknownElementTypeFrameInDEV(element.type);
              prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
              return stack;
            };
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              parentType,
              childOwner
            );
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
          }
        }
        function getCurrentComponentErrorInfo(parentType) {
          var info = "", owner = getOwner();
          owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
          info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
          return info;
        }
        function escape(key) {
          var escaperLookup = { "=": "=0", ":": "=2" };
          return "$" + key.replace(/[=:]/g, function(match2) {
            return escaperLookup[match2];
          });
        }
        function getElementKey(element, index) {
          return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
        }
        function noop$12() {
        }
        function resolveThenable(thenable) {
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
            default:
              switch ("string" === typeof thenable.status ? thenable.then(noop$12, noop$12) : (thenable.status = "pending", thenable.then(
                function(fulfilledValue) {
                  "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
                },
                function(error) {
                  "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
                }
              )), thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenable.reason;
              }
          }
          throw thenable;
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback2) {
          var type = typeof children;
          if ("undefined" === type || "boolean" === type) children = null;
          var invokeCallback = false;
          if (null === children) invokeCallback = true;
          else
            switch (type) {
              case "bigint":
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                    break;
                  case REACT_LAZY_TYPE:
                    return invokeCallback = children._init, mapIntoArray(
                      invokeCallback(children._payload),
                      array,
                      escapedPrefix,
                      nameSoFar,
                      callback2
                    );
                }
            }
          if (invokeCallback) {
            invokeCallback = children;
            callback2 = callback2(invokeCallback);
            var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
            isArrayImpl(callback2) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback2, array, escapedPrefix, "", function(c) {
              return c;
            })) : null != callback2 && (isValidElement2(callback2) && (null != callback2.key && (invokeCallback && invokeCallback.key === callback2.key || checkKeyStringCoercion(callback2.key)), escapedPrefix = cloneAndReplaceKey(
              callback2,
              escapedPrefix + (null == callback2.key || invokeCallback && invokeCallback.key === callback2.key ? "" : ("" + callback2.key).replace(
                userProvidedKeyEscapeRegex,
                "$&/"
              ) + "/") + childKey
            ), "" !== nameSoFar && null != invokeCallback && isValidElement2(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback2 = escapedPrefix), array.push(callback2));
            return 1;
          }
          invokeCallback = 0;
          childKey = "" === nameSoFar ? "." : nameSoFar + ":";
          if (isArrayImpl(children))
            for (var i = 0; i < children.length; i++)
              nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback2
              );
          else if (i = getIteratorFn(children), "function" === typeof i)
            for (i === children.entries && (didWarnAboutMaps || console.warn(
              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
            ), didWarnAboutMaps = true), children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
              nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
                nameSoFar,
                array,
                escapedPrefix,
                type,
                callback2
              );
          else if ("object" === type) {
            if ("function" === typeof children.then)
              return mapIntoArray(
                resolveThenable(children),
                array,
                escapedPrefix,
                nameSoFar,
                callback2
              );
            array = String(children);
            throw Error(
              "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
            );
          }
          return invokeCallback;
        }
        function mapChildren(children, func, context) {
          if (null == children) return children;
          var result = [], count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function lazyInitializer(payload) {
          if (-1 === payload._status) {
            var ctor = payload._result;
            ctor = ctor();
            ctor.then(
              function(moduleObject) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 1, payload._result = moduleObject;
              },
              function(error) {
                if (0 === payload._status || -1 === payload._status)
                  payload._status = 2, payload._result = error;
              }
            );
            -1 === payload._status && (payload._status = 0, payload._result = ctor);
          }
          if (1 === payload._status)
            return ctor = payload._result, void 0 === ctor && console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
              ctor
            ), "default" in ctor || console.error(
              "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
              ctor
            ), ctor.default;
          throw payload._result;
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        function noop5() {
        }
        function enqueueTask(task) {
          if (null === enqueueTaskImpl)
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              enqueueTaskImpl = (module && module[requireString]).call(
                module,
                "timers"
              ).setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback2) {
                false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                  "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
                ));
                var channel = new MessageChannel();
                channel.port1.onmessage = callback2;
                channel.port2.postMessage(void 0);
              };
            }
          return enqueueTaskImpl(task);
        }
        function aggregateErrors(errors2) {
          return 1 < errors2.length && "function" === typeof AggregateError ? new AggregateError(errors2) : errors2[0];
        }
        function popActScope(prevActQueue, prevActScopeDepth) {
          prevActScopeDepth !== actScopeDepth - 1 && console.error(
            "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
          );
          actScopeDepth = prevActScopeDepth;
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve2, reject) {
          var queue = ReactSharedInternals.actQueue;
          if (null !== queue)
            if (0 !== queue.length)
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  return recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
                });
                return;
              } catch (error) {
                ReactSharedInternals.thrownErrors.push(error);
              }
            else ReactSharedInternals.actQueue = null;
          0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve2(returnValue);
        }
        function flushActQueue(queue) {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (; i < queue.length; i++) {
                var callback2 = queue[i];
                do {
                  ReactSharedInternals.didUsePromise = false;
                  var continuation = callback2(false);
                  if (null !== continuation) {
                    if (ReactSharedInternals.didUsePromise) {
                      queue[i] = callback2;
                      queue.splice(0, i);
                      return;
                    }
                    callback2 = continuation;
                  } else break;
                } while (1);
              }
              queue.length = 0;
            } catch (error) {
              queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
            } finally {
              isFlushing = false;
            }
          }
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        Symbol.for("react.provider");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE2 = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
          isMounted: function() {
            return false;
          },
          enqueueForceUpdate: function(publicInstance) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance) {
            warnNoop(publicInstance, "setState");
          }
        }, assign3 = Object.assign, emptyObject = {};
        Object.freeze(emptyObject);
        Component4.prototype.isReactComponent = {};
        Component4.prototype.setState = function(partialState, callback2) {
          if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
            throw Error(
              "takes an object of state variables to update or a function which returns an object of state variables."
            );
          this.updater.enqueueSetState(this, partialState, callback2, "setState");
        };
        Component4.prototype.forceUpdate = function(callback2) {
          this.updater.enqueueForceUpdate(this, callback2, "forceUpdate");
        };
        var deprecatedAPIs = {
          isMounted: [
            "isMounted",
            "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
          ],
          replaceState: [
            "replaceState",
            "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
          ]
        }, fnName;
        for (fnName in deprecatedAPIs)
          deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        ComponentDummy.prototype = Component4.prototype;
        deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
        deprecatedAPIs.constructor = PureComponent;
        assign3(deprecatedAPIs, Component4.prototype);
        deprecatedAPIs.isPureReactComponent = true;
        var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = {
          H: null,
          A: null,
          T: null,
          S: null,
          actQueue: null,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false,
          didUsePromise: false,
          thrownErrors: [],
          getCurrentStack: null
        }, hasOwnProperty = Object.prototype.hasOwnProperty, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix2, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
        var didWarnAboutElementRef = {};
        var ownerHasKeyUseWarning = {}, didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback2) {
          queueMicrotask(function() {
            return queueMicrotask(callback2);
          });
        } : enqueueTask;
        exports.Children = {
          map: mapChildren,
          forEach: function(children, forEachFunc, forEachContext) {
            mapChildren(
              children,
              function() {
                forEachFunc.apply(this, arguments);
              },
              forEachContext
            );
          },
          count: function(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          },
          toArray: function(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          },
          only: function(children) {
            if (!isValidElement2(children))
              throw Error(
                "React.Children.only expected to receive a single React element child."
              );
            return children;
          }
        };
        exports.Component = Component4;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
        exports.act = function(callback2) {
          var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
          try {
            var result = callback2();
          } catch (error) {
            ReactSharedInternals.thrownErrors.push(error);
          }
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw popActScope(prevActQueue, prevActScopeDepth), callback2 = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback2;
          if (null !== result && "object" === typeof result && "function" === typeof result.then) {
            var thenable = result;
            queueSeveralMicrotasks(function() {
              didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
                "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
              ));
            });
            return {
              then: function(resolve2, reject) {
                didAwaitActCall = true;
                thenable.then(
                  function(returnValue) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    if (0 === prevActScopeDepth) {
                      try {
                        flushActQueue(queue), enqueueTask(function() {
                          return recursivelyFlushAsyncActWork(
                            returnValue,
                            resolve2,
                            reject
                          );
                        });
                      } catch (error$2) {
                        ReactSharedInternals.thrownErrors.push(error$2);
                      }
                      if (0 < ReactSharedInternals.thrownErrors.length) {
                        var _thrownError = aggregateErrors(
                          ReactSharedInternals.thrownErrors
                        );
                        ReactSharedInternals.thrownErrors.length = 0;
                        reject(_thrownError);
                      }
                    } else resolve2(returnValue);
                  },
                  function(error) {
                    popActScope(prevActQueue, prevActScopeDepth);
                    0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(
                      ReactSharedInternals.thrownErrors
                    ), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
                  }
                );
              }
            };
          }
          var returnValue$jscomp$0 = result;
          popActScope(prevActQueue, prevActScopeDepth);
          0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
            ));
          }), ReactSharedInternals.actQueue = null);
          if (0 < ReactSharedInternals.thrownErrors.length)
            throw callback2 = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback2;
          return {
            then: function(resolve2, reject) {
              didAwaitActCall = true;
              0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
                return recursivelyFlushAsyncActWork(
                  returnValue$jscomp$0,
                  resolve2,
                  reject
                );
              })) : resolve2(returnValue$jscomp$0);
            }
          };
        };
        exports.cache = function(fn) {
          return function() {
            return fn.apply(null, arguments);
          };
        };
        exports.cloneElement = function(element, config2, children) {
          if (null === element || void 0 === element)
            throw Error(
              "The argument must be a React element, but you passed " + element + "."
            );
          var props = assign3({}, element.props), key = element.key, owner = element._owner;
          if (null != config2) {
            var JSCompiler_inline_result;
            a: {
              if (hasOwnProperty.call(config2, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
                config2,
                "ref"
              ).get) && JSCompiler_inline_result.isReactWarning) {
                JSCompiler_inline_result = false;
                break a;
              }
              JSCompiler_inline_result = void 0 !== config2.ref;
            }
            JSCompiler_inline_result && (owner = getOwner());
            hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key = "" + config2.key);
            for (propName in config2)
              !hasOwnProperty.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            JSCompiler_inline_result = Array(propName);
            for (var i = 0; i < propName; i++)
              JSCompiler_inline_result[i] = arguments[i + 2];
            props.children = JSCompiler_inline_result;
          }
          props = ReactElement2(element.type, key, void 0, void 0, owner, props);
          for (key = 2; key < arguments.length; key++)
            validateChildKeys(arguments[key], props.type);
          return props;
        };
        exports.createContext = function(defaultValue) {
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = defaultValue;
          defaultValue.Consumer = {
            $$typeof: REACT_CONSUMER_TYPE,
            _context: defaultValue
          };
          defaultValue._currentRenderer = null;
          defaultValue._currentRenderer2 = null;
          return defaultValue;
        };
        exports.createElement = function(type, config2, children) {
          if (isValidElementType(type))
            for (var i = 2; i < arguments.length; i++)
              validateChildKeys(arguments[i], type);
          else {
            i = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
              i += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            if (null === type) var typeString = "null";
            else
              isArrayImpl(type) ? typeString = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", i = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type;
            console.error(
              "React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
              typeString,
              i
            );
          }
          var propName;
          i = {};
          typeString = null;
          if (null != config2)
            for (propName in didWarnAboutOldJSXRuntime || !("__self" in config2) || "key" in config2 || (didWarnAboutOldJSXRuntime = true, console.warn(
              "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
            )), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), typeString = "" + config2.key), config2)
              hasOwnProperty.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config2[propName]);
          var childrenLength = arguments.length - 2;
          if (1 === childrenLength) i.children = children;
          else if (1 < childrenLength) {
            for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++)
              childArray[_i] = arguments[_i + 2];
            Object.freeze && Object.freeze(childArray);
            i.children = childArray;
          }
          if (type && type.defaultProps)
            for (propName in childrenLength = type.defaultProps, childrenLength)
              void 0 === i[propName] && (i[propName] = childrenLength[propName]);
          typeString && defineKeyPropWarningGetter(
            i,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement2(type, typeString, void 0, void 0, getOwner(), i);
        };
        exports.createRef = function() {
          var refObject = { current: null };
          Object.seal(refObject);
          return refObject;
        };
        exports.forwardRef = function(render2) {
          null != render2 && render2.$$typeof === REACT_MEMO_TYPE2 ? console.error(
            "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
          ) : "function" !== typeof render2 ? console.error(
            "forwardRef requires a render function but was given %s.",
            null === render2 ? "null" : typeof render2
          ) : 0 !== render2.length && 2 !== render2.length && console.error(
            "forwardRef render functions accept exactly two parameters: props and ref. %s",
            1 === render2.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
          );
          null != render2 && null != render2.defaultProps && console.error(
            "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
          );
          var elementType = { $$typeof: REACT_FORWARD_REF_TYPE2, render: render2 }, ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              render2.name || render2.displayName || (Object.defineProperty(render2, "name", { value: name }), render2.displayName = name);
            }
          });
          return elementType;
        };
        exports.isValidElement = isValidElement2;
        exports.lazy = function(ctor) {
          return {
            $$typeof: REACT_LAZY_TYPE,
            _payload: { _status: -1, _result: ctor },
            _init: lazyInitializer
          };
        };
        exports.memo = function(type, compare) {
          isValidElementType(type) || console.error(
            "memo: The first argument must be a component. Instead received: %s",
            null === type ? "null" : typeof type
          );
          compare = {
            $$typeof: REACT_MEMO_TYPE2,
            type,
            compare: void 0 === compare ? null : compare
          };
          var ownName;
          Object.defineProperty(compare, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
            }
          });
          return compare;
        };
        exports.startTransition = function(scope) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop5, reportGlobalError);
          } catch (error) {
            reportGlobalError(error);
          } finally {
            null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            )), ReactSharedInternals.T = prevTransition;
          }
        };
        exports.unstable_useCacheRefresh = function() {
          return resolveDispatcher().useCacheRefresh();
        };
        exports.use = function(usable) {
          return resolveDispatcher().use(usable);
        };
        exports.useActionState = function(action, initialState6, permalink) {
          return resolveDispatcher().useActionState(
            action,
            initialState6,
            permalink
          );
        };
        exports.useCallback = function(callback2, deps) {
          return resolveDispatcher().useCallback(callback2, deps);
        };
        exports.useContext = function(Context) {
          var dispatcher = resolveDispatcher();
          Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
            "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
          );
          return dispatcher.useContext(Context);
        };
        exports.useDebugValue = function(value, formatterFn) {
          return resolveDispatcher().useDebugValue(value, formatterFn);
        };
        exports.useDeferredValue = function(value, initialValue) {
          return resolveDispatcher().useDeferredValue(value, initialValue);
        };
        exports.useEffect = function(create, deps) {
          return resolveDispatcher().useEffect(create, deps);
        };
        exports.useId = function() {
          return resolveDispatcher().useId();
        };
        exports.useImperativeHandle = function(ref, create, deps) {
          return resolveDispatcher().useImperativeHandle(ref, create, deps);
        };
        exports.useInsertionEffect = function(create, deps) {
          return resolveDispatcher().useInsertionEffect(create, deps);
        };
        exports.useLayoutEffect = function(create, deps) {
          return resolveDispatcher().useLayoutEffect(create, deps);
        };
        exports.useMemo = function(create, deps) {
          return resolveDispatcher().useMemo(create, deps);
        };
        exports.useOptimistic = function(passthrough, reducer) {
          return resolveDispatcher().useOptimistic(passthrough, reducer);
        };
        exports.useReducer = function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        };
        exports.useRef = function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        };
        exports.useState = function(initialState6) {
          return resolveDispatcher().useState(initialState6);
        };
        exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
          return resolveDispatcher().useSyncExternalStore(
            subscribe,
            getSnapshot,
            getServerSnapshot
          );
        };
        exports.useTransition = function() {
          return resolveDispatcher().useTransition();
        };
        exports.version = "19.0.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      (function() {
        function noop5() {
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function createPortal$1(children, containerInfo, implementation) {
          var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
          try {
            testStringCoercion(key);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          JSCompiler_inline_result && (console.error(
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
          ), testStringCoercion(key));
          return {
            $$typeof: REACT_PORTAL_TYPE,
            key: null == key ? null : "" + key,
            children,
            containerInfo,
            implementation
          };
        }
        function getCrossOriginStringAs(as, input) {
          if ("font" === as) return "";
          if ("string" === typeof input)
            return "use-credentials" === input ? input : "";
        }
        function getValueDescriptorExpectingObjectForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
        }
        function getValueDescriptorExpectingEnumForWarning(thing) {
          return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
        }
        function resolveDispatcher() {
          var dispatcher = ReactSharedInternals.H;
          null === dispatcher && console.error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
          return dispatcher;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React53 = require_react(), Internals = {
          d: {
            f: noop5,
            r: function() {
              throw Error(
                "Invalid form element. requestFormReset must be passed a form that was rendered by React."
              );
            },
            D: noop5,
            C: noop5,
            L: noop5,
            m: noop5,
            X: noop5,
            S: noop5,
            M: noop5
          },
          p: 0,
          findDOMNode: null
        }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React53.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        );
        exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
        exports.createPortal = function(children, container) {
          var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
            throw Error("Target container is not a DOM element.");
          return createPortal$1(children, container, null, key);
        };
        exports.flushSync = function(fn) {
          var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
          try {
            if (ReactSharedInternals.T = null, Internals.p = 2, fn)
              return fn();
          } finally {
            ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
              "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
            );
          }
        };
        exports.preconnect = function(href2, options2) {
          "string" === typeof href2 && href2 ? null != options2 && "object" !== typeof options2 ? console.error(
            "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
            getValueDescriptorExpectingEnumForWarning(options2)
          ) : null != options2 && "string" !== typeof options2.crossOrigin && console.error(
            "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
            getValueDescriptorExpectingObjectForWarning(options2.crossOrigin)
          ) : console.error(
            "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href2)
          );
          "string" === typeof href2 && (options2 ? (options2 = options2.crossOrigin, options2 = "string" === typeof options2 ? "use-credentials" === options2 ? options2 : "" : void 0) : options2 = null, Internals.d.C(href2, options2));
        };
        exports.prefetchDNS = function(href2) {
          if ("string" !== typeof href2 || !href2)
            console.error(
              "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
              getValueDescriptorExpectingObjectForWarning(href2)
            );
          else if (1 < arguments.length) {
            var options2 = arguments[1];
            "object" === typeof options2 && options2.hasOwnProperty("crossOrigin") ? console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options2)
            ) : console.error(
              "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
              getValueDescriptorExpectingEnumForWarning(options2)
            );
          }
          "string" === typeof href2 && Internals.d.D(href2);
        };
        exports.preinit = function(href2, options2) {
          "string" === typeof href2 && href2 ? null == options2 || "object" !== typeof options2 ? console.error(
            "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
            getValueDescriptorExpectingEnumForWarning(options2)
          ) : "style" !== options2.as && "script" !== options2.as && console.error(
            'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
            getValueDescriptorExpectingEnumForWarning(options2.as)
          ) : console.error(
            "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href2)
          );
          if ("string" === typeof href2 && options2 && "string" === typeof options2.as) {
            var as = options2.as, crossOrigin = getCrossOriginStringAs(as, options2.crossOrigin), integrity = "string" === typeof options2.integrity ? options2.integrity : void 0, fetchPriority = "string" === typeof options2.fetchPriority ? options2.fetchPriority : void 0;
            "style" === as ? Internals.d.S(
              href2,
              "string" === typeof options2.precedence ? options2.precedence : void 0,
              {
                crossOrigin,
                integrity,
                fetchPriority
              }
            ) : "script" === as && Internals.d.X(href2, {
              crossOrigin,
              integrity,
              fetchPriority,
              nonce: "string" === typeof options2.nonce ? options2.nonce : void 0
            });
          }
        };
        exports.preinitModule = function(href2, options2) {
          var encountered = "";
          "string" === typeof href2 && href2 || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href2) + ".");
          void 0 !== options2 && "object" !== typeof options2 ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options2) + "." : options2 && "as" in options2 && "script" !== options2.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options2.as) + ".");
          if (encountered)
            console.error(
              "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
              encountered
            );
          else
            switch (encountered = options2 && "string" === typeof options2.as ? options2.as : "script", encountered) {
              case "script":
                break;
              default:
                encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                  'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                  encountered,
                  href2
                );
            }
          if ("string" === typeof href2)
            if ("object" === typeof options2 && null !== options2) {
              if (null == options2.as || "script" === options2.as)
                encountered = getCrossOriginStringAs(
                  options2.as,
                  options2.crossOrigin
                ), Internals.d.M(href2, {
                  crossOrigin: encountered,
                  integrity: "string" === typeof options2.integrity ? options2.integrity : void 0,
                  nonce: "string" === typeof options2.nonce ? options2.nonce : void 0
                });
            } else null == options2 && Internals.d.M(href2);
        };
        exports.preload = function(href2, options2) {
          var encountered = "";
          "string" === typeof href2 && href2 || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href2) + ".");
          null == options2 || "object" !== typeof options2 ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options2) + "." : "string" === typeof options2.as && options2.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options2.as) + ".");
          encountered && console.error(
            'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
            encountered
          );
          if ("string" === typeof href2 && "object" === typeof options2 && null !== options2 && "string" === typeof options2.as) {
            encountered = options2.as;
            var crossOrigin = getCrossOriginStringAs(
              encountered,
              options2.crossOrigin
            );
            Internals.d.L(href2, encountered, {
              crossOrigin,
              integrity: "string" === typeof options2.integrity ? options2.integrity : void 0,
              nonce: "string" === typeof options2.nonce ? options2.nonce : void 0,
              type: "string" === typeof options2.type ? options2.type : void 0,
              fetchPriority: "string" === typeof options2.fetchPriority ? options2.fetchPriority : void 0,
              referrerPolicy: "string" === typeof options2.referrerPolicy ? options2.referrerPolicy : void 0,
              imageSrcSet: "string" === typeof options2.imageSrcSet ? options2.imageSrcSet : void 0,
              imageSizes: "string" === typeof options2.imageSizes ? options2.imageSizes : void 0,
              media: "string" === typeof options2.media ? options2.media : void 0
            });
          }
        };
        exports.preloadModule = function(href2, options2) {
          var encountered = "";
          "string" === typeof href2 && href2 || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href2) + ".");
          void 0 !== options2 && "object" !== typeof options2 ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options2) + "." : options2 && "as" in options2 && "string" !== typeof options2.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options2.as) + ".");
          encountered && console.error(
            'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
            encountered
          );
          "string" === typeof href2 && (options2 ? (encountered = getCrossOriginStringAs(
            options2.as,
            options2.crossOrigin
          ), Internals.d.m(href2, {
            as: "string" === typeof options2.as && "script" !== options2.as ? options2.as : void 0,
            crossOrigin: encountered,
            integrity: "string" === typeof options2.integrity ? options2.integrity : void 0
          })) : Internals.d.m(href2));
        };
        exports.requestFormReset = function(form) {
          Internals.d.r(form);
        };
        exports.unstable_batchedUpdates = function(fn, a) {
          return fn(a);
        };
        exports.useFormState = function(action, initialState6, permalink) {
          return resolveDispatcher().useFormState(action, initialState6, permalink);
        };
        exports.useFormStatus = function() {
          return resolveDispatcher().useHostTransitionStatus();
        };
        exports.version = "19.0.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.development.js
  var require_react_dom_client_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.development.js"(exports) {
      "use strict";
      (function() {
        function findHook(fiber, id) {
          for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
            fiber = fiber.next, id--;
          return fiber;
        }
        function copyWithSetImpl(obj, path, index, value) {
          if (index >= path.length) return value;
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign3({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
          return updated;
        }
        function copyWithRename(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length)
            console.warn("copyWithRename() expects paths of the same length");
          else {
            for (var i = 0; i < newPath.length - 1; i++)
              if (oldPath[i] !== newPath[i]) {
                console.warn(
                  "copyWithRename() expects paths to be the same except for the deepest key"
                );
                return;
              }
            return copyWithRenameImpl(obj, oldPath, newPath, 0);
          }
        }
        function copyWithRenameImpl(obj, oldPath, newPath, index) {
          var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign3({}, obj);
          index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
            obj[oldKey],
            oldPath,
            newPath,
            index + 1
          );
          return updated;
        }
        function copyWithDeleteImpl(obj, path, index) {
          var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign3({}, obj);
          if (index + 1 === path.length)
            return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
          updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
          return updated;
        }
        function shouldSuspendImpl() {
          return false;
        }
        function shouldErrorImpl() {
          return null;
        }
        function createFiber(tag, pendingProps, key, mode) {
          return new FiberNode(tag, pendingProps, key, mode);
        }
        function warnInvalidHookAccess() {
          console.error(
            "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
          );
        }
        function warnInvalidContextAccess() {
          console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
        }
        function noop$22() {
        }
        function warnForMissingKey() {
        }
        function setToSortedString(set7) {
          var array = [];
          set7.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        }
        function scheduleRoot(root2, element) {
          root2.context === emptyContextObject && (updateContainerSync(element, root2, null, null), flushSyncWork$1());
        }
        function scheduleRefresh(root2, update) {
          if (null !== resolveFamily) {
            var staleFamilies = update.staleFamilies;
            update = update.updatedFamilies;
            flushPassiveEffects();
            scheduleFibersWithFamiliesRecursively(
              root2.current,
              update,
              staleFamilies
            );
            flushSyncWork$1();
          }
        }
        function setRefreshHandler(handler) {
          resolveFamily = handler;
        }
        function isValidContainer(node2) {
          return !(!node2 || 1 !== node2.nodeType && 9 !== node2.nodeType && 11 !== node2.nodeType);
        }
        function getIteratorFn(maybeIterable) {
          if (null === maybeIterable || "object" !== typeof maybeIterable)
            return null;
          maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
          return "function" === typeof maybeIterable ? maybeIterable : null;
        }
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE2:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE2:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x2) {
                }
            }
          return null;
        }
        function getComponentNameFromOwner(owner) {
          return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
        }
        function getComponentNameFromFiber(fiber) {
          var type = fiber.type;
          switch (fiber.tag) {
            case 24:
              return "Cache";
            case 9:
              return (type._context.displayName || "Context") + ".Consumer";
            case 10:
              return (type.displayName || "Context") + ".Provider";
            case 18:
              return "DehydratedFragment";
            case 11:
              return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
            case 7:
              return "Fragment";
            case 26:
            case 27:
            case 5:
              return type;
            case 4:
              return "Portal";
            case 3:
              return "Root";
            case 6:
              return "Text";
            case 16:
              return getComponentNameFromType(type);
            case 8:
              return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
            case 22:
              return "Offscreen";
            case 12:
              return "Profiler";
            case 21:
              return "Scope";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 25:
              return "TracingMarker";
            case 1:
            case 0:
            case 14:
            case 15:
              if ("function" === typeof type)
                return type.displayName || type.name || null;
              if ("string" === typeof type) return type;
              break;
            case 29:
              type = fiber._debugInfo;
              if (null != type) {
                for (var i = type.length - 1; 0 <= i; i--)
                  if ("string" === typeof type[i].name) return type[i].name;
              }
              if (null !== fiber.return)
                return getComponentNameFromFiber(fiber.return);
          }
          return null;
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign3({}, props, { value: prevLog }),
              info: assign3({}, props, { value: prevInfo }),
              warn: assign3({}, props, { value: prevWarn }),
              error: assign3({}, props, { value: prevError }),
              group: assign3({}, props, { value: prevGroup }),
              groupCollapsed: assign3({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign3({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix2)
            try {
              throw Error();
            } catch (x2) {
              var match2 = x2.stack.trim().match(/\n( *(at )?)/);
              prefix2 = match2 && match2[1] || "";
              suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix2 + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher2 = null;
          previousDispatcher2 = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x2) {
                        var control = x2;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample2) {
                  if (sample2 && control && "string" === typeof sample2.stack)
                    return [sample2.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeFiber(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return describeBuiltInComponentFrame(fiber.type);
            case 16:
              return describeBuiltInComponentFrame("Lazy");
            case 13:
              return describeBuiltInComponentFrame("Suspense");
            case 19:
              return describeBuiltInComponentFrame("SuspenseList");
            case 0:
            case 15:
              return fiber = describeNativeComponentFrame(fiber.type, false), fiber;
            case 11:
              return fiber = describeNativeComponentFrame(fiber.type.render, false), fiber;
            case 1:
              return fiber = describeNativeComponentFrame(fiber.type, true), fiber;
            default:
              return "";
          }
        }
        function getStackByFiberInDevAndProd(workInProgress2) {
          try {
            var info = "";
            do {
              info += describeFiber(workInProgress2);
              var debugInfo = workInProgress2._debugInfo;
              if (debugInfo)
                for (var i = debugInfo.length - 1; 0 <= i; i--) {
                  var entry = debugInfo[i];
                  if ("string" === typeof entry.name) {
                    var JSCompiler_temp_const = info, env = entry.env;
                    var JSCompiler_inline_result = describeBuiltInComponentFrame(
                      entry.name + (env ? " [" + env + "]" : "")
                    );
                    info = JSCompiler_temp_const + JSCompiler_inline_result;
                  }
                }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2);
            return info;
          } catch (x2) {
            return "\nError generating stack: " + x2.message + "\n" + x2.stack;
          }
        }
        function getCurrentFiberOwnerNameInDevOrNull() {
          if (null === current2) return null;
          var owner = current2._debugOwner;
          return null != owner ? getComponentNameFromOwner(owner) : null;
        }
        function getCurrentFiberStackInDev() {
          return null === current2 ? "" : getStackByFiberInDevAndProd(current2);
        }
        function runWithFiberInDEV(fiber, callback2, arg0, arg1, arg2, arg3, arg4) {
          var previousFiber = current2;
          ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
          isRendering = false;
          current2 = fiber;
          try {
            return callback2(arg0, arg1, arg2, arg3, arg4);
          } finally {
            current2 = previousFiber;
          }
          throw Error(
            "runWithFiberInDEV should never be called in production. This is a bug in React."
          );
        }
        function getNearestMountedFiber(fiber) {
          var node2 = fiber, nearestMounted = fiber;
          if (fiber.alternate) for (; node2.return; ) node2 = node2.return;
          else {
            fiber = node2;
            do
              node2 = fiber, 0 !== (node2.flags & 4098) && (nearestMounted = node2.return), fiber = node2.return;
            while (fiber);
          }
          return 3 === node2.tag ? nearestMounted : null;
        }
        function getSuspenseInstanceFromFiber(fiber) {
          if (13 === fiber.tag) {
            var suspenseState = fiber.memoizedState;
            null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
            if (null !== suspenseState) return suspenseState.dehydrated;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (getNearestMountedFiber(fiber) !== fiber)
            throw Error("Unable to find node on an unmounted component.");
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            alternate = getNearestMountedFiber(fiber);
            if (null === alternate)
              throw Error("Unable to find node on an unmounted component.");
            return alternate !== fiber ? null : fiber;
          }
          for (var a = fiber, b = alternate; ; ) {
            var parentA = a.return;
            if (null === parentA) break;
            var parentB = parentA.alternate;
            if (null === parentB) {
              b = parentA.return;
              if (null !== b) {
                a = b;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              for (parentB = parentA.child; parentB; ) {
                if (parentB === a) return assertIsMounted(parentA), fiber;
                if (parentB === b) return assertIsMounted(parentA), alternate;
                parentB = parentB.sibling;
              }
              throw Error("Unable to find node on an unmounted component.");
            }
            if (a.return !== b.return) a = parentA, b = parentB;
            else {
              for (var didFindChild = false, _child = parentA.child; _child; ) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                for (_child = parentB.child; _child; ) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild)
                  throw Error(
                    "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
                  );
              }
            }
            if (a.alternate !== b)
              throw Error(
                "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
              );
          }
          if (3 !== a.tag)
            throw Error("Unable to find node on an unmounted component.");
          return a.stateNode.current === a ? fiber : alternate;
        }
        function findCurrentHostFiberImpl(node2) {
          var tag = node2.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node2;
          for (node2 = node2.child; null !== node2; ) {
            tag = findCurrentHostFiberImpl(node2);
            if (null !== tag) return tag;
            node2 = node2.sibling;
          }
          return null;
        }
        function createCursor(defaultValue) {
          return { current: defaultValue };
        }
        function pop(cursor2, fiber) {
          0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor2.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
        }
        function push(cursor2, value, fiber) {
          index$jscomp$0++;
          valueStack[index$jscomp$0] = cursor2.current;
          fiberStack[index$jscomp$0] = fiber;
          cursor2.current = value;
        }
        function requiredContext(c) {
          null === c && console.error(
            "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
          );
          return c;
        }
        function pushHostContainer(fiber, nextRootInstance) {
          push(rootInstanceStackCursor, nextRootInstance, fiber);
          push(contextFiberStackCursor, fiber, fiber);
          push(contextStackCursor, null, fiber);
          var nextRootContext = nextRootInstance.nodeType;
          switch (nextRootContext) {
            case 9:
            case 11:
              nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
              nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
              break;
            default:
              if (nextRootInstance = 8 === nextRootContext ? nextRootInstance.parentNode : nextRootInstance, nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
                nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
                  nextRootInstance,
                  nextRootContext
                );
              else
                switch (nextRootContext) {
                  case "svg":
                    nextRootInstance = HostContextNamespaceSvg;
                    break;
                  case "math":
                    nextRootInstance = HostContextNamespaceMath;
                    break;
                  default:
                    nextRootInstance = HostContextNamespaceNone;
                }
          }
          nextRootContext = nextRootContext.toLowerCase();
          nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
          nextRootContext = {
            context: nextRootInstance,
            ancestorInfo: nextRootContext
          };
          pop(contextStackCursor, fiber);
          push(contextStackCursor, nextRootContext, fiber);
        }
        function popHostContainer(fiber) {
          pop(contextStackCursor, fiber);
          pop(contextFiberStackCursor, fiber);
          pop(rootInstanceStackCursor, fiber);
        }
        function getHostContext() {
          return requiredContext(contextStackCursor.current);
        }
        function pushHostContext(fiber) {
          null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
          var context = requiredContext(contextStackCursor.current);
          var type = fiber.type;
          var nextContext = getChildHostContextProd(context.context, type);
          type = updatedAncestorInfoDev(context.ancestorInfo, type);
          nextContext = { context: nextContext, ancestorInfo: type };
          context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
        }
        function popHostContext(fiber) {
          contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
          hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
        }
        function typeName(value) {
          return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        }
        function willCoercionThrow(value) {
          try {
            return testStringCoercion(value), false;
          } catch (e) {
            return true;
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkAttributeStringCoercion(value, attributeName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
              attributeName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkCSSPropertyStringCoercion(value, propName) {
          if (willCoercionThrow(value))
            return console.error(
              "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
              propName,
              typeName(value)
            ), testStringCoercion(value);
        }
        function checkFormFieldValueStringCoercion(value) {
          if (willCoercionThrow(value))
            return console.error(
              "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
              typeName(value)
            ), testStringCoercion(value);
        }
        function injectInternals(internals) {
          if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
          if (hook.isDisabled) return true;
          if (!hook.supportsFiber)
            return console.error(
              "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
            ), true;
          try {
            rendererID = hook.inject(internals), injectedHook = hook;
          } catch (err) {
            console.error("React instrumentation encountered an error: %s.", err);
          }
          return hook.checkDCE ? true : false;
        }
        function onCommitRoot$1(root2, eventPriority) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              var didError = 128 === (root2.current.flags & 128);
              switch (eventPriority) {
                case DiscreteEventPriority:
                  var schedulerPriority = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriority = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriority = NormalPriority$1;
                  break;
                case IdleEventPriority:
                  schedulerPriority = IdlePriority;
                  break;
                default:
                  schedulerPriority = NormalPriority$1;
              }
              injectedHook.onCommitFiberRoot(
                rendererID,
                root2,
                schedulerPriority,
                didError
              );
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
        }
        function setIsStrictModeForDevtools(newIsStrictMode) {
          "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
          if (injectedHook && "function" === typeof injectedHook.setStrictMode)
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
        }
        function injectProfilingHooks(profilingHooks) {
          injectedProfilingHooks = profilingHooks;
        }
        function markCommitStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
        }
        function markComponentRenderStarted(fiber) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
        }
        function markComponentRenderStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
        }
        function markRenderStarted(lanes) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
        }
        function markRenderStopped() {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
        }
        function markStateUpdateScheduled(fiber, lane) {
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
        }
        function clz32Fallback(x2) {
          x2 >>>= 0;
          return 0 === x2 ? 32 : 31 - (log2(x2) / LN2 | 0) | 0;
        }
        function getLabelForLane(lane) {
          if (lane & 1) return "SyncHydrationLane";
          if (lane & 2) return "Sync";
          if (lane & 4) return "InputContinuousHydration";
          if (lane & 8) return "InputContinuous";
          if (lane & 16) return "DefaultHydration";
          if (lane & 32) return "Default";
          if (lane & 64) return "TransitionHydration";
          if (lane & 4194176) return "Transition";
          if (lane & 62914560) return "Retry";
          if (lane & 67108864) return "SelectiveHydration";
          if (lane & 134217728) return "IdleHydration";
          if (lane & 268435456) return "Idle";
          if (lane & 536870912) return "Offscreen";
          if (lane & 1073741824) return "Deferred";
        }
        function getHighestPriorityLanes(lanes) {
          var pendingSyncLanes = lanes & 42;
          if (0 !== pendingSyncLanes) return pendingSyncLanes;
          switch (lanes & -lanes) {
            case 1:
              return 1;
            case 2:
              return 2;
            case 4:
              return 4;
            case 8:
              return 8;
            case 16:
              return 16;
            case 32:
              return 32;
            case 64:
              return 64;
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return lanes & 4194176;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return lanes & 62914560;
            case 67108864:
              return 67108864;
            case 134217728:
              return 134217728;
            case 268435456:
              return 268435456;
            case 536870912:
              return 536870912;
            case 1073741824:
              return 0;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), lanes;
          }
        }
        function getNextLanes(root2, wipLanes) {
          var pendingLanes = root2.pendingLanes;
          if (0 === pendingLanes) return 0;
          var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, warmLanes = root2.warmLanes;
          root2 = 0 !== root2.finishedLanes;
          var nonIdlePendingLanes = pendingLanes & 134217727;
          0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root2 || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root2 || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));
          return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;
        }
        function checkIfRootIsPrerendering(root2, renderLanes2) {
          return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
        }
        function computeExpirationTime(lane, currentTime) {
          switch (lane) {
            case 1:
            case 2:
            case 4:
            case 8:
              return currentTime + 250;
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
              return currentTime + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              return -1;
            case 67108864:
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
              return -1;
            default:
              return console.error(
                "Should have found matching lanes. This is a bug in React."
              ), -1;
          }
        }
        function claimNextTransitionLane() {
          var lane = nextTransitionLane;
          nextTransitionLane <<= 1;
          0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
          return lane;
        }
        function claimNextRetryLane() {
          var lane = nextRetryLane;
          nextRetryLane <<= 1;
          0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
          return lane;
        }
        function createLaneMap(initial2) {
          for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial2);
          return laneMap;
        }
        function markRootUpdated$1(root2, updateLane) {
          root2.pendingLanes |= updateLane;
          268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
        }
        function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
          var previouslyPendingLanes = root2.pendingLanes;
          root2.pendingLanes = remainingLanes;
          root2.suspendedLanes = 0;
          root2.pingedLanes = 0;
          root2.warmLanes = 0;
          root2.expiredLanes &= remainingLanes;
          root2.entangledLanes &= remainingLanes;
          root2.errorRecoveryDisabledLanes &= remainingLanes;
          root2.shellSuspendCounter = 0;
          var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
          for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
            var index = 31 - clz32(remainingLanes), lane = 1 << index;
            entanglements[index] = 0;
            expirationTimes[index] = -1;
            var hiddenUpdatesForLane = hiddenUpdates[index];
            if (null !== hiddenUpdatesForLane)
              for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
                var update = hiddenUpdatesForLane[index];
                null !== update && (update.lane &= -536870913);
              }
            remainingLanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
          0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
        }
        function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
          root2.pendingLanes |= spawnedLane;
          root2.suspendedLanes &= ~spawnedLane;
          var spawnedLaneIndex = 31 - clz32(spawnedLane);
          root2.entangledLanes |= spawnedLane;
          root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;
        }
        function markRootEntangled(root2, entangledLanes) {
          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
          for (root2 = root2.entanglements; rootEntangledLanes; ) {
            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
            lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
            rootEntangledLanes &= ~lane;
          }
        }
        function addFiberToLanesMap(root2, fiber, lanes) {
          if (isDevToolsPresent)
            for (root2 = root2.pendingUpdatersLaneMap; 0 < lanes; ) {
              var index = 31 - clz32(lanes), lane = 1 << index;
              root2[index].add(fiber);
              lanes &= ~lane;
            }
        }
        function movePendingFibersToMemoized(root2, lanes) {
          if (isDevToolsPresent)
            for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; 0 < lanes; ) {
              var index = 31 - clz32(lanes);
              root2 = 1 << index;
              index = pendingUpdatersLaneMap[index];
              0 < index.size && (index.forEach(function(fiber) {
                var alternate = fiber.alternate;
                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
              }), index.clear());
              lanes &= ~root2;
            }
        }
        function lanesToEventPriority(lanes) {
          lanes &= -lanes;
          return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
        }
        function resolveUpdatePriority() {
          var updatePriority = ReactDOMSharedInternals.p;
          if (0 !== updatePriority) return updatePriority;
          updatePriority = window.event;
          return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
        }
        function runWithPriority(priority, fn) {
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            return ReactDOMSharedInternals.p = priority, fn();
          } finally {
            ReactDOMSharedInternals.p = previousPriority;
          }
        }
        function detachDeletedInstance(node2) {
          delete node2[internalInstanceKey];
          delete node2[internalPropsKey];
          delete node2[internalEventHandlersKey];
          delete node2[internalEventHandlerListenersKey];
          delete node2[internalEventHandlesSetKey];
        }
        function getClosestInstanceFromNode(targetNode) {
          var targetInst = targetNode[internalInstanceKey];
          if (targetInst) return targetInst;
          for (var parentNode = targetNode.parentNode; parentNode; ) {
            if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
              parentNode = targetInst.alternate;
              if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
                for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                  if (parentNode = targetNode[internalInstanceKey])
                    return parentNode;
                  targetNode = getParentSuspenseInstance(targetNode);
                }
              return targetInst;
            }
            targetNode = parentNode;
            parentNode = targetNode.parentNode;
          }
          return null;
        }
        function getInstanceFromNode(node2) {
          if (node2 = node2[internalInstanceKey] || node2[internalContainerInstanceKey]) {
            var tag = node2.tag;
            if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
              return node2;
          }
          return null;
        }
        function getNodeFromInstance(inst) {
          var tag = inst.tag;
          if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
            return inst.stateNode;
          throw Error("getNodeFromInstance: Invalid argument.");
        }
        function getResourcesFromRoot(root2) {
          var resources = root2[internalRootNodeResourcesKey];
          resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
          return resources;
        }
        function markNodeAsHoistable(node2) {
          node2[internalHoistableMarker] = true;
        }
        function registerTwoPhaseEvent(registrationName, dependencies) {
          registerDirectEvent(registrationName, dependencies);
          registerDirectEvent(registrationName + "Capture", dependencies);
        }
        function registerDirectEvent(registrationName, dependencies) {
          registrationNameDependencies[registrationName] && console.error(
            "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
            registrationName
          );
          registrationNameDependencies[registrationName] = dependencies;
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
          for (registrationName = 0; registrationName < dependencies.length; registrationName++)
            allNativeEvents.add(dependencies[registrationName]);
        }
        function checkControlledValueProps(tagName, props) {
          hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
          ) : console.error(
            "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
          ));
          props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
            "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
          );
        }
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
            return true;
          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
            return false;
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
            return validatedAttributeNameCache[attributeName] = true;
          illegalAttributeNameCache[attributeName] = true;
          console.error("Invalid attribute name: `%s`", attributeName);
          return false;
        }
        function getValueForAttributeOnCustomComponent(node2, name, expected) {
          if (isAttributeNameSafe(name)) {
            if (!node2.hasAttribute(name)) {
              switch (typeof expected) {
                case "symbol":
                case "object":
                  return expected;
                case "function":
                  return expected;
                case "boolean":
                  if (false === expected) return expected;
              }
              return void 0 === expected ? void 0 : null;
            }
            node2 = node2.getAttribute(name);
            if ("" === node2 && true === expected) return true;
            checkAttributeStringCoercion(expected, name);
            return node2 === "" + expected ? expected : node2;
          }
        }
        function setValueForAttribute(node2, name, value) {
          if (isAttributeNameSafe(name))
            if (null === value) node2.removeAttribute(name);
            else {
              switch (typeof value) {
                case "undefined":
                case "function":
                case "symbol":
                  node2.removeAttribute(name);
                  return;
                case "boolean":
                  var prefix3 = name.toLowerCase().slice(0, 5);
                  if ("data-" !== prefix3 && "aria-" !== prefix3) {
                    node2.removeAttribute(name);
                    return;
                  }
              }
              checkAttributeStringCoercion(value, name);
              node2.setAttribute(name, "" + value);
            }
        }
        function setValueForKnownAttribute(node2, name, value) {
          if (null === value) node2.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node2.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node2.setAttribute(name, "" + value);
          }
        }
        function setValueForNamespacedAttribute(node2, namespace2, name, value) {
          if (null === value) node2.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                node2.removeAttribute(name);
                return;
            }
            checkAttributeStringCoercion(value, name);
            node2.setAttributeNS(namespace2, name, "" + value);
          }
        }
        function getToStringValue(value) {
          switch (typeof value) {
            case "bigint":
            case "boolean":
            case "number":
            case "string":
            case "undefined":
              return value;
            case "object":
              return checkFormFieldValueStringCoercion(value), value;
            default:
              return "";
          }
        }
        function isCheckable(elem) {
          var type = elem.type;
          return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
        }
        function trackValueOnNode(node2) {
          var valueField = isCheckable(node2) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
            node2.constructor.prototype,
            valueField
          );
          checkFormFieldValueStringCoercion(node2[valueField]);
          var currentValue = "" + node2[valueField];
          if (!node2.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
            var get2 = descriptor.get, set7 = descriptor.set;
            Object.defineProperty(node2, valueField, {
              configurable: true,
              get: function() {
                return get2.call(this);
              },
              set: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
                set7.call(this, value);
              }
            });
            Object.defineProperty(node2, valueField, {
              enumerable: descriptor.enumerable
            });
            return {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                checkFormFieldValueStringCoercion(value);
                currentValue = "" + value;
              },
              stopTracking: function() {
                node2._valueTracker = null;
                delete node2[valueField];
              }
            };
          }
        }
        function track(node2) {
          node2._valueTracker || (node2._valueTracker = trackValueOnNode(node2));
        }
        function updateValueIfChanged(node2) {
          if (!node2) return false;
          var tracker = node2._valueTracker;
          if (!tracker) return true;
          var lastValue = tracker.getValue();
          var value = "";
          node2 && (value = isCheckable(node2) ? node2.checked ? "true" : "false" : node2.value);
          node2 = value;
          return node2 !== lastValue ? (tracker.setValue(node2), true) : false;
        }
        function getActiveElement(doc) {
          doc = doc || ("undefined" !== typeof document ? document : void 0);
          if ("undefined" === typeof doc) return null;
          try {
            return doc.activeElement || doc.body;
          } catch (e) {
            return doc.body;
          }
        }
        function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
          return value.replace(
            escapeSelectorAttributeValueInsideDoubleQuotesRegex,
            function(ch) {
              return "\\" + ch.charCodeAt(0).toString(16) + " ";
            }
          );
        }
        function validateInputProps(element, props) {
          void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
            "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnCheckedDefaultChecked = true);
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
            "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component",
            props.type
          ), didWarnValueDefaultValue$1 = true);
        }
        function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
          element.name = "";
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
          if (null != value)
            if ("number" === type) {
              if (0 === value && "" === element.value || element.value != value)
                element.value = "" + getToStringValue(value);
            } else
              element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
          else
            "submit" !== type && "reset" !== type || element.removeAttribute("value");
          null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
          null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
          null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
        }
        function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
          null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
          if (null != value || null != defaultValue) {
            if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
              return;
            defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
            value = null != value ? "" + getToStringValue(value) : defaultValue;
            isHydrating2 || value === element.value || (element.value = value);
            element.defaultValue = value;
          }
          checked = null != checked ? checked : defaultChecked;
          checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
          element.checked = isHydrating2 ? element.checked : !!checked;
          element.defaultChecked = !!checked;
          null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
        }
        function setDefaultValue(node2, type, value) {
          "number" === type && getActiveElement(node2.ownerDocument) === node2 || node2.defaultValue === "" + value || (node2.defaultValue = "" + value);
        }
        function validateOptionProps(element, props) {
          null == props.value && ("object" === typeof props.children && null !== props.children ? React53.Children.forEach(props.children, function(child) {
            null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
              "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
            ));
          }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
            "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
          )));
          null == props.selected || didWarnSelectedSetOnOption || (console.error(
            "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
          ), didWarnSelectedSetOnOption = true);
        }
        function getDeclarationErrorAddendum() {
          var ownerName = getCurrentFiberOwnerNameInDevOrNull();
          return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
        }
        function updateOptions(node2, multiple, propValue, setDefaultSelected) {
          node2 = node2.options;
          if (multiple) {
            multiple = {};
            for (var i = 0; i < propValue.length; i++)
              multiple["$" + propValue[i]] = true;
            for (propValue = 0; propValue < node2.length; propValue++)
              i = multiple.hasOwnProperty("$" + node2[propValue].value), node2[propValue].selected !== i && (node2[propValue].selected = i), i && setDefaultSelected && (node2[propValue].defaultSelected = true);
          } else {
            propValue = "" + getToStringValue(propValue);
            multiple = null;
            for (i = 0; i < node2.length; i++) {
              if (node2[i].value === propValue) {
                node2[i].selected = true;
                setDefaultSelected && (node2[i].defaultSelected = true);
                return;
              }
              null !== multiple || node2[i].disabled || (multiple = node2[i]);
            }
            null !== multiple && (multiple.selected = true);
          }
        }
        function validateSelectProps(element, props) {
          for (element = 0; element < valuePropNames.length; element++) {
            var propName = valuePropNames[element];
            if (null != props[propName]) {
              var propNameIsArray = isArrayImpl(props[propName]);
              props.multiple && !propNameIsArray ? console.error(
                "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
                propName,
                getDeclarationErrorAddendum()
              ) : !props.multiple && propNameIsArray && console.error(
                "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
                propName,
                getDeclarationErrorAddendum()
              );
            }
          }
          void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
            "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
          ), didWarnValueDefaultValue = true);
        }
        function validateTextareaProps(element, props) {
          void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
            "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
            getCurrentFiberOwnerNameInDevOrNull() || "A component"
          ), didWarnValDefaultVal = true);
          null != props.children && null == props.value && console.error(
            "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
          );
        }
        function updateTextarea(element, value, defaultValue) {
          if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
            element.defaultValue !== value && (element.defaultValue = value);
            return;
          }
          element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        }
        function initTextarea(element, value, defaultValue, children) {
          if (null == value) {
            if (null != children) {
              if (null != defaultValue)
                throw Error(
                  "If you supply `defaultValue` on a <textarea>, do not pass children."
                );
              if (isArrayImpl(children)) {
                if (1 < children.length)
                  throw Error("<textarea> can only have at most one child.");
                children = children[0];
              }
              defaultValue = children;
            }
            null == defaultValue && (defaultValue = "");
            value = defaultValue;
          }
          defaultValue = getToStringValue(value);
          element.defaultValue = defaultValue;
          children = element.textContent;
          children === defaultValue && "" !== children && null !== children && (element.value = children);
        }
        function findNotableNode(node2, indent) {
          return void 0 === node2.serverProps && 0 === node2.serverTail.length && 1 === node2.children.length && 3 < node2.distanceFromLeaf && node2.distanceFromLeaf > 15 - indent ? findNotableNode(node2.children[0], indent) : node2;
        }
        function indentation(indent) {
          return "  " + "  ".repeat(indent);
        }
        function added(indent) {
          return "+ " + "  ".repeat(indent);
        }
        function removed(indent) {
          return "- " + "  ".repeat(indent);
        }
        function describeFiberType(fiber) {
          switch (fiber.tag) {
            case 26:
            case 27:
            case 5:
              return fiber.type;
            case 16:
              return "Lazy";
            case 13:
              return "Suspense";
            case 19:
              return "SuspenseList";
            case 0:
            case 15:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            case 11:
              return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
            case 1:
              return fiber = fiber.type, fiber.displayName || fiber.name || null;
            default:
              return null;
          }
        }
        function describeTextNode(content, maxLength) {
          return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
        }
        function describeTextDiff(clientText, serverProps, indent) {
          var maxLength = 120 - 2 * indent;
          if (null === serverProps)
            return added(indent) + describeTextNode(clientText, maxLength) + "\n";
          if ("string" === typeof serverProps) {
            for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
            return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
          }
          return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
        }
        function objectName(object) {
          return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
            return p0;
          });
        }
        function describeValue(value, maxLength) {
          switch (typeof value) {
            case "string":
              return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
            case "object":
              if (null === value) return "null";
              if (isArrayImpl(value)) return "[...]";
              if (value.$$typeof === REACT_ELEMENT_TYPE)
                return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
              var name = objectName(value);
              if ("Object" === name) {
                name = "";
                maxLength -= 2;
                for (var propName in value)
                  if (value.hasOwnProperty(propName)) {
                    var jsonPropName = JSON.stringify(propName);
                    jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
                    maxLength -= propName.length - 2;
                    jsonPropName = describeValue(
                      value[propName],
                      15 > maxLength ? maxLength : 15
                    );
                    maxLength -= jsonPropName.length;
                    if (0 > maxLength) {
                      name += "" === name ? "..." : ", ...";
                      break;
                    }
                    name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
                  }
                return "{" + name + "}";
              }
              return name;
            case "function":
              return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
            default:
              return String(value);
          }
        }
        function describePropValue(value, maxLength) {
          return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
        }
        function describeExpandedElement(type, props, rowPrefix) {
          var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
          for (propName in props)
            if (props.hasOwnProperty(propName) && "children" !== propName) {
              var propValue = describePropValue(
                props[propName],
                120 - rowPrefix.length - propName.length - 1
              );
              remainingRowLength -= propName.length + propValue.length + 2;
              properties.push(propName + "=" + propValue);
            }
          return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
        }
        function describePropertiesDiff(clientObject, serverObject, indent) {
          var properties = "", remainingServerProperties = assign3({}, serverObject), propName;
          for (propName in clientObject)
            if (clientObject.hasOwnProperty(propName)) {
              delete remainingServerProperties[propName];
              var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
              serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
            }
          for (var _propName in remainingServerProperties)
            remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
              remainingServerProperties[_propName],
              120 - 2 * indent - _propName.length - 2
            ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
          return properties;
        }
        function describeElementDiff(type, clientProps, serverProps, indent) {
          var content = "", serverPropNames = /* @__PURE__ */ new Map();
          for (propName$jscomp$0 in serverProps)
            serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
              propName$jscomp$0.toLowerCase(),
              propName$jscomp$0
            );
          if (1 === serverPropNames.size && serverPropNames.has("children"))
            content += describeExpandedElement(
              type,
              clientProps,
              indentation(indent)
            );
          else {
            for (var _propName2 in clientProps)
              if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
                if (void 0 !== serverPropName) {
                  serverPropNames.delete(_propName2.toLowerCase());
                  var propName$jscomp$0 = clientProps[_propName2];
                  serverPropName = serverProps[serverPropName];
                  var clientPropValue = describePropValue(
                    propName$jscomp$0,
                    maxLength$jscomp$0
                  );
                  maxLength$jscomp$0 = describePropValue(
                    serverPropName,
                    maxLength$jscomp$0
                  );
                  "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
                    propName$jscomp$0,
                    serverPropName,
                    indent + 2
                  ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
                } else
                  content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
              }
            serverPropNames.forEach(function(propName) {
              if ("children" !== propName) {
                var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
                content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
              }
            });
            content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
          }
          type = serverProps.children;
          clientProps = clientProps.children;
          if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
            serverPropNames = "";
            if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
              serverPropNames = "" + clientProps;
            content += describeTextDiff(serverPropNames, "" + type, indent + 1);
          } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
            content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
          return content;
        }
        function describeSiblingFiber(fiber, indent) {
          var type = describeFiberType(fiber);
          if (null === type) {
            type = "";
            for (fiber = fiber.child; fiber; )
              type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
            return type;
          }
          return indentation(indent) + "<" + type + ">\n";
        }
        function describeNode(node2, indent) {
          var skipToNode = findNotableNode(node2, indent);
          if (skipToNode !== node2 && (1 !== node2.children.length || node2.children[0] !== skipToNode))
            return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
          skipToNode = "";
          var debugInfo = node2.fiber._debugInfo;
          if (debugInfo)
            for (var i = 0; i < debugInfo.length; i++) {
              var serverComponentName = debugInfo[i].name;
              "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
            }
          debugInfo = "";
          i = node2.fiber.pendingProps;
          if (6 === node2.fiber.tag)
            debugInfo = describeTextDiff(i, node2.serverProps, indent), indent++;
          else if (serverComponentName = describeFiberType(node2.fiber), null !== serverComponentName)
            if (void 0 === node2.serverProps) {
              debugInfo = indent;
              var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
              for (propName in i)
                if (i.hasOwnProperty(propName) && "children" !== propName) {
                  var propValue = describePropValue(i[propName], 15);
                  maxLength -= propName.length + propValue.length + 2;
                  if (0 > maxLength) {
                    content += " ...";
                    break;
                  }
                  content += " " + propName + "=" + propValue;
                }
              debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
              indent++;
            } else
              null === node2.serverProps ? (debugInfo = describeExpandedElement(
                serverComponentName,
                i,
                added(indent)
              ), indent++) : "string" === typeof node2.serverProps ? console.error(
                "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
              ) : (debugInfo = describeElementDiff(
                serverComponentName,
                i,
                node2.serverProps,
                indent
              ), indent++);
          var propName = "";
          i = node2.fiber.child;
          for (serverComponentName = 0; i && serverComponentName < node2.children.length; )
            maxLength = node2.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
          i && 0 < node2.children.length && (propName += indentation(indent) + "...\n");
          i = node2.serverTail;
          null === node2.serverProps && indent--;
          for (node2 = 0; node2 < i.length; node2++)
            serverComponentName = i[node2], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
              serverComponentName.type,
              serverComponentName.props,
              removed(indent)
            );
          return skipToNode + debugInfo + propName;
        }
        function describeDiff(rootNode) {
          try {
            return "\n\n" + describeNode(rootNode, 0);
          } catch (x2) {
            return "";
          }
        }
        function describeAncestors(ancestor, child, props) {
          for (var fiber = child, node2 = null, distanceFromLeaf = 0; fiber; )
            fiber === ancestor && (distanceFromLeaf = 0), node2 = {
              fiber,
              children: null !== node2 ? [node2] : [],
              serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
              serverTail: [],
              distanceFromLeaf
            }, distanceFromLeaf++, fiber = fiber.return;
          return null !== node2 ? describeDiff(node2).replaceAll(/^[+-]/gm, ">") : "";
        }
        function updatedAncestorInfoDev(oldInfo, tag) {
          oldInfo = assign3({}, oldInfo || emptyAncestorInfoDev);
          var info = { tag };
          -1 !== inScopeTags.indexOf(tag) && (oldInfo.aTagInScope = null, oldInfo.buttonTagInScope = null, oldInfo.nobrTagInScope = null);
          -1 !== buttonScopeTags.indexOf(tag) && (oldInfo.pTagInButtonScope = null);
          -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (oldInfo.listItemTagAutoclosing = null, oldInfo.dlItemTagAutoclosing = null);
          oldInfo.current = info;
          "form" === tag && (oldInfo.formTag = info);
          "a" === tag && (oldInfo.aTagInScope = info);
          "button" === tag && (oldInfo.buttonTagInScope = info);
          "nobr" === tag && (oldInfo.nobrTagInScope = info);
          "p" === tag && (oldInfo.pTagInButtonScope = info);
          "li" === tag && (oldInfo.listItemTagAutoclosing = info);
          if ("dd" === tag || "dt" === tag) oldInfo.dlItemTagAutoclosing = info;
          "#document" === tag || "html" === tag ? oldInfo.containerTagInScope = null : oldInfo.containerTagInScope || (oldInfo.containerTagInScope = info);
          return oldInfo;
        }
        function isTagValidWithParent(tag, parentTag) {
          switch (parentTag) {
            case "select":
              return "hr" === tag || "option" === tag || "optgroup" === tag || "#text" === tag;
            case "optgroup":
              return "option" === tag || "#text" === tag;
            case "option":
              return "#text" === tag;
            case "tr":
              return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "tbody":
            case "thead":
            case "tfoot":
              return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "colgroup":
              return "col" === tag || "template" === tag;
            case "table":
              return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "head":
              return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
            case "html":
              return "head" === tag || "body" === tag || "frameset" === tag;
            case "frameset":
              return "frame" === tag;
            case "#document":
              return "html" === tag;
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
            case "rp":
            case "rt":
              return -1 === impliedEndTags.indexOf(parentTag);
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "head":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return null == parentTag;
          }
          return true;
        }
        function findInvalidAncestorForTag(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        }
        function findAncestor(parent, tagName) {
          for (; parent; ) {
            switch (parent.tag) {
              case 5:
              case 26:
              case 27:
                if (parent.type === tagName) return parent;
            }
            parent = parent.return;
          }
          return null;
        }
        function validateDOMNesting(childTag, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
          var parentInfo = ancestorInfo.current;
          ancestorInfo = (parentInfo = isTagValidWithParent(
            childTag,
            parentInfo && parentInfo.tag
          ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          ancestorInfo = parentInfo || ancestorInfo;
          if (!ancestorInfo) return true;
          ancestorInfo = ancestorInfo.tag;
          var warnKey = String(!!parentInfo) + "|" + childTag + "|" + ancestorInfo;
          if (didWarn[warnKey]) return false;
          didWarn[warnKey] = true;
          var ancestor = (warnKey = current2) ? findAncestor(warnKey.return, ancestorInfo) : null;
          warnKey = null !== warnKey && null !== ancestor ? describeAncestors(ancestor, warnKey, null) : "";
          ancestor = "<" + childTag + ">";
          parentInfo ? (parentInfo = "", "table" === ancestorInfo && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
            "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
            ancestor,
            ancestorInfo,
            parentInfo,
            warnKey
          )) : console.error(
            "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
            ancestor,
            ancestorInfo,
            warnKey
          );
          return false;
        }
        function validateTextNesting(childText, parentTag) {
          if (isTagValidWithParent("#text", parentTag)) return true;
          var warnKey = "#text|" + parentTag;
          if (didWarn[warnKey]) return false;
          didWarn[warnKey] = true;
          var ancestor = (warnKey = current2) ? findAncestor(warnKey, parentTag) : null;
          warnKey = null !== warnKey && null !== ancestor ? describeAncestors(
            ancestor,
            warnKey,
            6 !== warnKey.tag ? { children: null } : null
          ) : "";
          /\S/.test(childText) ? console.error(
            "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
            parentTag,
            warnKey
          ) : console.error(
            "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
            parentTag,
            warnKey
          );
          return false;
        }
        function setTextContent(node2, text2) {
          if (text2) {
            var firstChild = node2.firstChild;
            if (firstChild && firstChild === node2.lastChild && 3 === firstChild.nodeType) {
              firstChild.nodeValue = text2;
              return;
            }
          }
          node2.textContent = text2;
        }
        function camelize2(string) {
          return string.replace(hyphenPattern, function(_, character2) {
            return character2.toUpperCase();
          });
        }
        function setValueForStyle(style2, styleName, value) {
          var isCustomProperty3 = 0 === styleName.indexOf("--");
          isCustomProperty3 || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported style property %s. Did you mean %s?",
            styleName,
            camelize2(styleName.replace(msPattern, "ms-"))
          )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
            "Unsupported vendor-prefixed style property %s. Did you mean %s?",
            styleName,
            styleName.charAt(0).toUpperCase() + styleName.slice(1)
          )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
            `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
            styleName,
            value.replace(badStyleValueWithSemicolonPattern, "")
          )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
            "`NaN` is an invalid value for the `%s` css style property.",
            styleName
          )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
            "`Infinity` is an invalid value for the `%s` css style property.",
            styleName
          ))));
          null == value || "boolean" === typeof value || "" === value ? isCustomProperty3 ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty3 ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
        }
        function setValueForStyles(node2, styles2, prevStyles) {
          if (null != styles2 && "object" !== typeof styles2)
            throw Error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          styles2 && Object.freeze(styles2);
          node2 = node2.style;
          if (null != prevStyles) {
            if (styles2) {
              var expandedUpdates = {};
              if (prevStyles) {
                for (var key in prevStyles)
                  if (prevStyles.hasOwnProperty(key) && !styles2.hasOwnProperty(key))
                    for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
                      expandedUpdates[longhands[i]] = key;
              }
              for (var _key in styles2)
                if (styles2.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles2[_key]))
                  for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
                    expandedUpdates[key[longhands]] = _key;
              _key = {};
              for (var key$jscomp$0 in styles2)
                for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
                  _key[key[longhands]] = key$jscomp$0;
              key$jscomp$0 = {};
              for (var _key2 in expandedUpdates)
                if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
                  key$jscomp$0[i] = true;
                  i = console;
                  var value = styles2[key];
                  i.error.call(
                    i,
                    "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
                    null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
                    key,
                    longhands
                  );
                }
            }
            for (var styleName in prevStyles)
              !prevStyles.hasOwnProperty(styleName) || null != styles2 && styles2.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node2.setProperty(styleName, "") : "float" === styleName ? node2.cssFloat = "" : node2[styleName] = "");
            for (var _styleName in styles2)
              _key2 = styles2[_styleName], styles2.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node2, _styleName, _key2);
          } else
            for (expandedUpdates in styles2)
              styles2.hasOwnProperty(expandedUpdates) && setValueForStyle(node2, expandedUpdates, styles2[expandedUpdates]);
        }
        function isCustomElement(tagName) {
          if (-1 === tagName.indexOf("-")) return false;
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        function getAttributeAlias(name) {
          return aliases.get(name) || name;
        }
        function validateProperty$1(tagName, name) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
            return true;
          if (rARIACamel$1.test(name)) {
            tagName = "aria-" + name.slice(4).toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
                name
              ), warnedProperties$1[name] = true;
            if (name !== tagName)
              return console.error(
                "Invalid ARIA attribute `%s`. Did you mean `%s`?",
                name,
                tagName
              ), warnedProperties$1[name] = true;
          }
          if (rARIA$1.test(name)) {
            tagName = name.toLowerCase();
            tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
            if (null == tagName) return warnedProperties$1[name] = true, false;
            name !== tagName && (console.error(
              "Unknown ARIA attribute `%s`. Did you mean `%s`?",
              name,
              tagName
            ), warnedProperties$1[name] = true);
          }
          return true;
        }
        function validateProperties$2(type, props) {
          var invalidProps = [], key;
          for (key in props)
            validateProperty$1(type, key) || invalidProps.push(key);
          props = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === invalidProps.length ? console.error(
            "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          ) : 1 < invalidProps.length && console.error(
            "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
            props,
            type
          );
        }
        function validateProperty(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
            return true;
          var lowerCasedName = name.toLowerCase();
          if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
            return console.error(
              "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
            ), warnedProperties[name] = true;
          if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
            return true;
          if (null != eventRegistry) {
            tagName = eventRegistry.possibleRegistrationNames;
            if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
              return true;
            eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
            if (null != eventRegistry)
              return console.error(
                "Invalid event handler property `%s`. Did you mean `%s`?",
                name,
                eventRegistry
              ), warnedProperties[name] = true;
            if (EVENT_NAME_REGEX.test(name))
              return console.error(
                "Unknown event handler property `%s`. It will be ignored.",
                name
              ), warnedProperties[name] = true;
          } else if (EVENT_NAME_REGEX.test(name))
            return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
              "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
              name
            ), warnedProperties[name] = true;
          if (rARIA.test(name) || rARIACamel.test(name)) return true;
          if ("innerhtml" === lowerCasedName)
            return console.error(
              "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
            ), warnedProperties[name] = true;
          if ("aria" === lowerCasedName)
            return console.error(
              "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
            ), warnedProperties[name] = true;
          if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
            return console.error(
              "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
              typeof value
            ), warnedProperties[name] = true;
          if ("number" === typeof value && isNaN(value))
            return console.error(
              "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
              name
            ), warnedProperties[name] = true;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
              return console.error(
                "Invalid DOM property `%s`. Did you mean `%s`?",
                name,
                lowerCasedName
              ), warnedProperties[name] = true;
          } else if (name !== lowerCasedName)
            return console.error(
              "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
              name,
              lowerCasedName
            ), warnedProperties[name] = true;
          switch (name) {
            case "dangerouslySetInnerHTML":
            case "children":
            case "style":
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              return true;
            case "innerText":
            case "textContent":
              return true;
          }
          switch (typeof value) {
            case "boolean":
              switch (name) {
                case "autoFocus":
                case "checked":
                case "multiple":
                case "muted":
                case "selected":
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                case "capture":
                case "download":
                case "inert":
                  return true;
                default:
                  lowerCasedName = name.toLowerCase().slice(0, 5);
                  if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
                    return true;
                  value ? console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
                    value,
                    name,
                    name,
                    value,
                    name
                  ) : console.error(
                    'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
                    value,
                    name,
                    name,
                    value,
                    name,
                    name,
                    name
                  );
                  return warnedProperties[name] = true;
              }
            case "function":
            case "symbol":
              return warnedProperties[name] = true, false;
            case "string":
              if ("false" === value || "true" === value) {
                switch (name) {
                  case "checked":
                  case "selected":
                  case "multiple":
                  case "muted":
                  case "allowFullScreen":
                  case "async":
                  case "autoPlay":
                  case "controls":
                  case "default":
                  case "defer":
                  case "disabled":
                  case "disablePictureInPicture":
                  case "disableRemotePlayback":
                  case "formNoValidate":
                  case "hidden":
                  case "loop":
                  case "noModule":
                  case "noValidate":
                  case "open":
                  case "playsInline":
                  case "readOnly":
                  case "required":
                  case "reversed":
                  case "scoped":
                  case "seamless":
                  case "itemScope":
                  case "inert":
                    break;
                  default:
                    return true;
                }
                console.error(
                  "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
                  value,
                  name,
                  "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
                  name,
                  value
                );
                warnedProperties[name] = true;
              }
          }
          return true;
        }
        function warnUnknownProperties(type, props, eventRegistry) {
          var unknownProps = [], key;
          for (key in props)
            validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
          props = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          1 === unknownProps.length ? console.error(
            "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          ) : 1 < unknownProps.length && console.error(
            "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
            props,
            type
          );
        }
        function sanitizeURL(url2) {
          return isJavaScriptProtocol.test("" + url2) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url2;
        }
        function getEventTarget(nativeEvent) {
          nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
          nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
          return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
        }
        function restoreStateOfTarget(target) {
          var internalInstance = getInstanceFromNode(target);
          if (internalInstance && (target = internalInstance.stateNode)) {
            var props = target[internalPropsKey] || null;
            a: switch (target = internalInstance.stateNode, internalInstance.type) {
              case "input":
                updateInput(
                  target,
                  props.value,
                  props.defaultValue,
                  props.defaultValue,
                  props.checked,
                  props.defaultChecked,
                  props.type,
                  props.name
                );
                internalInstance = props.name;
                if ("radio" === props.type && null != internalInstance) {
                  for (props = target; props.parentNode; ) props = props.parentNode;
                  checkAttributeStringCoercion(internalInstance, "name");
                  props = props.querySelectorAll(
                    'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                      "" + internalInstance
                    ) + '"][type="radio"]'
                  );
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                    var otherNode = props[internalInstance];
                    if (otherNode !== target && otherNode.form === target.form) {
                      var otherProps = otherNode[internalPropsKey] || null;
                      if (!otherProps)
                        throw Error(
                          "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
                        );
                      updateInput(
                        otherNode,
                        otherProps.value,
                        otherProps.defaultValue,
                        otherProps.defaultValue,
                        otherProps.checked,
                        otherProps.defaultChecked,
                        otherProps.type,
                        otherProps.name
                      );
                    }
                  }
                  for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                    otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
                }
                break a;
              case "textarea":
                updateTextarea(target, props.value, props.defaultValue);
                break a;
              case "select":
                internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
            }
          }
        }
        function batchedUpdates$1(fn, a, b) {
          if (isInsideEventHandler) return fn(a, b);
          isInsideEventHandler = true;
          try {
            var JSCompiler_inline_result = fn(a);
            return JSCompiler_inline_result;
          } finally {
            if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
              if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
                for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
            }
          }
        }
        function getListener(inst, registrationName) {
          var stateNode = inst.stateNode;
          if (null === stateNode) return null;
          var props = stateNode[internalPropsKey] || null;
          if (null === props) return null;
          stateNode = props[registrationName];
          a: switch (registrationName) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
              inst = !props;
              break a;
            default:
              inst = false;
          }
          if (inst) return null;
          if (stateNode && "function" !== typeof stateNode)
            throw Error(
              "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
            );
          return stateNode;
        }
        function getData() {
          if (fallbackText) return fallbackText;
          var start, startValue = startText, startLength = startValue.length, end2, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
          for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
          var minEnd = startLength - start;
          for (end2 = 1; end2 <= minEnd && startValue[startLength - end2] === endValue[endLength - end2]; end2++) ;
          return fallbackText = endValue.slice(start, 1 < end2 ? 1 - end2 : void 0);
        }
        function getEventCharCode(nativeEvent) {
          var keyCode = nativeEvent.keyCode;
          "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
          10 === nativeEvent && (nativeEvent = 13);
          return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
        }
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function createSyntheticEvent(Interface) {
          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
            this._reactName = reactName;
            this._targetInst = targetInst;
            this.type = reactEventType;
            this.nativeEvent = nativeEvent;
            this.target = nativeEventTarget;
            this.currentTarget = null;
            for (var propName in Interface)
              Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
            this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            return this;
          }
          assign3(SyntheticBaseEvent.prototype, {
            preventDefault: function() {
              this.defaultPrevented = true;
              var event = this.nativeEvent;
              event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
            },
            stopPropagation: function() {
              var event = this.nativeEvent;
              event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
            },
            persist: function() {
            },
            isPersistent: functionThatReturnsTrue
          });
          return SyntheticBaseEvent;
        }
        function modifierStateGetter(keyArg) {
          var nativeEvent = this.nativeEvent;
          return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
        }
        function getEventModifierState() {
          return modifierStateGetter;
        }
        function isFallbackCompositionEnd(domEventName, nativeEvent) {
          switch (domEventName) {
            case "keyup":
              return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
            case "keydown":
              return nativeEvent.keyCode !== START_KEYCODE;
            case "keypress":
            case "mousedown":
            case "focusout":
              return true;
            default:
              return false;
          }
        }
        function getDataFromCustomEvent(nativeEvent) {
          nativeEvent = nativeEvent.detail;
          return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
        }
        function getNativeBeforeInputChars(domEventName, nativeEvent) {
          switch (domEventName) {
            case "compositionend":
              return getDataFromCustomEvent(nativeEvent);
            case "keypress":
              if (nativeEvent.which !== SPACEBAR_CODE) return null;
              hasSpaceKeypress = true;
              return SPACEBAR_CHAR;
            case "textInput":
              return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
            default:
              return null;
          }
        }
        function getFallbackBeforeInputChars(domEventName, nativeEvent) {
          if (isComposing)
            return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
          switch (domEventName) {
            case "paste":
              return null;
            case "keypress":
              if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
                if (nativeEvent.char && 1 < nativeEvent.char.length)
                  return nativeEvent.char;
                if (nativeEvent.which)
                  return String.fromCharCode(nativeEvent.which);
              }
              return null;
            case "compositionend":
              return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
            default:
              return null;
          }
        }
        function isTextInputElement(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
        }
        function isEventSupported(eventNameSuffix) {
          if (!canUseDOM3) return false;
          eventNameSuffix = "on" + eventNameSuffix;
          var isSupported = eventNameSuffix in document;
          isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
          return isSupported;
        }
        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
          restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
          inst = accumulateTwoPhaseListeners(inst, "onChange");
          0 < inst.length && (nativeEvent = new SyntheticEvent(
            "onChange",
            "change",
            null,
            nativeEvent,
            target
          ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
        }
        function runEventInBatch(dispatchQueue) {
          processDispatchQueue(dispatchQueue, 0);
        }
        function getInstIfValueChanged(targetInst) {
          var targetNode = getNodeFromInstance(targetInst);
          if (updateValueIfChanged(targetNode)) return targetInst;
        }
        function getTargetInstForChangeEvent(domEventName, targetInst) {
          if ("change" === domEventName) return targetInst;
        }
        function stopWatchingForValueChange() {
          activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
        }
        function handlePropertyChange(nativeEvent) {
          if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(
              dispatchQueue,
              activeElementInst$1,
              nativeEvent,
              getEventTarget(nativeEvent)
            );
            batchedUpdates$1(runEventInBatch, dispatchQueue);
          }
        }
        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
          "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
        }
        function getTargetInstForInputEventPolyfill(domEventName) {
          if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
            return getInstIfValueChanged(activeElementInst$1);
        }
        function getTargetInstForClickEvent(domEventName, targetInst) {
          if ("click" === domEventName) return getInstIfValueChanged(targetInst);
        }
        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
          if ("input" === domEventName || "change" === domEventName)
            return getInstIfValueChanged(targetInst);
        }
        function is3(x2, y) {
          return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
        }
        function shallowEqual2(objA, objB) {
          if (objectIs(objA, objB)) return true;
          if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
            return false;
          var keysA = Object.keys(objA), keysB = Object.keys(objB);
          if (keysA.length !== keysB.length) return false;
          for (keysB = 0; keysB < keysA.length; keysB++) {
            var currentKey = keysA[keysB];
            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
              return false;
          }
          return true;
        }
        function getLeafNode(node2) {
          for (; node2 && node2.firstChild; ) node2 = node2.firstChild;
          return node2;
        }
        function getNodeForCharacterOffset(root2, offset) {
          var node2 = getLeafNode(root2);
          root2 = 0;
          for (var nodeEnd; node2; ) {
            if (3 === node2.nodeType) {
              nodeEnd = root2 + node2.textContent.length;
              if (root2 <= offset && nodeEnd >= offset)
                return { node: node2, offset: offset - root2 };
              root2 = nodeEnd;
            }
            a: {
              for (; node2; ) {
                if (node2.nextSibling) {
                  node2 = node2.nextSibling;
                  break a;
                }
                node2 = node2.parentNode;
              }
              node2 = void 0;
            }
            node2 = getLeafNode(node2);
          }
        }
        function containsNode(outerNode, innerNode) {
          return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
        }
        function getActiveElementDeep(containerInfo) {
          containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
          for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
            try {
              var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
            } catch (err) {
              JSCompiler_inline_result = false;
            }
            if (JSCompiler_inline_result) containerInfo = element.contentWindow;
            else break;
            element = getActiveElement(containerInfo.document);
          }
          return element;
        }
        function hasSelectionCapabilities(elem) {
          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
          return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
        }
        function restoreSelection(priorSelectionInformation, containerInfo) {
          var curFocusedElem = getActiveElementDeep(containerInfo);
          containerInfo = priorSelectionInformation.focusedElem;
          var priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== containerInfo && containerInfo && containerInfo.ownerDocument && containsNode(containerInfo.ownerDocument.documentElement, containerInfo)) {
            if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo)) {
              if (priorSelectionInformation = priorSelectionRange.start, curFocusedElem = priorSelectionRange.end, void 0 === curFocusedElem && (curFocusedElem = priorSelectionInformation), "selectionStart" in containerInfo)
                containerInfo.selectionStart = priorSelectionInformation, containerInfo.selectionEnd = Math.min(
                  curFocusedElem,
                  containerInfo.value.length
                );
              else if (curFocusedElem = (priorSelectionInformation = containerInfo.ownerDocument || document) && priorSelectionInformation.defaultView || window, curFocusedElem.getSelection) {
                curFocusedElem = curFocusedElem.getSelection();
                var length2 = containerInfo.textContent.length, start = Math.min(priorSelectionRange.start, length2);
                priorSelectionRange = void 0 === priorSelectionRange.end ? start : Math.min(priorSelectionRange.end, length2);
                !curFocusedElem.extend && start > priorSelectionRange && (length2 = priorSelectionRange, priorSelectionRange = start, start = length2);
                length2 = getNodeForCharacterOffset(containerInfo, start);
                var endMarker = getNodeForCharacterOffset(
                  containerInfo,
                  priorSelectionRange
                );
                length2 && endMarker && (1 !== curFocusedElem.rangeCount || curFocusedElem.anchorNode !== length2.node || curFocusedElem.anchorOffset !== length2.offset || curFocusedElem.focusNode !== endMarker.node || curFocusedElem.focusOffset !== endMarker.offset) && (priorSelectionInformation = priorSelectionInformation.createRange(), priorSelectionInformation.setStart(length2.node, length2.offset), curFocusedElem.removeAllRanges(), start > priorSelectionRange ? (curFocusedElem.addRange(priorSelectionInformation), curFocusedElem.extend(endMarker.node, endMarker.offset)) : (priorSelectionInformation.setEnd(
                  endMarker.node,
                  endMarker.offset
                ), curFocusedElem.addRange(priorSelectionInformation)));
              }
            }
            priorSelectionInformation = [];
            for (curFocusedElem = containerInfo; curFocusedElem = curFocusedElem.parentNode; )
              1 === curFocusedElem.nodeType && priorSelectionInformation.push({
                element: curFocusedElem,
                left: curFocusedElem.scrollLeft,
                top: curFocusedElem.scrollTop
              });
            "function" === typeof containerInfo.focus && containerInfo.focus();
            for (containerInfo = 0; containerInfo < priorSelectionInformation.length; containerInfo++)
              curFocusedElem = priorSelectionInformation[containerInfo], curFocusedElem.element.scrollLeft = curFocusedElem.left, curFocusedElem.element.scrollTop = curFocusedElem.top;
          }
        }
        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
          var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
          mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
            anchorNode: doc.anchorNode,
            anchorOffset: doc.anchorOffset,
            focusNode: doc.focusNode,
            focusOffset: doc.focusOffset
          }), lastSelection && shallowEqual2(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
            "onSelect",
            "select",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
        }
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
          if (!vendorPrefixes[eventName]) return eventName;
          var prefixMap = vendorPrefixes[eventName], styleProp;
          for (styleProp in prefixMap)
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
              return prefixedEventNames[eventName] = prefixMap[styleProp];
          return eventName;
        }
        function registerSimpleEvent(domEventName, reactName) {
          topLevelEventsToReactNames.set(domEventName, reactName);
          registerTwoPhaseEvent(reactName, [domEventName]);
        }
        function finishQueueingConcurrentUpdates() {
          for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
            var fiber = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var queue = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var update = concurrentQueues[i];
            concurrentQueues[i++] = null;
            var lane = concurrentQueues[i];
            concurrentQueues[i++] = null;
            if (null !== queue && null !== update) {
              var pending = queue.pending;
              null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
              queue.pending = update;
            }
            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
          }
        }
        function enqueueUpdate$1(fiber, queue, update, lane) {
          concurrentQueues[concurrentQueuesIndex++] = fiber;
          concurrentQueues[concurrentQueuesIndex++] = queue;
          concurrentQueues[concurrentQueuesIndex++] = update;
          concurrentQueues[concurrentQueuesIndex++] = lane;
          concurrentlyUpdatedLanes |= lane;
          fiber.lanes |= lane;
          fiber = fiber.alternate;
          null !== fiber && (fiber.lanes |= lane);
        }
        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
          enqueueUpdate$1(fiber, queue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function enqueueConcurrentRenderForLane(fiber, lane) {
          enqueueUpdate$1(fiber, null, null, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
          sourceFiber.lanes |= lane;
          var alternate = sourceFiber.alternate;
          null !== alternate && (alternate.lanes |= lane);
          for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
            parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
          isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [update] : sourceFiber.push(update), update.lane = lane | 536870912);
        }
        function getRootForUpdatedFiber(sourceFiber) {
          if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
            throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
              "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
            );
          nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
            "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
          ));
          null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          for (var node2 = sourceFiber, parent = node2.return; null !== parent; )
            null === node2.alternate && 0 !== (node2.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node2 = parent, parent = node2.return;
          return 3 === node2.tag ? node2.stateNode : null;
        }
        function resolveFunctionForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? type : family.current;
        }
        function resolveForwardRefForHotReloading(type) {
          if (null === resolveFamily) return type;
          var family = resolveFamily(type);
          return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE2, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
        }
        function isCompatibleFamilyForHotReloading(fiber, element) {
          if (null === resolveFamily) return false;
          var prevType = fiber.elementType;
          element = element.type;
          var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
          switch (fiber.tag) {
            case 1:
              "function" === typeof element && (needsCompareFamilies = true);
              break;
            case 0:
              "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 11:
              $$typeofNextType === REACT_FORWARD_REF_TYPE2 ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            case 14:
            case 15:
              $$typeofNextType === REACT_MEMO_TYPE2 ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
              break;
            default:
              return false;
          }
          return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
        }
        function markFailedErrorBoundaryForHotReloading(fiber) {
          null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
        }
        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
          var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
          switch (tag) {
            case 0:
            case 15:
            case 1:
              candidateType = type;
              break;
            case 11:
              candidateType = type.render;
          }
          if (null === resolveFamily)
            throw Error("Expected resolveFamily to be set during hot reload.");
          var needsRender = false;
          type = false;
          null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = true : updatedFamilies.has(candidateType) && (1 === tag ? type = true : needsRender = true)));
          null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = true);
          type && (fiber._debugNeedsRemount = true);
          if (type || needsRender)
            alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
          null === child || type || scheduleFibersWithFamiliesRecursively(
            child,
            updatedFamilies,
            staleFamilies
          );
          null !== sibling && scheduleFibersWithFamiliesRecursively(
            sibling,
            updatedFamilies,
            staleFamilies
          );
        }
        function pushNestedEffectDurations() {
          var prevEffectDuration = profilerEffectDuration;
          profilerEffectDuration = 0;
          return prevEffectDuration;
        }
        function popNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration = prevEffectDuration;
          return elapsedTime;
        }
        function bubbleNestedEffectDurations(prevEffectDuration) {
          var elapsedTime = profilerEffectDuration;
          profilerEffectDuration += prevEffectDuration;
          return elapsedTime;
        }
        function startProfilerTimer(fiber) {
          profilerStartTime = now();
          0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
        }
        function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            fiber.selfBaseDuration = elapsedTime;
            profilerStartTime = -1;
          }
        }
        function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            fiber.actualDuration += elapsedTime;
            profilerStartTime = -1;
          }
        }
        function recordEffectDuration() {
          if (0 <= profilerStartTime) {
            var elapsedTime = now() - profilerStartTime;
            profilerStartTime = -1;
            profilerEffectDuration += elapsedTime;
          }
        }
        function startEffectTimer() {
          profilerStartTime = now();
        }
        function transferActualDuration(fiber) {
          for (var child = fiber.child; child; )
            fiber.actualDuration += child.actualDuration, child = child.sibling;
        }
        function createCapturedValueAtFiber(value, source) {
          if ("object" === typeof value && null !== value) {
            var existing = CapturedStacks.get(value);
            if (void 0 !== existing) return existing;
            source = {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source)
            };
            CapturedStacks.set(value, source);
            return source;
          }
          return {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
        }
        function pushTreeFork(workInProgress2, totalChildren) {
          warnIfNotHydrating();
          forkStack[forkStackIndex++] = treeForkCount;
          forkStack[forkStackIndex++] = treeForkProvider;
          treeForkProvider = workInProgress2;
          treeForkCount = totalChildren;
        }
        function pushTreeId(workInProgress2, totalChildren, index) {
          warnIfNotHydrating();
          idStack[idStackIndex++] = treeContextId;
          idStack[idStackIndex++] = treeContextOverflow;
          idStack[idStackIndex++] = treeContextProvider;
          treeContextProvider = workInProgress2;
          var baseIdWithLeadingBit = treeContextId;
          workInProgress2 = treeContextOverflow;
          var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
          baseIdWithLeadingBit &= ~(1 << baseLength);
          index += 1;
          var length2 = 32 - clz32(totalChildren) + baseLength;
          if (30 < length2) {
            var numberOfOverflowBits = baseLength - baseLength % 5;
            length2 = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
            baseIdWithLeadingBit >>= numberOfOverflowBits;
            baseLength -= numberOfOverflowBits;
            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
            treeContextOverflow = length2 + workInProgress2;
          } else
            treeContextId = 1 << length2 | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
        }
        function pushMaterializedTreeId(workInProgress2) {
          warnIfNotHydrating();
          null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
        }
        function popTreeContext(workInProgress2) {
          for (; workInProgress2 === treeForkProvider; )
            treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
          for (; workInProgress2 === treeContextProvider; )
            treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
        }
        function warnIfNotHydrating() {
          isHydrating || console.error(
            "Expected to be hydrating. This is a bug in React. Please file an issue."
          );
        }
        function buildHydrationDiffNode(fiber, distanceFromLeaf) {
          if (null === fiber.return) {
            if (null === hydrationDiffRootDEV)
              hydrationDiffRootDEV = {
                fiber,
                children: [],
                serverProps: void 0,
                serverTail: [],
                distanceFromLeaf
              };
            else {
              if (hydrationDiffRootDEV.fiber !== fiber)
                throw Error(
                  "Saw multiple hydration diff roots in a pass. This is a bug in React."
                );
              hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
            }
            return hydrationDiffRootDEV;
          }
          var siblings = buildHydrationDiffNode(
            fiber.return,
            distanceFromLeaf + 1
          ).children;
          if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
            return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
          distanceFromLeaf = {
            fiber,
            children: [],
            serverProps: void 0,
            serverTail: [],
            distanceFromLeaf
          };
          siblings.push(distanceFromLeaf);
          return distanceFromLeaf;
        }
        function warnNonHydratedInstance(fiber, rejectedCandidate) {
          didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
        }
        function throwOnHydrationMismatch(fiber) {
          var diff = "", diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
          queueHydrationError(
            createCapturedValueAtFiber(
              Error(
                "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
              ),
              fiber
            )
          );
          throw HydrationMismatchException;
        }
        function prepareToHydrateHostInstance(fiber) {
          var didHydrate = fiber.stateNode;
          var type = fiber.type, props = fiber.memoizedProps;
          didHydrate[internalInstanceKey] = fiber;
          didHydrate[internalPropsKey] = props;
          validatePropertiesInDevelopment(type, props);
          switch (type) {
            case "dialog":
              listenToNonDelegatedEvent("cancel", didHydrate);
              listenToNonDelegatedEvent("close", didHydrate);
              break;
            case "iframe":
            case "object":
            case "embed":
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "video":
            case "audio":
              for (type = 0; type < mediaEventTypes.length; type++)
                listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
              break;
            case "source":
              listenToNonDelegatedEvent("error", didHydrate);
              break;
            case "img":
            case "image":
            case "link":
              listenToNonDelegatedEvent("error", didHydrate);
              listenToNonDelegatedEvent("load", didHydrate);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", didHydrate);
              break;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateInputProps(didHydrate, props);
              initInput(
                didHydrate,
                props.value,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name,
                true
              );
              track(didHydrate);
              break;
            case "option":
              validateOptionProps(didHydrate, props);
              break;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", didHydrate);
              validateSelectProps(didHydrate, props);
              break;
            case "textarea":
              checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
                didHydrate,
                props.value,
                props.defaultValue,
                props.children
              ), track(didHydrate);
          }
          type = props.children;
          "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$12), didHydrate = true) : didHydrate = false;
          didHydrate || throwOnHydrationMismatch(fiber);
        }
        function popToNextHostParent(fiber) {
          for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
            switch (hydrationParentFiber.tag) {
              case 3:
              case 27:
                rootOrSingletonContext = true;
                return;
              case 5:
              case 13:
                rootOrSingletonContext = false;
                return;
              default:
                hydrationParentFiber = hydrationParentFiber.return;
            }
        }
        function popHydrationState(fiber) {
          if (fiber !== hydrationParentFiber) return false;
          if (!isHydrating)
            return popToNextHostParent(fiber), isHydrating = true, false;
          var shouldClear = false, JSCompiler_temp;
          if (JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag) {
            if (JSCompiler_temp = 5 === fiber.tag)
              JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
            JSCompiler_temp = !JSCompiler_temp;
          }
          JSCompiler_temp && (shouldClear = true);
          if (shouldClear && nextHydratableInstance) {
            for (shouldClear = nextHydratableInstance; shouldClear; ) {
              JSCompiler_temp = buildHydrationDiffNode(fiber, 0);
              var description = describeHydratableInstanceForDevWarnings(shouldClear);
              JSCompiler_temp.serverTail.push(description);
              shouldClear = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratable(shouldClear.nextSibling);
            }
            throwOnHydrationMismatch(fiber);
          }
          popToNextHostParent(fiber);
          if (13 === fiber.tag) {
            fiber = fiber.memoizedState;
            fiber = null !== fiber ? fiber.dehydrated : null;
            if (!fiber)
              throw Error(
                "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
              );
            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
          } else
            nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
          return true;
        }
        function resetHydrationState() {
          nextHydratableInstance = hydrationParentFiber = null;
          didSuspendOrErrorDEV = isHydrating = false;
        }
        function queueHydrationError(error) {
          null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
        }
        function emitPendingHydrationWarnings() {
          var diffRoot = hydrationDiffRootDEV;
          null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error(
            "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
            "https://react.dev/link/hydration-mismatch",
            diffRoot
          ));
        }
        function createThenableState() {
          return { didWarnAboutUncachedPromise: false, thenables: [] };
        }
        function isThenableResolved(thenable) {
          thenable = thenable.status;
          return "fulfilled" === thenable || "rejected" === thenable;
        }
        function noop$3() {
        }
        function trackUsedThenable(thenableState2, thenable, index) {
          null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
          var trackedThenables = thenableState2.thenables;
          index = trackedThenables[index];
          void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
            "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
          )), thenable.then(noop$3, noop$3), thenable = index);
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            default:
              if ("string" === typeof thenable.status)
                thenable.then(noop$3, noop$3);
              else {
                thenableState2 = workInProgressRoot;
                if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                  throw Error(
                    "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
                  );
                thenableState2 = thenable;
                thenableState2.status = "pending";
                thenableState2.then(
                  function(fulfilledValue) {
                    if ("pending" === thenable.status) {
                      var fulfilledThenable = thenable;
                      fulfilledThenable.status = "fulfilled";
                      fulfilledThenable.value = fulfilledValue;
                    }
                  },
                  function(error) {
                    if ("pending" === thenable.status) {
                      var rejectedThenable = thenable;
                      rejectedThenable.status = "rejected";
                      rejectedThenable.reason = error;
                    }
                  }
                );
              }
              switch (thenable.status) {
                case "fulfilled":
                  return thenable.value;
                case "rejected":
                  throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
              }
              suspendedThenable = thenable;
              needsToResetSuspendedThenableDEV = true;
              throw SuspenseException;
          }
        }
        function getSuspendedThenable() {
          if (null === suspendedThenable)
            throw Error(
              "Expected a suspended thenable. This is a bug in React. Please file an issue."
            );
          var thenable = suspendedThenable;
          suspendedThenable = null;
          needsToResetSuspendedThenableDEV = false;
          return thenable;
        }
        function checkIfUseWrappedInAsyncCatch(rejectedReason) {
          if (rejectedReason === SuspenseException)
            throw Error(
              "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            );
        }
        function pushDebugInfo(debugInfo) {
          var previousDebugInfo = currentDebugInfo;
          null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
          return previousDebugInfo;
        }
        function validateFragmentProps(element, fiber, returnFiber) {
          for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
            var key = keys[i];
            if ("children" !== key && "key" !== key) {
              null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
              runWithFiberInDEV(
                fiber,
                function(erroredKey) {
                  console.error(
                    "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
                    erroredKey
                  );
                },
                key
              );
              break;
            }
          }
        }
        function unwrapThenable(thenable) {
          var index = thenableIndexCounter$1;
          thenableIndexCounter$1 += 1;
          null === thenableState$1 && (thenableState$1 = createThenableState());
          return trackUsedThenable(thenableState$1, thenable, index);
        }
        function coerceRef(workInProgress2, element) {
          element = element.props.ref;
          workInProgress2.ref = void 0 !== element ? element : null;
        }
        function throwOnInvalidObjectType(returnFiber, newChild) {
          if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
            throw Error(
              'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
            );
          returnFiber = Object.prototype.toString.call(newChild);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        function warnOnFunctionType(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
            invalidChild,
            invalidChild,
            invalidChild
          ) : console.error(
            "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
            invalidChild,
            invalidChild,
            parentName,
            invalidChild,
            parentName
          ));
        }
        function warnOnSymbolType(returnFiber, invalidChild) {
          var parentName = getComponentNameFromFiber(returnFiber) || "Component";
          ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
            "Symbols are not valid as a React child.\n  root.render(%s)",
            invalidChild
          ) : console.error(
            "Symbols are not valid as a React child.\n  <%s>%s</%s>",
            parentName,
            invalidChild,
            parentName
          ));
        }
        function createChildReconciler(shouldTrackSideEffects) {
          function deleteChild(returnFiber, childToDelete) {
            if (shouldTrackSideEffects) {
              var deletions = returnFiber.deletions;
              null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
            }
          }
          function deleteRemainingChildren(returnFiber, currentFirstChild) {
            if (!shouldTrackSideEffects) return null;
            for (; null !== currentFirstChild; )
              deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return null;
          }
          function mapRemainingChildren(currentFirstChild) {
            for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
              null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
            return existingChildren;
          }
          function useFiber(fiber, pendingProps) {
            fiber = createWorkInProgress(fiber, pendingProps);
            fiber.index = 0;
            fiber.sibling = null;
            return fiber;
          }
          function placeChild(newFiber, lastPlacedIndex, newIndex) {
            newFiber.index = newIndex;
            if (!shouldTrackSideEffects)
              return newFiber.flags |= 1048576, lastPlacedIndex;
            newIndex = newFiber.alternate;
            if (null !== newIndex)
              return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;
            newFiber.flags |= 33554434;
            return lastPlacedIndex;
          }
          function placeSingleChild(newFiber) {
            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);
            return newFiber;
          }
          function updateTextNode(returnFiber, current3, textContent, lanes) {
            if (null === current3 || 6 !== current3.tag)
              return current3 = createFiberFromText(
                textContent,
                returnFiber.mode,
                lanes
              ), current3.return = returnFiber, current3._debugOwner = returnFiber, current3._debugInfo = currentDebugInfo, current3;
            current3 = useFiber(current3, textContent);
            current3.return = returnFiber;
            current3._debugInfo = currentDebugInfo;
            return current3;
          }
          function updateElement(returnFiber, current3, element, lanes) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE)
              return current3 = updateFragment(
                returnFiber,
                current3,
                element.props.children,
                lanes,
                element.key
              ), validateFragmentProps(element, current3, returnFiber), current3;
            if (null !== current3 && (current3.elementType === elementType || isCompatibleFamilyForHotReloading(current3, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current3.type))
              return current3 = useFiber(current3, element.props), coerceRef(current3, element), current3.return = returnFiber, current3._debugOwner = element._owner, current3._debugInfo = currentDebugInfo, current3;
            current3 = createFiberFromElement(element, returnFiber.mode, lanes);
            coerceRef(current3, element);
            current3.return = returnFiber;
            current3._debugInfo = currentDebugInfo;
            return current3;
          }
          function updatePortal(returnFiber, current3, portal, lanes) {
            if (null === current3 || 4 !== current3.tag || current3.stateNode.containerInfo !== portal.containerInfo || current3.stateNode.implementation !== portal.implementation)
              return current3 = createFiberFromPortal(portal, returnFiber.mode, lanes), current3.return = returnFiber, current3._debugInfo = currentDebugInfo, current3;
            current3 = useFiber(current3, portal.children || []);
            current3.return = returnFiber;
            current3._debugInfo = currentDebugInfo;
            return current3;
          }
          function updateFragment(returnFiber, current3, fragment, lanes, key) {
            if (null === current3 || 7 !== current3.tag)
              return current3 = createFiberFromFragment(
                fragment,
                returnFiber.mode,
                lanes,
                key
              ), current3.return = returnFiber, current3._debugOwner = returnFiber, current3._debugInfo = currentDebugInfo, current3;
            current3 = useFiber(current3, fragment);
            current3.return = returnFiber;
            current3._debugInfo = currentDebugInfo;
            return current3;
          }
          function createChild(returnFiber, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return newChild = createFiberFromText(
                "" + newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return lanes = createFiberFromElement(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
                case REACT_PORTAL_TYPE:
                  return newChild = createFiberFromPortal(
                    newChild,
                    returnFiber.mode,
                    lanes
                  ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  newChild = callLazyInitInDEV(newChild);
                  returnFiber = createChild(returnFiber, newChild, lanes);
                  currentDebugInfo = _prevDebugInfo;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return lanes = createFiberFromFragment(
                  newChild,
                  returnFiber.mode,
                  lanes,
                  null
                ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
                  returnFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return createChild(
                  returnFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateSlot(returnFiber, oldFiber, newChild, lanes) {
            var key = null !== oldFiber ? oldFiber.key : null;
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber) : null;
                case REACT_PORTAL_TYPE:
                  return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
                case REACT_LAZY_TYPE:
                  return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(
                    returnFiber,
                    oldFiber,
                    newChild,
                    lanes
                  ), currentDebugInfo = key, returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
                if (null !== key) return null;
                key = pushDebugInfo(newChild._debugInfo);
                returnFiber = updateFragment(
                  returnFiber,
                  oldFiber,
                  newChild,
                  lanes,
                  null
                );
                currentDebugInfo = key;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
                  returnFiber,
                  oldFiber,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = key, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateSlot(
                  returnFiber,
                  oldFiber,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  return newIdx = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  ), currentDebugInfo = existingChildren, returnFiber;
                case REACT_PORTAL_TYPE:
                  return existingChildren = existingChildren.get(
                    null === newChild.key ? newIdx : newChild.key
                  ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
                case REACT_LAZY_TYPE:
                  var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
                  newChild = callLazyInitInDEV(newChild);
                  returnFiber = updateFromMap(
                    existingChildren,
                    returnFiber,
                    newIdx,
                    newChild,
                    lanes
                  );
                  currentDebugInfo = _prevDebugInfo7;
                  return returnFiber;
              }
              if (isArrayImpl(newChild) || getIteratorFn(newChild))
                return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes,
                  null
                ), currentDebugInfo = existingChildren, returnFiber;
              if ("function" === typeof newChild.then)
                return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = _prevDebugInfo7, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return null;
          }
          function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
            if ("object" !== typeof child || null === child) return knownKeys;
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(returnFiber, workInProgress2, child);
                var key = child.key;
                if ("string" !== typeof key) break;
                if (null === knownKeys) {
                  knownKeys = /* @__PURE__ */ new Set();
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                runWithFiberInDEV(workInProgress2, function() {
                  console.error(
                    "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.",
                    key
                  );
                });
                break;
              case REACT_LAZY_TYPE:
                child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
            }
            return knownKeys;
          }
          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
            for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(
                returnFiber,
                oldFiber,
                newChildren[newIdx],
                lanes
              );
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                newChildren[newIdx],
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (newIdx === newChildren.length)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; newIdx < newChildren.length; newIdx++)
                oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  newChildren[newIdx],
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                newChildren[newIdx],
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                newChildren[newIdx],
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
            if (null == newChildren)
              throw Error("An iterable object provided no iterator.");
            for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
              oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
              if (null === newFiber) {
                null === oldFiber && (oldFiber = nextOldFiber);
                break;
              }
              knownKeys = warnOnInvalidKey(
                returnFiber,
                newFiber,
                step.value,
                knownKeys
              );
              shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
              currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
              null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
              previousNewFiber = newFiber;
              oldFiber = nextOldFiber;
            }
            if (step.done)
              return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
            if (null === oldFiber) {
              for (; !step.done; newIdx++, step = newChildren.next())
                oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
                  returnFiber,
                  oldFiber,
                  step.value,
                  knownKeys
                ), currentFirstChild = placeChild(
                  oldFiber,
                  currentFirstChild,
                  newIdx
                ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
              isHydrating && pushTreeFork(returnFiber, newIdx);
              return resultingFirstChild;
            }
            for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
              nextOldFiber = updateFromMap(
                oldFiber,
                returnFiber,
                newIdx,
                step.value,
                lanes
              ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
                returnFiber,
                nextOldFiber,
                step.value,
                knownKeys
              ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ), currentFirstChild = placeChild(
                nextOldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
            shouldTrackSideEffects && oldFiber.forEach(function(child) {
              return deleteChild(returnFiber, child);
            });
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
            "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
            if ("object" === typeof newChild && null !== newChild) {
              switch (newChild.$$typeof) {
                case REACT_ELEMENT_TYPE:
                  var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                  a: {
                    for (var key = newChild.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === key) {
                        key = newChild.type;
                        if (key === REACT_FRAGMENT_TYPE) {
                          if (7 === currentFirstChild.tag) {
                            deleteRemainingChildren(
                              returnFiber,
                              currentFirstChild.sibling
                            );
                            lanes = useFiber(
                              currentFirstChild,
                              newChild.props.children
                            );
                            lanes.return = returnFiber;
                            lanes._debugOwner = newChild._owner;
                            lanes._debugInfo = currentDebugInfo;
                            validateFragmentProps(newChild, lanes, returnFiber);
                            returnFiber = lanes;
                            break a;
                          }
                        } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
                          currentFirstChild,
                          newChild
                        ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(currentFirstChild, newChild.props);
                          coerceRef(lanes, newChild);
                          lanes.return = returnFiber;
                          lanes._debugOwner = newChild._owner;
                          lanes._debugInfo = currentDebugInfo;
                          returnFiber = lanes;
                          break a;
                        }
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      } else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                      newChild.props.children,
                      returnFiber.mode,
                      lanes,
                      newChild.key
                    ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
                      newChild,
                      returnFiber.mode,
                      lanes
                    ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
                  }
                  returnFiber = placeSingleChild(returnFiber);
                  currentDebugInfo = prevDebugInfo;
                  return returnFiber;
                case REACT_PORTAL_TYPE:
                  a: {
                    prevDebugInfo = newChild;
                    for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
                      if (currentFirstChild.key === newChild)
                        if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            prevDebugInfo.children || []
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        } else {
                          deleteRemainingChildren(returnFiber, currentFirstChild);
                          break;
                        }
                      else deleteChild(returnFiber, currentFirstChild);
                      currentFirstChild = currentFirstChild.sibling;
                    }
                    lanes = createFiberFromPortal(
                      prevDebugInfo,
                      returnFiber.mode,
                      lanes
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                  }
                  return placeSingleChild(returnFiber);
                case REACT_LAZY_TYPE:
                  return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(
                    returnFiber,
                    currentFirstChild,
                    newChild,
                    lanes
                  ), currentDebugInfo = prevDebugInfo, returnFiber;
              }
              if (isArrayImpl(newChild))
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (getIteratorFn(newChild)) {
                prevDebugInfo = pushDebugInfo(newChild._debugInfo);
                key = getIteratorFn(newChild);
                if ("function" !== typeof key)
                  throw Error(
                    "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
                  );
                var newChildren = key.call(newChild);
                if (newChildren === newChild) {
                  if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
                    didWarnAboutGenerators || console.error(
                      "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
                    ), didWarnAboutGenerators = true;
                } else
                  newChild.entries !== key || didWarnAboutMaps || (console.error(
                    "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
                  ), didWarnAboutMaps = true);
                returnFiber = reconcileChildrenIterator(
                  returnFiber,
                  currentFirstChild,
                  newChildren,
                  lanes
                );
                currentDebugInfo = prevDebugInfo;
                return returnFiber;
              }
              if ("function" === typeof newChild.then)
                return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  unwrapThenable(newChild),
                  lanes
                ), currentDebugInfo = prevDebugInfo, returnFiber;
              if (newChild.$$typeof === REACT_CONTEXT_TYPE)
                return reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  readContextDuringReconciliation(returnFiber, newChild),
                  lanes
                );
              throwOnInvalidObjectType(returnFiber, newChild);
            }
            if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
              return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
                returnFiber,
                currentFirstChild.sibling
              ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
                prevDebugInfo,
                returnFiber.mode,
                lanes
              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
            "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
            "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
            return deleteRemainingChildren(returnFiber, currentFirstChild);
          }
          return function(returnFiber, currentFirstChild, newChild, lanes) {
            var prevDebugInfo = currentDebugInfo;
            currentDebugInfo = null;
            try {
              thenableIndexCounter$1 = 0;
              var firstChildFiber = reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
              thenableState$1 = null;
              return firstChildFiber;
            } catch (x2) {
              if (x2 === SuspenseException) throw x2;
              var fiber = createFiber(29, x2, null, returnFiber.mode);
              fiber.lanes = lanes;
              fiber.return = returnFiber;
              var debugInfo = fiber._debugInfo = currentDebugInfo;
              fiber._debugOwner = returnFiber._debugOwner;
              if (null != debugInfo) {
                for (var i = debugInfo.length - 1; 0 <= i; i--)
                  if ("string" === typeof debugInfo[i].stack) {
                    fiber._debugOwner = debugInfo[i];
                    break;
                  }
              }
              return fiber;
            } finally {
              currentDebugInfo = prevDebugInfo;
            }
          };
        }
        function pushHiddenContext(fiber, context) {
          var prevEntangledRenderLanes = entangledRenderLanes;
          push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
          push(currentTreeHiddenStackCursor, context, fiber);
          entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
        }
        function reuseHiddenContextOnStack(fiber) {
          push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
          push(
            currentTreeHiddenStackCursor,
            currentTreeHiddenStackCursor.current,
            fiber
          );
        }
        function popHiddenContext(fiber) {
          entangledRenderLanes = prevEntangledRenderLanesCursor.current;
          pop(currentTreeHiddenStackCursor, fiber);
          pop(prevEntangledRenderLanesCursor, fiber);
        }
        function pushPrimaryTreeSuspenseHandler(handler) {
          var current3 = handler.alternate;
          push(
            suspenseStackCursor,
            suspenseStackCursor.current & SubtreeSuspenseContextMask,
            handler
          );
          push(suspenseHandlerStackCursor, handler, handler);
          null === shellBoundary && (null === current3 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current3.memoizedState && (shellBoundary = handler));
        }
        function pushOffscreenSuspenseHandler(fiber) {
          if (22 === fiber.tag) {
            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
              var current3 = fiber.alternate;
              null !== current3 && null !== current3.memoizedState && (shellBoundary = fiber);
            }
          } else reuseSuspenseHandlerOnStack(fiber);
        }
        function reuseSuspenseHandlerOnStack(fiber) {
          push(suspenseStackCursor, suspenseStackCursor.current, fiber);
          push(
            suspenseHandlerStackCursor,
            suspenseHandlerStackCursor.current,
            fiber
          );
        }
        function popSuspenseHandler(fiber) {
          pop(suspenseHandlerStackCursor, fiber);
          shellBoundary === fiber && (shellBoundary = null);
          pop(suspenseStackCursor, fiber);
        }
        function findFirstSuspended(row) {
          for (var node2 = row; null !== node2; ) {
            if (13 === node2.tag) {
              var state = node2.memoizedState;
              if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || state.data === SUSPENSE_FALLBACK_START_DATA))
                return node2;
            } else if (19 === node2.tag && void 0 !== node2.memoizedProps.revealOrder) {
              if (0 !== (node2.flags & 128)) return node2;
            } else if (null !== node2.child) {
              node2.child.return = node2;
              node2 = node2.child;
              continue;
            }
            if (node2 === row) break;
            for (; null === node2.sibling; ) {
              if (null === node2.return || node2.return === row) return null;
              node2 = node2.return;
            }
            node2.sibling.return = node2.return;
            node2 = node2.sibling;
          }
          return null;
        }
        function createCache3() {
          return {
            controller: new AbortControllerLocal(),
            data: /* @__PURE__ */ new Map(),
            refCount: 0
          };
        }
        function retainCache(cache4) {
          cache4.controller.signal.aborted && console.warn(
            "A cache instance was retained after it was already freed. This likely indicates a bug in React."
          );
          cache4.refCount++;
        }
        function releaseCache(cache4) {
          cache4.refCount--;
          0 > cache4.refCount && console.warn(
            "A cache instance was released after it was already freed. This likely indicates a bug in React."
          );
          0 === cache4.refCount && scheduleCallback$2(NormalPriority, function() {
            cache4.controller.abort();
          });
        }
        function entangleAsyncAction(transition, thenable) {
          if (null === currentEntangledListeners) {
            var entangledListeners = currentEntangledListeners = [];
            currentEntangledPendingCount = 0;
            currentEntangledLane = requestTransitionLane();
            currentEntangledActionThenable = {
              status: "pending",
              value: void 0,
              then: function(resolve2) {
                entangledListeners.push(resolve2);
              }
            };
          }
          currentEntangledPendingCount++;
          thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
          return thenable;
        }
        function pingEngtangledActionScope() {
          if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
            var listeners = currentEntangledListeners;
            currentEntangledListeners = null;
            currentEntangledLane = 0;
            currentEntangledActionThenable = null;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
          }
        }
        function chainThenableValue(thenable, result) {
          var listeners = [], thenableWithOverride = {
            status: "pending",
            value: null,
            reason: null,
            then: function(resolve2) {
              listeners.push(resolve2);
            }
          };
          thenable.then(
            function() {
              thenableWithOverride.status = "fulfilled";
              thenableWithOverride.value = result;
              for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
            },
            function(error) {
              thenableWithOverride.status = "rejected";
              thenableWithOverride.reason = error;
              for (error = 0; error < listeners.length; error++)
                (0, listeners[error])(void 0);
            }
          );
          return thenableWithOverride;
        }
        function peekCacheFromPool() {
          var cacheResumedFromPreviousRender = resumedCache.current;
          return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
        }
        function pushTransition(offscreenWorkInProgress, prevCachePool) {
          null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
        }
        function getSuspendedCache() {
          var cacheFromPool = peekCacheFromPool();
          return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
        }
        function mountHookTypesDev() {
          var hookName = currentHookNameInDev;
          null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
        }
        function updateHookTypesDev() {
          var hookName = currentHookNameInDev;
          if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
            var componentName2 = getComponentNameFromFiber(
              currentlyRenderingFiber$1
            );
            if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
              for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
                var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
                for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
                  oldHookName += " ";
                oldHookName += newHookName + "\n";
                table += oldHookName;
              }
              console.error(
                "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
                componentName2,
                table
              );
            }
          }
        }
        function checkDepsAreArrayDev(deps) {
          void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
            "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
            currentHookNameInDev,
            typeof deps
          );
        }
        function warnOnUseFormStateInDev() {
          var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber$1);
          didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
            "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
            componentName2
          ));
        }
        function throwInvalidHookError() {
          throw Error(
            "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
          );
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (ignorePreviousDependencies) return false;
          if (null === prevDeps)
            return console.error(
              "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
              currentHookNameInDev
            ), false;
          nextDeps.length !== prevDeps.length && console.error(
            "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
            currentHookNameInDev,
            "[" + prevDeps.join(", ") + "]",
            "[" + nextDeps.join(", ") + "]"
          );
          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
            if (!objectIs(nextDeps[i], prevDeps[i])) return false;
          return true;
        }
        function renderWithHooks(current3, workInProgress2, Component4, props, secondArg, nextRenderLanes) {
          renderLanes = nextRenderLanes;
          currentlyRenderingFiber$1 = workInProgress2;
          hookTypesDev = null !== current3 ? current3._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current3 && current3.type !== workInProgress2.type;
          if ("[object AsyncFunction]" === Object.prototype.toString.call(Component4) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component4))
            nextRenderLanes = getComponentNameFromFiber(
              currentlyRenderingFiber$1
            ), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
              "async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
            ));
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.lanes = 0;
          ReactSharedInternals.H = null !== current3 && null !== current3.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
          shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
          var children = callComponentInDEV(Component4, props, secondArg);
          shouldDoubleInvokeUserFnsInHooksDEV = false;
          didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
            workInProgress2,
            Component4,
            props,
            secondArg
          ));
          if (nextRenderLanes) {
            setIsStrictModeForDevtools(true);
            try {
              children = renderWithHooksAgain(
                workInProgress2,
                Component4,
                props,
                secondArg
              );
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          finishRenderingHooks(current3, workInProgress2);
          return children;
        }
        function finishRenderingHooks(current3, workInProgress2) {
          workInProgress2._debugHookTypes = hookTypesDev;
          null === workInProgress2.dependencies ? null !== thenableState && (workInProgress2.dependencies = {
            lanes: 0,
            firstContext: null,
            _debugThenableState: thenableState
          }) : workInProgress2.dependencies._debugThenableState = thenableState;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
          renderLanes = 0;
          hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
          hookTypesUpdateIndexDev = -1;
          null !== current3 && (current3.flags & 31457280) !== (workInProgress2.flags & 31457280) && console.error(
            "Internal React error: Expected static flag was missing. Please notify the React team."
          );
          didScheduleRenderPhaseUpdate = false;
          thenableIndexCounter = 0;
          thenableState = null;
          if (didRenderTooFewHooks)
            throw Error(
              "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
            );
          null === current3 || didReceiveUpdate || (current3 = current3.dependencies, null !== current3 && checkIfContextChanged(current3) && (didReceiveUpdate = true));
          needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current3 = true) : current3 = false;
          current3 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
            "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
          )));
        }
        function renderWithHooksAgain(workInProgress2, Component4, props, secondArg) {
          currentlyRenderingFiber$1 = workInProgress2;
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
            thenableIndexCounter = 0;
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            if (numberOfReRenders >= RE_RENDER_LIMIT)
              throw Error(
                "Too many re-renders. React limits the number of renders to prevent an infinite loop."
              );
            numberOfReRenders += 1;
            ignorePreviousDependencies = false;
            workInProgressHook = currentHook = null;
            if (null != workInProgress2.updateQueue) {
              var children = workInProgress2.updateQueue;
              children.lastEffect = null;
              children.events = null;
              children.stores = null;
              null != children.memoCache && (children.memoCache.index = 0);
            }
            hookTypesUpdateIndexDev = -1;
            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
            children = callComponentInDEV(Component4, props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
          return children;
        }
        function TransitionAwareHostComponent() {
          var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
          maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
          dispatcher = dispatcher.useState()[0];
          (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);
          return maybeThenable;
        }
        function checkDidRenderIdHook() {
          var didRenderIdHook = 0 !== localIdCounter;
          localIdCounter = 0;
          return didRenderIdHook;
        }
        function bailoutHooks(current3, workInProgress2, lanes) {
          workInProgress2.updateQueue = current3.updateQueue;
          workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -201328645 : workInProgress2.flags & -2053;
          current3.lanes &= ~lanes;
        }
        function resetHooksOnUnwind(workInProgress2) {
          if (didScheduleRenderPhaseUpdate) {
            for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
              var queue = workInProgress2.queue;
              null !== queue && (queue.pending = null);
              workInProgress2 = workInProgress2.next;
            }
            didScheduleRenderPhaseUpdate = false;
          }
          renderLanes = 0;
          hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          thenableIndexCounter = localIdCounter = 0;
          thenableState = null;
        }
        function mountWorkInProgressHook() {
          var hook = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
          return workInProgressHook;
        }
        function updateWorkInProgressHook() {
          if (null === currentHook) {
            var nextCurrentHook = currentlyRenderingFiber$1.alternate;
            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
          } else nextCurrentHook = currentHook.next;
          var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;
          if (null !== nextWorkInProgressHook)
            workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
          else {
            if (null === nextCurrentHook) {
              if (null === currentlyRenderingFiber$1.alternate)
                throw Error(
                  "Update hook called on initial render. This is likely a bug in React. Please file an issue."
                );
              throw Error("Rendered more hooks than during the previous render.");
            }
            currentHook = nextCurrentHook;
            nextCurrentHook = {
              memoizedState: currentHook.memoizedState,
              baseState: currentHook.baseState,
              baseQueue: currentHook.baseQueue,
              queue: currentHook.queue,
              next: null
            };
            null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
          }
          return workInProgressHook;
        }
        function useThenable(thenable) {
          var index = thenableIndexCounter;
          thenableIndexCounter += 1;
          null === thenableState && (thenableState = createThenableState());
          thenable = trackUsedThenable(thenableState, thenable, index);
          index = currentlyRenderingFiber$1;
          null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
          return thenable;
        }
        function use(usable) {
          if (null !== usable && "object" === typeof usable) {
            if ("function" === typeof usable.then) return useThenable(usable);
            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
          }
          throw Error("An unsupported type was passed to use(): " + String(usable));
        }
        function useMemoCache(size) {
          var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;
          null !== updateQueue && (memoCache = updateQueue.memoCache);
          if (null == memoCache) {
            var current3 = currentlyRenderingFiber$1.alternate;
            null !== current3 && (current3 = current3.updateQueue, null !== current3 && (current3 = current3.memoCache, null != current3 && (memoCache = {
              data: current3.data.map(function(array) {
                return array.slice();
              }),
              index: 0
            })));
          }
          null == memoCache && (memoCache = { data: [], index: 0 });
          null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);
          updateQueue.memoCache = memoCache;
          updateQueue = memoCache.data[memoCache.index];
          if (void 0 === updateQueue || ignorePreviousDependencies)
            for (updateQueue = memoCache.data[memoCache.index] = Array(size), current3 = 0; current3 < size; current3++)
              updateQueue[current3] = REACT_MEMO_CACHE_SENTINEL;
          else
            updateQueue.length !== size && console.error(
              "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
              updateQueue.length,
              size
            );
          memoCache.index++;
          return updateQueue;
        }
        function basicStateReducer(state, action) {
          return "function" === typeof action ? action(state) : action;
        }
        function mountReducer(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState6 = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState6 = initialArg;
          hook.memoizedState = hook.baseState = initialState6;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState6
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber$1,
            reducer
          );
          return [hook.memoizedState, reducer];
        }
        function updateReducer(reducer) {
          var hook = updateWorkInProgressHook();
          return updateReducerImpl(hook, currentHook, reducer);
        }
        function updateReducerImpl(hook, current3, reducer) {
          var queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
          if (null !== pendingQueue) {
            if (null !== baseQueue) {
              var baseFirst = baseQueue.next;
              baseQueue.next = pendingQueue.next;
              pendingQueue.next = baseFirst;
            }
            current3.baseQueue !== baseQueue && console.error(
              "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
            );
            current3.baseQueue = baseQueue = pendingQueue;
            queue.pending = null;
          }
          pendingQueue = hook.baseState;
          if (null === baseQueue) hook.memoizedState = pendingQueue;
          else {
            current3 = baseQueue.next;
            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current3, didReadFromEntangledAsyncAction2 = false;
            do {
              var updateLane = update.lane & -536870913;
              if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
                var revertLane = update.revertLane;
                if (0 === revertLane)
                  null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                    lane: 0,
                    revertLane: 0,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                else if ((renderLanes & revertLane) === revertLane) {
                  update = update.next;
                  revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
                  continue;
                } else
                  updateLane = {
                    lane: 0,
                    revertLane: update.revertLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
                updateLane = update.action;
                shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
                pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
              } else
                revertLane = {
                  lane: updateLane,
                  revertLane: update.revertLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
              update = update.next;
            } while (null !== update && update !== current3);
            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
              throw reducer;
            hook.memoizedState = pendingQueue;
            hook.baseState = baseFirst;
            hook.baseQueue = newBaseQueueLast;
            queue.lastRenderedState = pendingQueue;
          }
          null === baseQueue && (queue.lanes = 0);
          return [hook.memoizedState, queue.dispatch];
        }
        function rerenderReducer(reducer) {
          var hook = updateWorkInProgressHook(), queue = hook.queue;
          if (null === queue)
            throw Error(
              "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
            );
          queue.lastRenderedReducer = reducer;
          var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
          if (null !== lastRenderPhaseUpdate) {
            queue.pending = null;
            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
            do
              newState = reducer(newState, update.action), update = update.next;
            while (update !== lastRenderPhaseUpdate);
            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
            hook.memoizedState = newState;
            null === hook.baseQueue && (hook.baseState = newState);
            queue.lastRenderedState = newState;
          }
          return [newState, dispatch];
        }
        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            var nextSnapshot = getServerSnapshot();
            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
              "The result of getServerSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          } else {
            nextSnapshot = getSnapshot();
            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true));
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
          hook.memoizedState = nextSnapshot;
          getServerSnapshot = { value: nextSnapshot, getSnapshot };
          hook.queue = getServerSnapshot;
          mountEffect(
            subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
            [subscribe]
          );
          fiber.flags |= 2048;
          pushEffect(
            HasEffect | Passive,
            updateStoreInstance.bind(
              null,
              fiber,
              getServerSnapshot,
              nextSnapshot,
              getSnapshot
            ),
            { destroy: void 0 },
            null
          );
          return nextSnapshot;
        }
        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
          if (isHydrating$jscomp$0) {
            if (void 0 === getServerSnapshot)
              throw Error(
                "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
              );
            getServerSnapshot = getServerSnapshot();
          } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          if (cachedSnapshot = !objectIs(
            (currentHook || hook).memoizedState,
            getServerSnapshot
          ))
            hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
          hook = hook.queue;
          var create = subscribeToStore.bind(null, fiber, hook, subscribe);
          updateEffectImpl(2048, Passive, create, [subscribe]);
          if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
            fiber.flags |= 2048;
            pushEffect(
              HasEffect | Passive,
              updateStoreInstance.bind(
                null,
                fiber,
                hook,
                getServerSnapshot,
                getSnapshot
              ),
              { destroy: void 0 },
              null
            );
            if (null === workInProgressRoot)
              throw Error(
                "Expected a work-in-progress root. This is a bug in React. Please file an issue."
              );
            isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          return getServerSnapshot;
        }
        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
          fiber.flags |= 16384;
          fiber = { getSnapshot, value: renderedSnapshot };
          getSnapshot = currentlyRenderingFiber$1.updateQueue;
          null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
        }
        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
          inst.value = nextSnapshot;
          inst.getSnapshot = getSnapshot;
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        }
        function subscribeToStore(fiber, inst, subscribe) {
          return subscribe(function() {
            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
          });
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error) {
            return true;
          }
        }
        function forceStoreRerender(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        }
        function mountStateImpl(initialState6) {
          var hook = mountWorkInProgressHook();
          if ("function" === typeof initialState6) {
            var initialStateInitializer = initialState6;
            initialState6 = initialStateInitializer();
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                initialStateInitializer();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          hook.memoizedState = hook.baseState = initialState6;
          hook.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialState6
          };
          return hook;
        }
        function mountState(initialState6) {
          initialState6 = mountStateImpl(initialState6);
          var queue = initialState6.queue, dispatch = dispatchSetState.bind(
            null,
            currentlyRenderingFiber$1,
            queue
          );
          queue.dispatch = dispatch;
          return [initialState6.memoizedState, dispatch];
        }
        function mountOptimistic(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber$1,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        }
        function updateOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        }
        function updateOptimisticImpl(hook, current3, passthrough, reducer) {
          hook.baseState = passthrough;
          return updateReducerImpl(
            hook,
            currentHook,
            "function" === typeof reducer ? reducer : basicStateReducer
          );
        }
        function rerenderOptimistic(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        }
        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
          if (isRenderPhaseUpdate(fiber))
            throw Error("Cannot update form state while rendering.");
          fiber = actionQueue.action;
          if (null !== fiber) {
            var actionNode = {
              payload,
              action: fiber,
              next: null,
              isTransition: true,
              status: "pending",
              value: null,
              reason: null,
              listeners: [],
              then: function(listener3) {
                actionNode.listeners.push(listener3);
              }
            };
            null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
            setState(actionNode);
            setPendingState = actionQueue.pending;
            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
          }
        }
        function runActionStateAction(actionQueue, node2) {
          var action = node2.action, payload = node2.payload, prevState = actionQueue.state;
          if (node2.isTransition) {
            var prevTransition = ReactSharedInternals.T, currentTransition = {};
            ReactSharedInternals.T = currentTransition;
            ReactSharedInternals.T._updatedFibers = /* @__PURE__ */ new Set();
            try {
              var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
              null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
              handleActionReturnValue(actionQueue, node2, returnValue);
            } catch (error) {
              onActionError(actionQueue, node2, error);
            } finally {
              ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
                "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
              ));
            }
          } else
            try {
              currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node2, currentTransition);
            } catch (error$3) {
              onActionError(actionQueue, node2, error$3);
            }
        }
        function handleActionReturnValue(actionQueue, node2, returnValue) {
          null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(
            function(nextState) {
              onActionSuccess(actionQueue, node2, nextState);
            },
            function(error) {
              return onActionError(actionQueue, node2, error);
            }
          ), node2.isTransition || console.error(
            "An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`"
          )) : onActionSuccess(actionQueue, node2, returnValue);
        }
        function onActionSuccess(actionQueue, actionNode, nextState) {
          actionNode.status = "fulfilled";
          actionNode.value = nextState;
          notifyActionListeners(actionNode);
          actionQueue.state = nextState;
          actionNode = actionQueue.pending;
          null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
        }
        function onActionError(actionQueue, actionNode, error) {
          var last = actionQueue.pending;
          actionQueue.pending = null;
          if (null !== last) {
            last = last.next;
            do
              actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
            while (actionNode !== last);
          }
          actionQueue.action = null;
        }
        function notifyActionListeners(actionNode) {
          actionNode = actionNode.listeners;
          for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
        }
        function actionStateReducer(oldState, newState) {
          return newState;
        }
        function mountActionState(action, initialStateProp) {
          if (isHydrating) {
            var ssrFormState = workInProgressRoot.formState;
            if (null !== ssrFormState) {
              a: {
                var isMatching = currentlyRenderingFiber$1;
                if (isHydrating) {
                  if (nextHydratableInstance) {
                    b: {
                      var markerInstance = nextHydratableInstance;
                      for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
                        if (!inRootOrSingleton) {
                          markerInstance = null;
                          break b;
                        }
                        markerInstance = getNextHydratable(
                          markerInstance.nextSibling
                        );
                        if (null === markerInstance) {
                          markerInstance = null;
                          break b;
                        }
                      }
                      inRootOrSingleton = markerInstance.data;
                      markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
                    }
                    if (markerInstance) {
                      nextHydratableInstance = getNextHydratable(
                        markerInstance.nextSibling
                      );
                      isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                      break a;
                    }
                  }
                  throwOnHydrationMismatch(isMatching);
                }
                isMatching = false;
              }
              isMatching && (initialStateProp = ssrFormState[0]);
            }
          }
          ssrFormState = mountWorkInProgressHook();
          ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
          isMatching = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: actionStateReducer,
            lastRenderedState: initialStateProp
          };
          ssrFormState.queue = isMatching;
          ssrFormState = dispatchSetState.bind(
            null,
            currentlyRenderingFiber$1,
            isMatching
          );
          isMatching.dispatch = ssrFormState;
          isMatching = mountStateImpl(false);
          inRootOrSingleton = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber$1,
            false,
            isMatching.queue
          );
          isMatching = mountWorkInProgressHook();
          markerInstance = {
            state: initialStateProp,
            dispatch: null,
            action,
            pending: null
          };
          isMatching.queue = markerInstance;
          ssrFormState = dispatchActionState.bind(
            null,
            currentlyRenderingFiber$1,
            markerInstance,
            inRootOrSingleton,
            ssrFormState
          );
          markerInstance.dispatch = ssrFormState;
          isMatching.memoizedState = action;
          return [initialStateProp, ssrFormState, false];
        }
        function updateActionState(action) {
          var stateHook = updateWorkInProgressHook();
          return updateActionStateImpl(stateHook, currentHook, action);
        }
        function updateActionStateImpl(stateHook, currentStateHook, action) {
          currentStateHook = updateReducerImpl(
            stateHook,
            currentStateHook,
            actionStateReducer
          )[0];
          stateHook = updateReducer(basicStateReducer)[0];
          currentStateHook = "object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;
          var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;
          action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(
            HasEffect | Passive,
            actionStateActionEffect.bind(null, actionQueue, action),
            { destroy: void 0 },
            null
          ));
          return [currentStateHook, dispatch, stateHook];
        }
        function actionStateActionEffect(actionQueue, action) {
          actionQueue.action = action;
        }
        function rerenderActionState(action) {
          var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
          if (null !== currentStateHook)
            return updateActionStateImpl(stateHook, currentStateHook, action);
          updateWorkInProgressHook();
          stateHook = stateHook.memoizedState;
          currentStateHook = updateWorkInProgressHook();
          var dispatch = currentStateHook.queue.dispatch;
          currentStateHook.memoizedState = action;
          return [stateHook, dispatch, false];
        }
        function pushEffect(tag, create, inst, deps) {
          tag = { tag, create, inst, deps, next: null };
          create = currentlyRenderingFiber$1.updateQueue;
          null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);
          inst = create.lastEffect;
          null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);
          return tag;
        }
        function mountRef(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        }
        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = mountWorkInProgressHook();
          currentlyRenderingFiber$1.flags |= fiberFlags;
          hook.memoizedState = pushEffect(
            HasEffect | hookFlags,
            create,
            { destroy: void 0 },
            void 0 === deps ? null : deps
          );
        }
        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var inst = hook.memoizedState.inst;
          null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(
            HasEffect | hookFlags,
            create,
            inst,
            deps
          ));
        }
        function mountEffect(create, deps) {
          (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
        }
        function mountLayoutEffect(create, deps) {
          var fiberFlags = 4194308;
          (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 67108864);
          return mountEffectImpl(fiberFlags, Layout, create, deps);
        }
        function imperativeHandleEffect(create, ref) {
          if ("function" === typeof ref) {
            create = create();
            var refCleanup = ref(create);
            return function() {
              "function" === typeof refCleanup ? refCleanup() : ref(null);
            };
          }
          if (null !== ref && void 0 !== ref)
            return ref.hasOwnProperty("current") || console.error(
              "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
              "an object with keys {" + Object.keys(ref).join(", ") + "}"
            ), create = create(), ref.current = create, function() {
              ref.current = null;
            };
        }
        function mountImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          var fiberFlags = 4194308;
          (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 67108864);
          mountEffectImpl(
            fiberFlags,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function updateImperativeHandle(ref, create, deps) {
          "function" !== typeof create && console.error(
            "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
            null !== create ? typeof create : "null"
          );
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          updateEffectImpl(
            4,
            Layout,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        }
        function mountCallback(callback2, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback2,
            void 0 === deps ? null : deps
          ];
          return callback2;
        }
        function updateCallback(callback2, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          hook.memoizedState = [callback2, deps];
          return callback2;
        }
        function mountMemo(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        }
        function updateMemo(nextCreate, deps) {
          var hook = updateWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var prevState = hook.memoizedState;
          if (null !== deps && areHookInputsEqual(deps, prevState[1]))
            return prevState[0];
          prevState = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [prevState, deps];
          return prevState;
        }
        function mountDeferredValue(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        }
        function updateDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function rerenderDeferredValue(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        }
        function mountDeferredValueImpl(hook, value, initialValue) {
          if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
            return hook.memoizedState = value;
          hook.memoizedState = initialValue;
          hook = requestDeferredLane();
          currentlyRenderingFiber$1.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return initialValue;
        }
        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
          if (objectIs(value, prevValue)) return value;
          if (null !== currentTreeHiddenStackCursor.current)
            return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
          if (0 === (renderLanes & 42))
            return didReceiveUpdate = true, hook.memoizedState = value;
          hook = requestDeferredLane();
          currentlyRenderingFiber$1.lanes |= hook;
          workInProgressRootSkippedLanes |= hook;
          return prevValue;
        }
        function startTransition3(fiber, queue, pendingState, finishedState, callback2) {
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          dispatchOptimisticSetState(fiber, false, queue, pendingState);
          currentTransition._updatedFibers = /* @__PURE__ */ new Set();
          try {
            var returnValue = callback2(), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
              var thenableForFinishedState = chainThenableValue(
                returnValue,
                finishedState
              );
              dispatchSetStateInternal(
                fiber,
                queue,
                thenableForFinishedState,
                requestUpdateLane(fiber)
              );
            } else
              dispatchSetStateInternal(
                fiber,
                queue,
                finishedState,
                requestUpdateLane(fiber)
              );
          } catch (error) {
            dispatchSetStateInternal(
              fiber,
              queue,
              { then: function() {
              }, status: "rejected", reason: error },
              requestUpdateLane(fiber)
            );
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
              "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
            ));
          }
        }
        function startHostTransition(formFiber, pendingState, action, formData) {
          if (5 !== formFiber.tag)
            throw Error(
              "Expected the form instance to be a HostComponent. This is a bug in React."
            );
          var queue = ensureFormComponentIsStateful(formFiber).queue;
          startTransition3(
            formFiber,
            queue,
            pendingState,
            NotPendingTransition,
            null === action ? noop$22 : function() {
              requestFormReset$1(formFiber);
              return action(formData);
            }
          );
        }
        function ensureFormComponentIsStateful(formFiber) {
          var existingStateHook = formFiber.memoizedState;
          if (null !== existingStateHook) return existingStateHook;
          existingStateHook = {
            memoizedState: NotPendingTransition,
            baseState: NotPendingTransition,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: NotPendingTransition
            },
            next: null
          };
          var initialResetState = {};
          existingStateHook.next = {
            memoizedState: initialResetState,
            baseState: initialResetState,
            baseQueue: null,
            queue: {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialResetState
            },
            next: null
          };
          formFiber.memoizedState = existingStateHook;
          formFiber = formFiber.alternate;
          null !== formFiber && (formFiber.memoizedState = existingStateHook);
          return existingStateHook;
        }
        function requestFormReset$1(formFiber) {
          null === ReactSharedInternals.T && console.error(
            "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
          );
          var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
          dispatchSetStateInternal(
            formFiber,
            resetStateQueue,
            {},
            requestUpdateLane(formFiber)
          );
        }
        function mountTransition() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition3.bind(
            null,
            currentlyRenderingFiber$1,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        }
        function updateTransition() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function rerenderTransition() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start
          ];
        }
        function useHostTransitionStatus() {
          return readContext(HostTransitionContext);
        }
        function mountId() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var treeId = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
            identifierPrefix = ":" + identifierPrefix + "R" + treeId;
            treeId = localIdCounter++;
            0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
            identifierPrefix += ":";
          } else
            treeId = globalClientIdCounter++, identifierPrefix = ":" + identifierPrefix + "r" + treeId.toString(32) + ":";
          return hook.memoizedState = identifierPrefix;
        }
        function mountRefresh() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber$1
          );
        }
        function refreshCache(fiber, seedKey) {
          for (var provider = fiber.return; null !== provider; ) {
            switch (provider.tag) {
              case 24:
              case 3:
                var lane = requestUpdateLane(provider);
                fiber = createUpdate(lane);
                var root2 = enqueueUpdate(provider, fiber, lane);
                null !== root2 && (scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
                provider = createCache3();
                null !== seedKey && void 0 !== seedKey && null !== root2 && console.error(
                  "The seed argument is not enabled outside experimental channels."
                );
                fiber.payload = { cache: provider };
                return;
            }
            provider = provider.return;
          }
        }
        function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {
          "function" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);
          action = {
            lane: JSCompiler_OptimizeArgumentsArray_p0,
            revertLane: 0,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            JSCompiler_OptimizeArgumentsArray_p0
          ), null !== action && (scheduleUpdateOnFiber(
            action,
            fiber,
            JSCompiler_OptimizeArgumentsArray_p0
          ), entangleTransitionUpdate(
            action,
            queue,
            JSCompiler_OptimizeArgumentsArray_p0
          )));
          markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);
        }
        function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {
          "function" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error(
            "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
          );
          JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);
          dispatchSetStateInternal(
            fiber,
            queue,
            action,
            JSCompiler_OptimizeArgumentsArray_p1
          );
          markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);
        }
        function dispatchSetStateInternal(fiber, queue, action, lane) {
          var update = {
            lane,
            revertLane: 0,
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
          else {
            var alternate = fiber.alternate;
            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
              var prevDispatcher = ReactSharedInternals.H;
              ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
              try {
                var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState))
                  return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
              } catch (error) {
              } finally {
                ReactSharedInternals.H = prevDispatcher;
              }
            }
            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
            if (null !== action)
              return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
          }
          return false;
        }
        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
          null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
            "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
          );
          action = {
            lane: 2,
            revertLane: requestTransitionLane(),
            action,
            hasEagerState: false,
            eagerState: null,
            next: null
          };
          if (isRenderPhaseUpdate(fiber)) {
            if (throwIfDuringRender)
              throw Error("Cannot update optimistic state while rendering.");
            console.error("Cannot call startTransition while rendering.");
          } else
            throwIfDuringRender = enqueueConcurrentHookUpdate(
              fiber,
              queue,
              action,
              2
            ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
          markStateUpdateScheduled(fiber, 2);
        }
        function isRenderPhaseUpdate(fiber) {
          var alternate = fiber.alternate;
          return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;
        }
        function enqueueRenderPhaseUpdate(queue, update) {
          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        function entangleTransitionUpdate(root2, queue, lane) {
          if (0 !== (lane & 4194176)) {
            var queueLanes = queue.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            queue.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function warnOnInvalidCallback(callback2) {
          if (null !== callback2 && "function" !== typeof callback2) {
            var key = String(callback2);
            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
              "Expected the last optional `callback` argument to be a function. Instead received: %s.",
              callback2
            ));
          }
        }
        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
          var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
            "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
            ctor
          )));
          prevState = null === partialState || void 0 === partialState ? prevState : assign3({}, prevState, partialState);
          workInProgress2.memoizedState = prevState;
          0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
        }
        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
          var instance = workInProgress2.stateNode;
          if ("function" === typeof instance.shouldComponentUpdate) {
            oldProps = instance.shouldComponentUpdate(
              newProps,
              newState,
              nextContext
            );
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                oldProps = instance.shouldComponentUpdate(
                  newProps,
                  newState,
                  nextContext
                );
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            void 0 === oldProps && console.error(
              "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
              getComponentNameFromType(ctor) || "Component"
            );
            return oldProps;
          }
          return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual2(oldProps, newProps) || !shallowEqual2(oldState, newState) : true;
        }
        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
          var oldState = instance.state;
          "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
          "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
          instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
            "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
            workInProgress2
          )), classComponentUpdater.enqueueReplaceState(
            instance,
            instance.state,
            null
          ));
        }
        function resolveClassComponentProps(Component4, baseProps) {
          var newProps = baseProps;
          if ("ref" in baseProps) {
            newProps = {};
            for (var propName in baseProps)
              "ref" !== propName && (newProps[propName] = baseProps[propName]);
          }
          if (Component4 = Component4.defaultProps) {
            newProps === baseProps && (newProps = assign3({}, newProps));
            for (var _propName in Component4)
              void 0 === newProps[_propName] && (newProps[_propName] = Component4[_propName]);
          }
          return newProps;
        }
        function defaultOnUncaughtError(error, errorInfo) {
          reportGlobalError(error);
          error = componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.";
          var prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : "";
          ReactSharedInternals.getCurrentStack = function() {
            return componentStack;
          };
          try {
            console.warn(
              "%s\n\n%s\n",
              error,
              "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
            );
          } finally {
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
          }
        }
        function defaultOnCaughtError(error, errorInfo) {
          var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + "."), prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : "";
          ReactSharedInternals.getCurrentStack = function() {
            return componentStack;
          };
          try {
            "object" === typeof error && null !== error && "string" === typeof error.environmentName ? bindToConsole(
              "error",
              [
                "%o\n\n%s\n\n%s\n",
                error,
                componentNameMessage,
                recreateMessage
              ],
              error.environmentName
            )() : console.error(
              "%o\n\n%s\n\n%s\n",
              error,
              componentNameMessage,
              recreateMessage
            );
          } finally {
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
          }
        }
        function defaultOnRecoverableError(error) {
          reportGlobalError(error);
        }
        function logUncaughtError(root2, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = null;
            var error = errorInfo.value;
            if (null !== ReactSharedInternals.actQueue)
              ReactSharedInternals.thrownErrors.push(error);
            else {
              var onUncaughtError = root2.onUncaughtError;
              onUncaughtError(error, { componentStack: errorInfo.stack });
            }
          } catch (e$4) {
            setTimeout(function() {
              throw e$4;
            });
          }
        }
        function logCaughtError(root2, boundary, errorInfo) {
          try {
            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
            errorBoundaryName = getComponentNameFromFiber(boundary);
            var onCaughtError = root2.onCaughtError;
            onCaughtError(errorInfo.value, {
              componentStack: errorInfo.stack,
              errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
            });
          } catch (e$5) {
            setTimeout(function() {
              throw e$5;
            });
          }
        }
        function createRootErrorUpdate(root2, errorInfo, lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          lane.payload = { element: null };
          lane.callback = function() {
            runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
          };
          return lane;
        }
        function createClassErrorUpdate(lane) {
          lane = createUpdate(lane);
          lane.tag = CaptureUpdate;
          return lane;
        }
        function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
          if ("function" === typeof getDerivedStateFromError) {
            var error = errorInfo.value;
            update.payload = function() {
              return getDerivedStateFromError(error);
            };
            update.callback = function() {
              markFailedErrorBoundaryForHotReloading(fiber);
              runWithFiberInDEV(
                errorInfo.source,
                logCaughtError,
                root2,
                fiber,
                errorInfo
              );
            };
          }
          var inst = fiber.stateNode;
          null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
            markFailedErrorBoundaryForHotReloading(fiber);
            runWithFiberInDEV(
              errorInfo.source,
              logCaughtError,
              root2,
              fiber,
              errorInfo
            );
            "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
            callComponentDidCatchInDEV(this, errorInfo);
            "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
              "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
              getComponentNameFromFiber(fiber) || "Unknown"
            );
          });
        }
        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
          sourceFiber.flags |= 32768;
          isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
          if (null !== value && "object" === typeof value && "function" === typeof value.then) {
            returnFiber = sourceFiber.alternate;
            null !== returnFiber && propagateParentContextChanges(
              returnFiber,
              sourceFiber,
              rootRenderLanes,
              true
            );
            isHydrating && (didSuspendOrErrorDEV = true);
            sourceFiber = suspenseHandlerStackCursor.current;
            if (null !== sourceFiber) {
              switch (sourceFiber.tag) {
                case 13:
                  return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
                case 22:
                  return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: /* @__PURE__ */ new Set([value])
                  }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
              }
              throw Error(
                "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
              );
            }
            attachPingListener(root2, value, rootRenderLanes);
            renderDidSuspendDelayIfPossible();
            return false;
          }
          if (isHydrating)
            return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
                  { cause: value }
                ),
                sourceFiber
              )
            )) : (value !== HydrationMismatchException && queueHydrationError(
              createCapturedValueAtFiber(
                Error(
                  "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
                  { cause: value }
                ),
                sourceFiber
              )
            ), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
              root2.stateNode,
              value,
              rootRenderLanes
            ), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
          var error = createCapturedValueAtFiber(
            Error(
              "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
              { cause: value }
            ),
            sourceFiber
          );
          null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
          workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
          if (null === returnFiber) return true;
          value = createCapturedValueAtFiber(value, sourceFiber);
          sourceFiber = returnFiber;
          do {
            switch (sourceFiber.tag) {
              case 3:
                return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(
                  sourceFiber.stateNode,
                  value,
                  root2
                ), enqueueCapturedUpdate(sourceFiber, root2), false;
              case 1:
                if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
                  return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                    rootRenderLanes,
                    root2,
                    sourceFiber,
                    value
                  ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
            }
            sourceFiber = sourceFiber.return;
          } while (null !== sourceFiber);
          return false;
        }
        function reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2) {
          workInProgress2.child = null === current3 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
            workInProgress2,
            current3.child,
            nextChildren,
            renderLanes2
          );
        }
        function updateForwardRef(current3, workInProgress2, Component4, nextProps, renderLanes2) {
          Component4 = Component4.render;
          var ref = workInProgress2.ref;
          if ("ref" in nextProps) {
            var propsWithoutRef = {};
            for (var key in nextProps)
              "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
          } else propsWithoutRef = nextProps;
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          nextProps = renderWithHooks(
            current3,
            workInProgress2,
            Component4,
            propsWithoutRef,
            ref,
            renderLanes2
          );
          key = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current3 && !didReceiveUpdate)
            return bailoutHooks(current3, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          isHydrating && key && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current3, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateMemoComponent(current3, workInProgress2, Component4, nextProps, renderLanes2) {
          if (null === current3) {
            var type = Component4.type;
            if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component4.compare)
              return Component4 = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component4, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
                current3,
                workInProgress2,
                Component4,
                nextProps,
                renderLanes2
              );
            current3 = createFiberFromTypeAndProps(
              Component4.type,
              null,
              nextProps,
              workInProgress2,
              workInProgress2.mode,
              renderLanes2
            );
            current3.ref = workInProgress2.ref;
            current3.return = workInProgress2;
            return workInProgress2.child = current3;
          }
          type = current3.child;
          if (!checkScheduledUpdateOrContext(current3, renderLanes2)) {
            var prevProps = type.memoizedProps;
            Component4 = Component4.compare;
            Component4 = null !== Component4 ? Component4 : shallowEqual2;
            if (Component4(prevProps, nextProps) && current3.ref === workInProgress2.ref)
              return bailoutOnAlreadyFinishedWork(
                current3,
                workInProgress2,
                renderLanes2
              );
          }
          workInProgress2.flags |= 1;
          current3 = createWorkInProgress(type, nextProps);
          current3.ref = workInProgress2.ref;
          current3.return = workInProgress2;
          return workInProgress2.child = current3;
        }
        function updateSimpleMemoComponent(current3, workInProgress2, Component4, nextProps, renderLanes2) {
          if (null !== current3) {
            var prevProps = current3.memoizedProps;
            if (shallowEqual2(prevProps, nextProps) && current3.ref === workInProgress2.ref && workInProgress2.type === current3.type)
              if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current3, renderLanes2))
                0 !== (current3.flags & 131072) && (didReceiveUpdate = true);
              else
                return workInProgress2.lanes = current3.lanes, bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          }
          return updateFunctionComponent(
            current3,
            workInProgress2,
            Component4,
            nextProps,
            renderLanes2
          );
        }
        function updateOffscreenComponent(current3, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress2.stateNode._pendingVisibility & OffscreenDetached), prevState = null !== current3 ? current3.memoizedState : null;
          markRef(current3, workInProgress2);
          if ("hidden" === nextProps.mode || nextIsDetached) {
            if (0 !== (workInProgress2.flags & 128)) {
              nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
              if (null !== current3) {
                nextChildren = workInProgress2.child = current3.child;
                for (nextIsDetached = 0; null !== nextChildren; )
                  nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
                workInProgress2.childLanes = nextIsDetached & ~nextProps;
              } else workInProgress2.childLanes = 0, workInProgress2.child = null;
              return deferHiddenOffscreenComponent(
                current3,
                workInProgress2,
                nextProps,
                renderLanes2
              );
            }
            if (0 !== (renderLanes2 & 536870912))
              workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current3 && pushTransition(
                workInProgress2,
                null !== prevState ? prevState.cachePool : null
              ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
            else
              return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
                current3,
                workInProgress2,
                null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
                renderLanes2
              );
          } else
            null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current3 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function deferHiddenOffscreenComponent(current3, workInProgress2, nextBaseLanes, renderLanes2) {
          var JSCompiler_inline_result = peekCacheFromPool();
          JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
            parent: CacheContext._currentValue,
            pool: JSCompiler_inline_result
          };
          workInProgress2.memoizedState = {
            baseLanes: nextBaseLanes,
            cachePool: JSCompiler_inline_result
          };
          null !== current3 && pushTransition(workInProgress2, null);
          reuseHiddenContextOnStack(workInProgress2);
          pushOffscreenSuspenseHandler(workInProgress2);
          null !== current3 && propagateParentContextChanges(current3, workInProgress2, renderLanes2, true);
          return null;
        }
        function markRef(current3, workInProgress2) {
          var ref = workInProgress2.ref;
          if (null === ref)
            null !== current3 && null !== current3.ref && (workInProgress2.flags |= 2097664);
          else {
            if ("function" !== typeof ref && "object" !== typeof ref)
              throw Error(
                "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
              );
            if (null === current3 || current3.ref !== ref)
              workInProgress2.flags |= 2097664;
          }
        }
        function updateFunctionComponent(current3, workInProgress2, Component4, nextProps, renderLanes2) {
          if (Component4.prototype && "function" === typeof Component4.prototype.render) {
            var componentName2 = getComponentNameFromType(Component4) || "Unknown";
            didWarnAboutBadClass[componentName2] || (console.error(
              "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
              componentName2,
              componentName2
            ), didWarnAboutBadClass[componentName2] = true);
          }
          workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
            workInProgress2,
            null
          );
          null === current3 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component4.contextTypes && (componentName2 = getComponentNameFromType(Component4) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
            "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
            componentName2
          ))));
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          Component4 = renderWithHooks(
            current3,
            workInProgress2,
            Component4,
            nextProps,
            void 0,
            renderLanes2
          );
          nextProps = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current3 && !didReceiveUpdate)
            return bailoutHooks(current3, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current3, workInProgress2, Component4, renderLanes2);
          return workInProgress2.child;
        }
        function replayFunctionComponent(current3, workInProgress2, nextProps, Component4, secondArg, renderLanes2) {
          prepareToReadContext(workInProgress2);
          markComponentRenderStarted(workInProgress2);
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = null !== current3 && current3.type !== workInProgress2.type;
          workInProgress2.updateQueue = null;
          nextProps = renderWithHooksAgain(
            workInProgress2,
            Component4,
            nextProps,
            secondArg
          );
          finishRenderingHooks(current3, workInProgress2);
          Component4 = checkDidRenderIdHook();
          markComponentRenderStopped();
          if (null !== current3 && !didReceiveUpdate)
            return bailoutHooks(current3, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
          isHydrating && Component4 && pushMaterializedTreeId(workInProgress2);
          workInProgress2.flags |= 1;
          reconcileChildren(current3, workInProgress2, nextProps, renderLanes2);
          return workInProgress2.child;
        }
        function updateClassComponent(current$jscomp$0, workInProgress2, Component4, nextProps, renderLanes2) {
          switch (shouldErrorImpl(workInProgress2)) {
            case false:
              var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
                workInProgress2.memoizedProps,
                _instance.context
              ).state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            case true:
              workInProgress2.flags |= 128;
              workInProgress2.flags |= 65536;
              _instance = Error("Simulated error coming from DevTools");
              var lane = renderLanes2 & -renderLanes2;
              workInProgress2.lanes |= lane;
              state = workInProgressRoot;
              if (null === state)
                throw Error(
                  "Expected a work-in-progress root. This is a bug in React. Please file an issue."
                );
              lane = createClassErrorUpdate(lane);
              initializeClassErrorUpdate(
                lane,
                state,
                workInProgress2,
                createCapturedValueAtFiber(_instance, workInProgress2)
              );
              enqueueCapturedUpdate(workInProgress2, lane);
          }
          prepareToReadContext(workInProgress2);
          if (null === workInProgress2.stateNode) {
            state = emptyContextObject;
            _instance = Component4.contextType;
            "contextType" in Component4 && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component4) && (didWarnAboutInvalidateContextType.add(Component4), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
              "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
              getComponentNameFromType(Component4) || "Component",
              lane
            ));
            "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
            _instance = new Component4(nextProps, state);
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                _instance = new Component4(nextProps, state);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
            _instance.updater = classComponentUpdater;
            workInProgress2.stateNode = _instance;
            _instance._reactInternals = workInProgress2;
            _instance._reactInternalInstance = fakeInternalInstance;
            "function" === typeof Component4.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component4) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
              "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
              state,
              null === _instance.state ? "null" : "undefined",
              state
            )));
            if ("function" === typeof Component4.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
              var foundWillUpdateName = lane = state = null;
              "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
              "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
              "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
              if (null !== state || null !== lane || null !== foundWillUpdateName) {
                _instance = getComponentNameFromType(Component4) || "Component";
                var newApiName = "function" === typeof Component4.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
                  "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
                  _instance,
                  newApiName,
                  null !== state ? "\n  " + state : "",
                  null !== lane ? "\n  " + lane : "",
                  null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
                ));
              }
            }
            _instance = workInProgress2.stateNode;
            state = getComponentNameFromType(Component4) || "Component";
            _instance.render || (Component4.prototype && "function" === typeof Component4.prototype.render ? console.error(
              "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
              state
            ) : console.error(
              "No `render` method found on the %s instance: you may have forgotten to define `render`.",
              state
            ));
            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
              "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
              state
            );
            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
              "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
              state
            );
            _instance.contextType && console.error(
              "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
              state
            );
            Component4.childContextTypes && !didWarnAboutChildContextTypes.has(Component4) && (didWarnAboutChildContextTypes.add(Component4), console.error(
              "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
              state
            ));
            Component4.contextTypes && !didWarnAboutContextTypes$1.has(Component4) && (didWarnAboutContextTypes$1.add(Component4), console.error(
              "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
              state
            ));
            "function" === typeof _instance.componentShouldUpdate && console.error(
              "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
              state
            );
            Component4.prototype && Component4.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
              "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
              getComponentNameFromType(Component4) || "A pure component"
            );
            "function" === typeof _instance.componentDidUnmount && console.error(
              "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
              state
            );
            "function" === typeof _instance.componentDidReceiveProps && console.error(
              "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
              state
            );
            "function" === typeof _instance.componentWillRecieveProps && console.error(
              "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
              state
            );
            "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
              "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
              state
            );
            lane = _instance.props !== nextProps;
            void 0 !== _instance.props && lane && console.error(
              "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
              state
            );
            _instance.defaultProps && console.error(
              "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
              state,
              state
            );
            "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component4) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component4), console.error(
              "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
              getComponentNameFromType(Component4)
            ));
            "function" === typeof _instance.getDerivedStateFromProps && console.error(
              "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof _instance.getDerivedStateFromError && console.error(
              "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
              state
            );
            "function" === typeof Component4.getSnapshotBeforeUpdate && console.error(
              "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
              state
            );
            (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
            "function" === typeof _instance.getChildContext && "object" !== typeof Component4.childContextTypes && console.error(
              "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
              state
            );
            _instance = workInProgress2.stateNode;
            _instance.props = nextProps;
            _instance.state = workInProgress2.memoizedState;
            _instance.refs = {};
            initializeUpdateQueue(workInProgress2);
            state = Component4.contextType;
            _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
            _instance.state === nextProps && (state = getComponentNameFromType(Component4) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
              "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
              state
            )));
            workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
              workInProgress2,
              _instance
            );
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
              workInProgress2,
              _instance
            );
            _instance.state = workInProgress2.memoizedState;
            state = Component4.getDerivedStateFromProps;
            "function" === typeof state && (applyDerivedStateFromProps(
              workInProgress2,
              Component4,
              state,
              nextProps
            ), _instance.state = workInProgress2.memoizedState);
            "function" === typeof Component4.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
              "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
              getComponentNameFromFiber(workInProgress2) || "Component"
            ), classComponentUpdater.enqueueReplaceState(
              _instance,
              _instance.state,
              null
            )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
            "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
            (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 67108864);
            _instance = true;
          } else if (null === current$jscomp$0) {
            _instance = workInProgress2.stateNode;
            var unresolvedOldProps = workInProgress2.memoizedProps;
            lane = resolveClassComponentProps(Component4, unresolvedOldProps);
            _instance.props = lane;
            var oldContext = _instance.context;
            foundWillUpdateName = Component4.contextType;
            state = emptyContextObject;
            "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
            newApiName = Component4.getDerivedStateFromProps;
            foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
            unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
            foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              state
            );
            hasForceUpdate = false;
            var oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            oldContext = workInProgress2.memoizedState;
            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
              workInProgress2,
              Component4,
              newApiName,
              nextProps
            ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component4,
              lane,
              nextProps,
              oldState,
              oldContext,
              state
            )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 67108864)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 67108864), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 67108864), _instance = false);
          } else {
            _instance = workInProgress2.stateNode;
            cloneUpdateQueue(current$jscomp$0, workInProgress2);
            state = workInProgress2.memoizedProps;
            foundWillUpdateName = resolveClassComponentProps(Component4, state);
            _instance.props = foundWillUpdateName;
            newApiName = workInProgress2.pendingProps;
            oldState = _instance.context;
            oldContext = Component4.contextType;
            lane = emptyContextObject;
            "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
            unresolvedOldProps = Component4.getDerivedStateFromProps;
            (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
              workInProgress2,
              _instance,
              nextProps,
              lane
            );
            hasForceUpdate = false;
            oldState = workInProgress2.memoizedState;
            _instance.state = oldState;
            processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
            suspendIfUpdateReadFromEntangledAsyncAction();
            var newState = workInProgress2.memoizedState;
            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
              workInProgress2,
              Component4,
              unresolvedOldProps,
              nextProps
            ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
              workInProgress2,
              Component4,
              foundWillUpdateName,
              nextProps,
              oldState,
              newState,
              lane
            ) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
              nextProps,
              newState,
              lane
            )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
          }
          lane = _instance;
          markRef(current$jscomp$0, workInProgress2);
          state = 0 !== (workInProgress2.flags & 128);
          if (lane || state) {
            lane = workInProgress2.stateNode;
            ReactSharedInternals.getCurrentStack = null === workInProgress2 ? null : getCurrentFiberStackInDev;
            isRendering = false;
            current2 = workInProgress2;
            if (state && "function" !== typeof Component4.getDerivedStateFromError)
              Component4 = null, profilerStartTime = -1;
            else {
              markComponentRenderStarted(workInProgress2);
              Component4 = callRenderInDEV(lane);
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  callRenderInDEV(lane);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              markComponentRenderStopped();
            }
            workInProgress2.flags |= 1;
            null !== current$jscomp$0 && state ? (workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              current$jscomp$0.child,
              null,
              renderLanes2
            ), workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              Component4,
              renderLanes2
            )) : reconcileChildren(
              current$jscomp$0,
              workInProgress2,
              Component4,
              renderLanes2
            );
            workInProgress2.memoizedState = lane.state;
            current$jscomp$0 = workInProgress2.child;
          } else
            current$jscomp$0 = bailoutOnAlreadyFinishedWork(
              current$jscomp$0,
              workInProgress2,
              renderLanes2
            );
          renderLanes2 = workInProgress2.stateNode;
          _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
            "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
            getComponentNameFromFiber(workInProgress2) || "a component"
          ), didWarnAboutReassigningProps = true);
          return current$jscomp$0;
        }
        function mountHostRootWithoutHydrating(current3, workInProgress2, nextChildren, renderLanes2) {
          resetHydrationState();
          workInProgress2.flags |= 256;
          reconcileChildren(current3, workInProgress2, nextChildren, renderLanes2);
          return workInProgress2.child;
        }
        function validateFunctionComponentInDev(workInProgress2, Component4) {
          Component4 && Component4.childContextTypes && console.error(
            "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
            Component4.displayName || Component4.name || "Component"
          );
          "function" === typeof Component4.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component4) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
            "%s: Function components do not support getDerivedStateFromProps.",
            workInProgress2
          ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
          "object" === typeof Component4.contextType && null !== Component4.contextType && (Component4 = getComponentNameFromType(Component4) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component4] || (console.error(
            "%s: Function components do not support contextType.",
            Component4
          ), didWarnAboutContextTypeOnFunctionComponent[Component4] = true));
        }
        function mountSuspenseOffscreenState(renderLanes2) {
          return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
        }
        function getRemainingWorkInPrimaryTree(current3, primaryTreeDidDefer, renderLanes2) {
          current3 = null !== current3 ? current3.childLanes & ~renderLanes2 : 0;
          primaryTreeDidDefer && (current3 |= workInProgressDeferredLane);
          return current3;
        }
        function updateSuspenseComponent(current3, workInProgress2, renderLanes2) {
          var JSCompiler_object_inline_digest_2317;
          var JSCompiler_object_inline_stack_2318 = workInProgress2.pendingProps;
          shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
          var JSCompiler_object_inline_componentStack_2319 = false;
          var didSuspend = 0 !== (workInProgress2.flags & 128);
          (JSCompiler_object_inline_digest_2317 = didSuspend) || (JSCompiler_object_inline_digest_2317 = null !== current3 && null === current3.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
          JSCompiler_object_inline_digest_2317 && (JSCompiler_object_inline_componentStack_2319 = true, workInProgress2.flags &= -129);
          JSCompiler_object_inline_digest_2317 = 0 !== (workInProgress2.flags & 32);
          workInProgress2.flags &= -33;
          if (null === current3) {
            if (isHydrating) {
              JSCompiler_object_inline_componentStack_2319 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
              if (isHydrating) {
                var JSCompiler_object_inline_message_2316 = nextHydratableInstance;
                var JSCompiler_temp;
                if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2316)) {
                  c: {
                    var instance = JSCompiler_object_inline_message_2316;
                    for (JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType; ) {
                      if (!JSCompiler_temp) {
                        JSCompiler_temp = null;
                        break c;
                      }
                      instance = getNextHydratable(instance.nextSibling);
                      if (null === instance) {
                        JSCompiler_temp = null;
                        break c;
                      }
                    }
                    JSCompiler_temp = instance;
                  }
                  null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress2.memoizedState = {
                    dehydrated: JSCompiler_temp,
                    treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                    retryLane: 536870912
                  }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress2, workInProgress2.child = instance, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp = true) : JSCompiler_temp = false;
                  JSCompiler_temp = !JSCompiler_temp;
                }
                JSCompiler_temp && (warnNonHydratedInstance(
                  workInProgress2,
                  JSCompiler_object_inline_message_2316
                ), throwOnHydrationMismatch(workInProgress2));
              }
              JSCompiler_object_inline_message_2316 = workInProgress2.memoizedState;
              if (null !== JSCompiler_object_inline_message_2316 && (JSCompiler_object_inline_message_2316 = JSCompiler_object_inline_message_2316.dehydrated, null !== JSCompiler_object_inline_message_2316))
                return JSCompiler_object_inline_message_2316.data === SUSPENSE_FALLBACK_START_DATA ? workInProgress2.lanes = 16 : workInProgress2.lanes = 536870912, null;
              popSuspenseHandler(workInProgress2);
            }
            JSCompiler_object_inline_message_2316 = JSCompiler_object_inline_stack_2318.children;
            JSCompiler_object_inline_stack_2318 = JSCompiler_object_inline_stack_2318.fallback;
            if (JSCompiler_object_inline_componentStack_2319)
              return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2319 = workInProgress2.mode, JSCompiler_object_inline_message_2316 = mountWorkInProgressOffscreenFiber(
                {
                  mode: "hidden",
                  children: JSCompiler_object_inline_message_2316
                },
                JSCompiler_object_inline_componentStack_2319
              ), JSCompiler_object_inline_stack_2318 = createFiberFromFragment(
                JSCompiler_object_inline_stack_2318,
                JSCompiler_object_inline_componentStack_2319,
                renderLanes2,
                null
              ), JSCompiler_object_inline_message_2316.return = workInProgress2, JSCompiler_object_inline_stack_2318.return = workInProgress2, JSCompiler_object_inline_message_2316.sibling = JSCompiler_object_inline_stack_2318, workInProgress2.child = JSCompiler_object_inline_message_2316, JSCompiler_object_inline_componentStack_2319 = workInProgress2.child, JSCompiler_object_inline_componentStack_2319.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_componentStack_2319.childLanes = getRemainingWorkInPrimaryTree(
                current3,
                JSCompiler_object_inline_digest_2317,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2318;
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            return mountSuspensePrimaryChildren(
              workInProgress2,
              JSCompiler_object_inline_message_2316
            );
          }
          var prevState = current3.memoizedState;
          if (null !== prevState && (JSCompiler_object_inline_message_2316 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2316)) {
            if (didSuspend)
              workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current3,
                workInProgress2,
                renderLanes2
              )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current3.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_stack_2318.fallback, JSCompiler_object_inline_message_2316 = workInProgress2.mode, JSCompiler_object_inline_stack_2318 = mountWorkInProgressOffscreenFiber(
                {
                  mode: "visible",
                  children: JSCompiler_object_inline_stack_2318.children
                },
                JSCompiler_object_inline_message_2316
              ), JSCompiler_object_inline_componentStack_2319 = createFiberFromFragment(
                JSCompiler_object_inline_componentStack_2319,
                JSCompiler_object_inline_message_2316,
                renderLanes2,
                null
              ), JSCompiler_object_inline_componentStack_2319.flags |= 2, JSCompiler_object_inline_stack_2318.return = workInProgress2, JSCompiler_object_inline_componentStack_2319.return = workInProgress2, JSCompiler_object_inline_stack_2318.sibling = JSCompiler_object_inline_componentStack_2319, workInProgress2.child = JSCompiler_object_inline_stack_2318, reconcileChildFibers(
                workInProgress2,
                current3.child,
                null,
                renderLanes2
              ), JSCompiler_object_inline_stack_2318 = workInProgress2.child, JSCompiler_object_inline_stack_2318.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2318.childLanes = getRemainingWorkInPrimaryTree(
                current3,
                JSCompiler_object_inline_digest_2317,
                renderLanes2
              ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = JSCompiler_object_inline_componentStack_2319);
            else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isHydrating && console.error(
              "We should not be hydrating here. This is a bug in React. Please file a bug."
            ), JSCompiler_object_inline_message_2316.data === SUSPENSE_FALLBACK_START_DATA) {
              JSCompiler_object_inline_digest_2317 = JSCompiler_object_inline_message_2316.nextSibling && JSCompiler_object_inline_message_2316.nextSibling.dataset;
              if (JSCompiler_object_inline_digest_2317) {
                JSCompiler_temp = JSCompiler_object_inline_digest_2317.dgst;
                var message = JSCompiler_object_inline_digest_2317.msg;
                instance = JSCompiler_object_inline_digest_2317.stck;
                var componentStack = JSCompiler_object_inline_digest_2317.cstck;
              }
              JSCompiler_object_inline_message_2316 = message;
              JSCompiler_object_inline_digest_2317 = JSCompiler_temp;
              JSCompiler_object_inline_stack_2318 = instance;
              JSCompiler_temp = JSCompiler_object_inline_componentStack_2319 = componentStack;
              JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_message_2316 ? Error(JSCompiler_object_inline_message_2316) : Error(
                "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
              );
              JSCompiler_object_inline_componentStack_2319.stack = JSCompiler_object_inline_stack_2318 || "";
              JSCompiler_object_inline_componentStack_2319.digest = JSCompiler_object_inline_digest_2317;
              JSCompiler_object_inline_digest_2317 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
              JSCompiler_object_inline_stack_2318 = {
                value: JSCompiler_object_inline_componentStack_2319,
                source: null,
                stack: JSCompiler_object_inline_digest_2317
              };
              "string" === typeof JSCompiler_object_inline_digest_2317 && CapturedStacks.set(
                JSCompiler_object_inline_componentStack_2319,
                JSCompiler_object_inline_stack_2318
              );
              queueHydrationError(JSCompiler_object_inline_stack_2318);
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current3,
                workInProgress2,
                renderLanes2
              );
            } else if (didReceiveUpdate || propagateParentContextChanges(
              current3,
              workInProgress2,
              renderLanes2,
              false
            ), JSCompiler_object_inline_digest_2317 = 0 !== (renderLanes2 & current3.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2317) {
              JSCompiler_object_inline_digest_2317 = workInProgressRoot;
              if (null !== JSCompiler_object_inline_digest_2317) {
                JSCompiler_object_inline_stack_2318 = renderLanes2 & -renderLanes2;
                if (0 !== (JSCompiler_object_inline_stack_2318 & 42))
                  JSCompiler_object_inline_stack_2318 = 1;
                else
                  switch (JSCompiler_object_inline_stack_2318) {
                    case 2:
                      JSCompiler_object_inline_stack_2318 = 1;
                      break;
                    case 8:
                      JSCompiler_object_inline_stack_2318 = 4;
                      break;
                    case 32:
                      JSCompiler_object_inline_stack_2318 = 16;
                      break;
                    case 128:
                    case 256:
                    case 512:
                    case 1024:
                    case 2048:
                    case 4096:
                    case 8192:
                    case 16384:
                    case 32768:
                    case 65536:
                    case 131072:
                    case 262144:
                    case 524288:
                    case 1048576:
                    case 2097152:
                    case 4194304:
                    case 8388608:
                    case 16777216:
                    case 33554432:
                      JSCompiler_object_inline_stack_2318 = 64;
                      break;
                    case 268435456:
                      JSCompiler_object_inline_stack_2318 = 134217728;
                      break;
                    default:
                      JSCompiler_object_inline_stack_2318 = 0;
                  }
                JSCompiler_object_inline_stack_2318 = 0 !== (JSCompiler_object_inline_stack_2318 & (JSCompiler_object_inline_digest_2317.suspendedLanes | renderLanes2)) ? 0 : JSCompiler_object_inline_stack_2318;
                if (0 !== JSCompiler_object_inline_stack_2318 && JSCompiler_object_inline_stack_2318 !== prevState.retryLane)
                  throw prevState.retryLane = JSCompiler_object_inline_stack_2318, enqueueConcurrentRenderForLane(
                    current3,
                    JSCompiler_object_inline_stack_2318
                  ), scheduleUpdateOnFiber(
                    JSCompiler_object_inline_digest_2317,
                    current3,
                    JSCompiler_object_inline_stack_2318
                  ), SelectiveHydrationException;
              }
              JSCompiler_object_inline_message_2316.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
              workInProgress2 = retrySuspenseComponentWithoutHydrating(
                current3,
                workInProgress2,
                renderLanes2
              );
            } else
              JSCompiler_object_inline_message_2316.data === SUSPENSE_PENDING_START_DATA ? (workInProgress2.flags |= 128, workInProgress2.child = current3.child, workInProgress2 = retryDehydratedSuspenseBoundary.bind(
                null,
                current3
              ), JSCompiler_object_inline_message_2316._reactRetry = workInProgress2, workInProgress2 = null) : (current3 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
                JSCompiler_object_inline_message_2316.nextSibling
              ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current3 && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current3.id, treeContextOverflow = current3.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
                workInProgress2,
                JSCompiler_object_inline_stack_2318.children
              ), workInProgress2.flags |= 4096);
            return workInProgress2;
          }
          if (JSCompiler_object_inline_componentStack_2319)
            return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_stack_2318.fallback, JSCompiler_object_inline_message_2316 = workInProgress2.mode, JSCompiler_temp = current3.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2318 = createWorkInProgress(
              JSCompiler_temp,
              {
                mode: "hidden",
                children: JSCompiler_object_inline_stack_2318.children
              }
            ), JSCompiler_object_inline_stack_2318.subtreeFlags = JSCompiler_temp.subtreeFlags & 31457280, null !== instance ? JSCompiler_object_inline_componentStack_2319 = createWorkInProgress(
              instance,
              JSCompiler_object_inline_componentStack_2319
            ) : (JSCompiler_object_inline_componentStack_2319 = createFiberFromFragment(
              JSCompiler_object_inline_componentStack_2319,
              JSCompiler_object_inline_message_2316,
              renderLanes2,
              null
            ), JSCompiler_object_inline_componentStack_2319.flags |= 2), JSCompiler_object_inline_componentStack_2319.return = workInProgress2, JSCompiler_object_inline_stack_2318.return = workInProgress2, JSCompiler_object_inline_stack_2318.sibling = JSCompiler_object_inline_componentStack_2319, workInProgress2.child = JSCompiler_object_inline_stack_2318, JSCompiler_object_inline_stack_2318 = JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_componentStack_2319 = workInProgress2.child, JSCompiler_object_inline_message_2316 = current3.child.memoizedState, null === JSCompiler_object_inline_message_2316 ? JSCompiler_object_inline_message_2316 = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp = JSCompiler_object_inline_message_2316.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? { parent: instance, pool: instance } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2316 = {
              baseLanes: JSCompiler_object_inline_message_2316.baseLanes | renderLanes2,
              cachePool: JSCompiler_temp
            }), JSCompiler_object_inline_componentStack_2319.memoizedState = JSCompiler_object_inline_message_2316, JSCompiler_object_inline_componentStack_2319.childLanes = getRemainingWorkInPrimaryTree(
              current3,
              JSCompiler_object_inline_digest_2317,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2318;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          renderLanes2 = current3.child;
          current3 = renderLanes2.sibling;
          renderLanes2 = createWorkInProgress(renderLanes2, {
            mode: "visible",
            children: JSCompiler_object_inline_stack_2318.children
          });
          renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
          null !== current3 && (JSCompiler_object_inline_digest_2317 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2317 ? (workInProgress2.deletions = [current3], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2317.push(current3));
          workInProgress2.child = renderLanes2;
          workInProgress2.memoizedState = null;
          return renderLanes2;
        }
        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
          primaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: primaryChildren },
            workInProgress2.mode
          );
          primaryChildren.return = workInProgress2;
          return workInProgress2.child = primaryChildren;
        }
        function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
          return createFiberFromOffscreen(offscreenProps, mode, 0, null);
        }
        function retrySuspenseComponentWithoutHydrating(current3, workInProgress2, renderLanes2) {
          reconcileChildFibers(workInProgress2, current3.child, null, renderLanes2);
          current3 = mountSuspensePrimaryChildren(
            workInProgress2,
            workInProgress2.pendingProps.children
          );
          current3.flags |= 2;
          workInProgress2.memoizedState = null;
          return current3;
        }
        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
          fiber.lanes |= renderLanes2;
          var alternate = fiber.alternate;
          null !== alternate && (alternate.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(
            fiber.return,
            renderLanes2,
            propagationRoot
          );
        }
        function validateSuspenseListNestedChild(childSlot, index) {
          var isAnArray = isArrayImpl(childSlot);
          childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
          return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
            "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
            isAnArray,
            index,
            isAnArray
          ), false) : true;
        }
        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
          var renderState = workInProgress2.memoizedState;
          null === renderState ? workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode
          } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
        }
        function updateSuspenseListComponent(current3, workInProgress2, renderLanes2) {
          var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
          nextProps = nextProps.children;
          if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder])
            if (didWarnAboutRevealOrder[revealOrder] = true, "string" === typeof revealOrder)
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                case "forward":
                case "backward":
                  console.error(
                    '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
                    revealOrder,
                    revealOrder.toLowerCase()
                  );
                  break;
                default:
                  console.error(
                    '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                    revealOrder
                  );
              }
            else
              console.error(
                '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
                revealOrder
              );
          void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = true, console.error(
            '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
            tailMode
          )) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = true, console.error(
            '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
            tailMode
          )));
          a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && false !== nextProps)
            if (isArrayImpl(nextProps))
              for (var i = 0; i < nextProps.length; i++) {
                if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
              }
            else if (i = getIteratorFn(nextProps), "function" === typeof i) {
              if (i = i.call(nextProps))
                for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
                  if (!validateSuspenseListNestedChild(step.value, _i)) break a;
                  _i++;
                }
            } else
              console.error(
                'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
                revealOrder
              );
          reconcileChildren(current3, workInProgress2, nextProps, renderLanes2);
          nextProps = suspenseStackCursor.current;
          if (0 !== (nextProps & ForceSuspenseFallback))
            nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128;
          else {
            if (null !== current3 && 0 !== (current3.flags & 128))
              a: for (current3 = workInProgress2.child; null !== current3; ) {
                if (13 === current3.tag)
                  null !== current3.memoizedState && scheduleSuspenseWorkOnFiber(
                    current3,
                    renderLanes2,
                    workInProgress2
                  );
                else if (19 === current3.tag)
                  scheduleSuspenseWorkOnFiber(current3, renderLanes2, workInProgress2);
                else if (null !== current3.child) {
                  current3.child.return = current3;
                  current3 = current3.child;
                  continue;
                }
                if (current3 === workInProgress2) break a;
                for (; null === current3.sibling; ) {
                  if (null === current3.return || current3.return === workInProgress2)
                    break a;
                  current3 = current3.return;
                }
                current3.sibling.return = current3.return;
                current3 = current3.sibling;
              }
            nextProps &= SubtreeSuspenseContextMask;
          }
          push(suspenseStackCursor, nextProps, workInProgress2);
          switch (revealOrder) {
            case "forwards":
              renderLanes2 = workInProgress2.child;
              for (revealOrder = null; null !== renderLanes2; )
                current3 = renderLanes2.alternate, null !== current3 && null === findFirstSuspended(current3) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
              renderLanes2 = revealOrder;
              null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
              initSuspenseListRenderState(
                workInProgress2,
                false,
                revealOrder,
                renderLanes2,
                tailMode
              );
              break;
            case "backwards":
              renderLanes2 = null;
              revealOrder = workInProgress2.child;
              for (workInProgress2.child = null; null !== revealOrder; ) {
                current3 = revealOrder.alternate;
                if (null !== current3 && null === findFirstSuspended(current3)) {
                  workInProgress2.child = revealOrder;
                  break;
                }
                current3 = revealOrder.sibling;
                revealOrder.sibling = renderLanes2;
                renderLanes2 = revealOrder;
                revealOrder = current3;
              }
              initSuspenseListRenderState(
                workInProgress2,
                true,
                renderLanes2,
                null,
                tailMode
              );
              break;
            case "together":
              initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
              break;
            default:
              workInProgress2.memoizedState = null;
          }
          return workInProgress2.child;
        }
        function bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2) {
          null !== current3 && (workInProgress2.dependencies = current3.dependencies);
          profilerStartTime = -1;
          workInProgressRootSkippedLanes |= workInProgress2.lanes;
          if (0 === (renderLanes2 & workInProgress2.childLanes))
            if (null !== current3) {
              if (propagateParentContextChanges(
                current3,
                workInProgress2,
                renderLanes2,
                false
              ), 0 === (renderLanes2 & workInProgress2.childLanes))
                return null;
            } else return null;
          if (null !== current3 && workInProgress2.child !== current3.child)
            throw Error("Resuming work not yet implemented.");
          if (null !== workInProgress2.child) {
            current3 = workInProgress2.child;
            renderLanes2 = createWorkInProgress(current3, current3.pendingProps);
            workInProgress2.child = renderLanes2;
            for (renderLanes2.return = workInProgress2; null !== current3.sibling; )
              current3 = current3.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current3, current3.pendingProps), renderLanes2.return = workInProgress2;
            renderLanes2.sibling = null;
          }
          return workInProgress2.child;
        }
        function checkScheduledUpdateOrContext(current3, renderLanes2) {
          if (0 !== (current3.lanes & renderLanes2)) return true;
          current3 = current3.dependencies;
          return null !== current3 && checkIfContextChanged(current3) ? true : false;
        }
        function attemptEarlyBailoutIfNoScheduledUpdate(current3, workInProgress2, renderLanes2) {
          switch (workInProgress2.tag) {
            case 3:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              pushProvider(
                workInProgress2,
                CacheContext,
                current3.memoizedState.cache
              );
              resetHydrationState();
              break;
            case 27:
            case 5:
              pushHostContext(workInProgress2);
              break;
            case 4:
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(
                workInProgress2,
                workInProgress2.type,
                workInProgress2.memoizedProps.value
              );
              break;
            case 12:
              0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
              workInProgress2.flags |= 2048;
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = -0;
              stateNode.passiveEffectDuration = -0;
              break;
            case 13:
              stateNode = workInProgress2.memoizedState;
              if (null !== stateNode) {
                if (null !== stateNode.dehydrated)
                  return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
                if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                  return updateSuspenseComponent(
                    current3,
                    workInProgress2,
                    renderLanes2
                  );
                pushPrimaryTreeSuspenseHandler(workInProgress2);
                current3 = bailoutOnAlreadyFinishedWork(
                  current3,
                  workInProgress2,
                  renderLanes2
                );
                return null !== current3 ? current3.sibling : null;
              }
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              break;
            case 19:
              var didSuspendBefore = 0 !== (current3.flags & 128);
              stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
              stateNode || (propagateParentContextChanges(
                current3,
                workInProgress2,
                renderLanes2,
                false
              ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
              if (didSuspendBefore) {
                if (stateNode)
                  return updateSuspenseListComponent(
                    current3,
                    workInProgress2,
                    renderLanes2
                  );
                workInProgress2.flags |= 128;
              }
              didSuspendBefore = workInProgress2.memoizedState;
              null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress2
              );
              if (stateNode) break;
              else return null;
            case 22:
            case 23:
              return workInProgress2.lanes = 0, updateOffscreenComponent(current3, workInProgress2, renderLanes2);
            case 24:
              pushProvider(
                workInProgress2,
                CacheContext,
                current3.memoizedState.cache
              );
          }
          return bailoutOnAlreadyFinishedWork(current3, workInProgress2, renderLanes2);
        }
        function beginWork(current3, workInProgress2, renderLanes2) {
          if (workInProgress2._debugNeedsRemount && null !== current3) {
            renderLanes2 = createFiberFromTypeAndProps(
              workInProgress2.type,
              workInProgress2.key,
              workInProgress2.pendingProps,
              workInProgress2._debugOwner || null,
              workInProgress2.mode,
              workInProgress2.lanes
            );
            var returnFiber = workInProgress2.return;
            if (null === returnFiber) throw Error("Cannot swap the root fiber.");
            current3.alternate = null;
            workInProgress2.alternate = null;
            renderLanes2.index = workInProgress2.index;
            renderLanes2.sibling = workInProgress2.sibling;
            renderLanes2.return = workInProgress2.return;
            renderLanes2.ref = workInProgress2.ref;
            renderLanes2._debugInfo = workInProgress2._debugInfo;
            if (workInProgress2 === returnFiber.child)
              returnFiber.child = renderLanes2;
            else {
              var prevSibling = returnFiber.child;
              if (null === prevSibling)
                throw Error("Expected parent to have a child.");
              for (; prevSibling.sibling !== workInProgress2; )
                if (prevSibling = prevSibling.sibling, null === prevSibling)
                  throw Error("Expected to find the previous sibling.");
              prevSibling.sibling = renderLanes2;
            }
            workInProgress2 = returnFiber.deletions;
            null === workInProgress2 ? (returnFiber.deletions = [current3], returnFiber.flags |= 16) : workInProgress2.push(current3);
            renderLanes2.flags |= 2;
            return renderLanes2;
          }
          if (null !== current3)
            if (current3.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current3.type)
              didReceiveUpdate = true;
            else {
              if (!checkScheduledUpdateOrContext(current3, renderLanes2) && 0 === (workInProgress2.flags & 128))
                return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                  current3,
                  workInProgress2,
                  renderLanes2
                );
              didReceiveUpdate = 0 !== (current3.flags & 131072) ? true : false;
            }
          else {
            didReceiveUpdate = false;
            if (returnFiber = isHydrating)
              warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
            returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
          }
          workInProgress2.lanes = 0;
          switch (workInProgress2.tag) {
            case 16:
              a: if (returnFiber = workInProgress2.pendingProps, current3 = callLazyInitInDEV(workInProgress2.elementType), workInProgress2.type = current3, "function" === typeof current3)
                shouldConstruct(current3) ? (returnFiber = resolveClassComponentProps(
                  current3,
                  returnFiber
                ), workInProgress2.tag = 1, workInProgress2.type = current3 = resolveFunctionForHotReloading(current3), workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  current3,
                  returnFiber,
                  renderLanes2
                )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current3), workInProgress2.type = current3 = resolveFunctionForHotReloading(current3), workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  current3,
                  returnFiber,
                  renderLanes2
                ));
              else {
                if (void 0 !== current3 && null !== current3) {
                  if (prevSibling = current3.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE2) {
                    workInProgress2.tag = 11;
                    workInProgress2.type = current3 = resolveForwardRefForHotReloading(current3);
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      current3,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  } else if (prevSibling === REACT_MEMO_TYPE2) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      current3,
                      returnFiber,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = "";
                null !== current3 && "object" === typeof current3 && current3.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
                current3 = getComponentNameFromType(current3) || current3;
                throw Error(
                  "Element type is invalid. Received a promise that resolves to: " + current3 + ". Lazy element type must resolve to a class or function." + workInProgress2
                );
              }
              return workInProgress2;
            case 0:
              return updateFunctionComponent(
                current3,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 1:
              return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
                returnFiber,
                workInProgress2.pendingProps
              ), updateClassComponent(
                current3,
                workInProgress2,
                returnFiber,
                prevSibling,
                renderLanes2
              );
            case 3:
              a: {
                pushHostContainer(
                  workInProgress2,
                  workInProgress2.stateNode.containerInfo
                );
                if (null === current3)
                  throw Error(
                    "Should have a current fiber. This is a bug in React."
                  );
                var nextProps = workInProgress2.pendingProps;
                prevSibling = workInProgress2.memoizedState;
                returnFiber = prevSibling.element;
                cloneUpdateQueue(current3, workInProgress2);
                processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
                var nextState = workInProgress2.memoizedState;
                nextProps = nextState.cache;
                pushProvider(workInProgress2, CacheContext, nextProps);
                nextProps !== prevSibling.cache && propagateContextChanges(
                  workInProgress2,
                  [CacheContext],
                  renderLanes2,
                  true
                );
                suspendIfUpdateReadFromEntangledAsyncAction();
                nextProps = nextState.element;
                if (prevSibling.isDehydrated)
                  if (prevSibling = {
                    element: nextProps,
                    isDehydrated: false,
                    cache: nextState.cache
                  }, workInProgress2.updateQueue.baseState = prevSibling, workInProgress2.memoizedState = prevSibling, workInProgress2.flags & 256) {
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current3,
                      workInProgress2,
                      nextProps,
                      renderLanes2
                    );
                    break a;
                  } else if (nextProps !== returnFiber) {
                    returnFiber = createCapturedValueAtFiber(
                      Error(
                        "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
                      ),
                      workInProgress2
                    );
                    queueHydrationError(returnFiber);
                    workInProgress2 = mountHostRootWithoutHydrating(
                      current3,
                      workInProgress2,
                      nextProps,
                      renderLanes2
                    );
                    break a;
                  } else
                    for (nextHydratableInstance = getNextHydratable(
                      workInProgress2.stateNode.containerInfo.firstChild
                    ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = true, current3 = mountChildFibers(
                      workInProgress2,
                      null,
                      nextProps,
                      renderLanes2
                    ), workInProgress2.child = current3; current3; )
                      current3.flags = current3.flags & -3 | 4096, current3 = current3.sibling;
                else {
                  resetHydrationState();
                  if (nextProps === returnFiber) {
                    workInProgress2 = bailoutOnAlreadyFinishedWork(
                      current3,
                      workInProgress2,
                      renderLanes2
                    );
                    break a;
                  }
                  reconcileChildren(
                    current3,
                    workInProgress2,
                    nextProps,
                    renderLanes2
                  );
                }
                workInProgress2 = workInProgress2.child;
              }
              return workInProgress2;
            case 26:
              return markRef(current3, workInProgress2), null === current3 ? (current3 = getResource(
                workInProgress2.type,
                null,
                workInProgress2.pendingProps,
                null
              )) ? workInProgress2.memoizedState = current3 : isHydrating || (current3 = workInProgress2.type, renderLanes2 = workInProgress2.pendingProps, returnFiber = requiredContext(
                rootInstanceStackCursor.current
              ), returnFiber = getOwnerDocumentFromRootContainer(
                returnFiber
              ).createElement(current3), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = renderLanes2, setInitialProperties(returnFiber, current3, renderLanes2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
                workInProgress2.type,
                current3.memoizedProps,
                workInProgress2.pendingProps,
                current3.memoizedState
              ), null;
            case 27:
              return pushHostContext(workInProgress2), null === current3 && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress2.stateNode = resolveSingletonInstance(
                workInProgress2.type,
                workInProgress2.pendingProps,
                prevSibling,
                returnFiber,
                false
              ), didSuspendOrErrorDEV || (returnFiber = diffHydratedProperties(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                returnFiber
              ), null !== returnFiber && (buildHydrationDiffNode(workInProgress2, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, nextHydratableInstance = getNextHydratable(
                prevSibling.firstChild
              )), returnFiber = workInProgress2.pendingProps.children, null !== current3 || isHydrating ? reconcileChildren(
                current3,
                workInProgress2,
                returnFiber,
                renderLanes2
              ) : workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ), markRef(current3, workInProgress2), workInProgress2.child;
            case 5:
              return null === current3 && isHydrating && (nextProps = getHostContext(), returnFiber = validateDOMNesting(
                workInProgress2.type,
                nextProps.ancestorInfo
              ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
                prevSibling,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedProperties(
                nextState,
                workInProgress2.type,
                workInProgress2.pendingProps,
                nextProps
              ), null !== nextProps && (buildHydrationDiffNode(workInProgress2, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                nextState.firstChild
              ), rootOrSingletonContext = false, nextProps = true) : nextProps = false, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, nextProps = workInProgress2.pendingProps, nextState = null !== current3 ? current3.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
                current3,
                workInProgress2,
                TransitionAwareHostComponent,
                null,
                null,
                renderLanes2
              ), HostTransitionContext._currentValue = prevSibling), markRef(current3, workInProgress2), reconcileChildren(
                current3,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 6:
              return null === current3 && isHydrating && (current3 = workInProgress2.pendingProps, renderLanes2 = getHostContext().ancestorInfo.current, current3 = null != renderLanes2 ? validateTextNesting(current3, renderLanes2.tag) : true, renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (current3 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
            case 13:
              return updateSuspenseComponent(current3, workInProgress2, renderLanes2);
            case 4:
              return pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              ), returnFiber = workInProgress2.pendingProps, null === current3 ? workInProgress2.child = reconcileChildFibers(
                workInProgress2,
                null,
                returnFiber,
                renderLanes2
              ) : reconcileChildren(
                current3,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 11:
              return updateForwardRef(
                current3,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 7:
              return reconcileChildren(
                current3,
                workInProgress2,
                workInProgress2.pendingProps,
                renderLanes2
              ), workInProgress2.child;
            case 8:
              return reconcileChildren(
                current3,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 12:
              return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
                current3,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 10:
              return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, nextProps = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
                "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
              )), pushProvider(workInProgress2, returnFiber, nextProps), reconcileChildren(
                current3,
                workInProgress2,
                prevSibling.children,
                renderLanes2
              ), workInProgress2.child;
            case 9:
              return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
                "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
              ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress2), returnFiber = callComponentInDEV(
                returnFiber,
                prevSibling,
                void 0
              ), markComponentRenderStopped(), workInProgress2.flags |= 1, reconcileChildren(
                current3,
                workInProgress2,
                returnFiber,
                renderLanes2
              ), workInProgress2.child;
            case 14:
              return updateMemoComponent(
                current3,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 15:
              return updateSimpleMemoComponent(
                current3,
                workInProgress2,
                workInProgress2.type,
                workInProgress2.pendingProps,
                renderLanes2
              );
            case 19:
              return updateSuspenseListComponent(
                current3,
                workInProgress2,
                renderLanes2
              );
            case 22:
              return updateOffscreenComponent(current3, workInProgress2, renderLanes2);
            case 24:
              return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current3 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache3(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = nextProps), workInProgress2.memoizedState = {
                parent: returnFiber,
                cache: prevSibling
              }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current3.lanes & renderLanes2) && (cloneUpdateQueue(current3, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current3.memoizedState, nextProps = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
                parent: returnFiber,
                cache: returnFiber
              }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              ))), reconcileChildren(
                current3,
                workInProgress2,
                workInProgress2.pendingProps.children,
                renderLanes2
              ), workInProgress2.child;
            case 29:
              throw workInProgress2.pendingProps;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function resetContextDependencies() {
          lastContextDependency = currentlyRenderingFiber = null;
          isDisallowedContextReadInDEV = false;
        }
        function pushProvider(providerFiber, context, nextValue) {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          push(rendererCursorDEV, context._currentRenderer, providerFiber);
          void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
            "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
          );
          context._currentRenderer = rendererSigil;
        }
        function popProvider(context, providerFiber) {
          context._currentValue = valueCursor.current;
          var currentRenderer = rendererCursorDEV.current;
          pop(rendererCursorDEV, providerFiber);
          context._currentRenderer = currentRenderer;
          pop(valueCursor, providerFiber);
        }
        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
          for (; null !== parent; ) {
            var alternate = parent.alternate;
            (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
            if (parent === propagationRoot) break;
            parent = parent.return;
          }
          parent !== propagationRoot && console.error(
            "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
          var fiber = workInProgress2.child;
          null !== fiber && (fiber.return = workInProgress2);
          for (; null !== fiber; ) {
            var list = fiber.dependencies;
            if (null !== list) {
              var nextFiber = fiber.child;
              list = list.firstContext;
              a: for (; null !== list; ) {
                var dependency = list;
                list = fiber;
                for (var i = 0; i < contexts.length; i++)
                  if (dependency.context === contexts[i]) {
                    list.lanes |= renderLanes2;
                    dependency = list.alternate;
                    null !== dependency && (dependency.lanes |= renderLanes2);
                    scheduleContextWorkOnParentPath(
                      list.return,
                      renderLanes2,
                      workInProgress2
                    );
                    forcePropagateEntireTree || (nextFiber = null);
                    break a;
                  }
                list = dependency.next;
              }
            } else if (18 === fiber.tag) {
              nextFiber = fiber.return;
              if (null === nextFiber)
                throw Error(
                  "We just came from a parent so we must have had a parent. This is a bug in React."
                );
              nextFiber.lanes |= renderLanes2;
              list = nextFiber.alternate;
              null !== list && (list.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                nextFiber,
                renderLanes2,
                workInProgress2
              );
              nextFiber = null;
            } else nextFiber = fiber.child;
            if (null !== nextFiber) nextFiber.return = fiber;
            else
              for (nextFiber = fiber; null !== nextFiber; ) {
                if (nextFiber === workInProgress2) {
                  nextFiber = null;
                  break;
                }
                fiber = nextFiber.sibling;
                if (null !== fiber) {
                  fiber.return = nextFiber.return;
                  nextFiber = fiber;
                  break;
                }
                nextFiber = nextFiber.return;
              }
            fiber = nextFiber;
          }
        }
        function propagateParentContextChanges(current3, workInProgress2, renderLanes2, forcePropagateEntireTree) {
          current3 = null;
          for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
            if (!isInsidePropagationBailout) {
              if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
              else if (0 !== (parent.flags & 262144)) break;
            }
            if (10 === parent.tag) {
              var currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent = currentParent.memoizedProps;
              if (null !== currentParent) {
                var context = parent.type;
                objectIs(parent.pendingProps.value, currentParent.value) || (null !== current3 ? current3.push(context) : current3 = [context]);
              }
            } else if (parent === hostTransitionProviderCursor.current) {
              currentParent = parent.alternate;
              if (null === currentParent)
                throw Error("Should have a current fiber. This is a bug in React.");
              currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current3 ? current3.push(HostTransitionContext) : current3 = [HostTransitionContext]);
            }
            parent = parent.return;
          }
          null !== current3 && propagateContextChanges(
            workInProgress2,
            current3,
            renderLanes2,
            forcePropagateEntireTree
          );
          workInProgress2.flags |= 262144;
        }
        function checkIfContextChanged(currentDependencies) {
          for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
            if (!objectIs(
              currentDependencies.context._currentValue,
              currentDependencies.memoizedValue
            ))
              return true;
            currentDependencies = currentDependencies.next;
          }
          return false;
        }
        function prepareToReadContext(workInProgress2) {
          currentlyRenderingFiber = workInProgress2;
          lastContextDependency = null;
          workInProgress2 = workInProgress2.dependencies;
          null !== workInProgress2 && (workInProgress2.firstContext = null);
        }
        function readContext(context) {
          isDisallowedContextReadInDEV && console.error(
            "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
          );
          return readContextForConsumer(currentlyRenderingFiber, context);
        }
        function readContextDuringReconciliation(consumer, context) {
          null === currentlyRenderingFiber && prepareToReadContext(consumer);
          return readContextForConsumer(consumer, context);
        }
        function readContextForConsumer(consumer, context) {
          var value = context._currentValue;
          context = { context, memoizedValue: value, next: null };
          if (null === lastContextDependency) {
            if (null === consumer)
              throw Error(
                "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
              );
            lastContextDependency = context;
            consumer.dependencies = {
              lanes: 0,
              firstContext: context,
              _debugThenableState: null
            };
            consumer.flags |= 524288;
          } else lastContextDependency = lastContextDependency.next = context;
          return value;
        }
        function initializeUpdateQueue(fiber) {
          fiber.updateQueue = {
            baseState: fiber.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: { pending: null, lanes: 0, hiddenCallbacks: null },
            callbacks: null
          };
        }
        function cloneUpdateQueue(current3, workInProgress2) {
          current3 = current3.updateQueue;
          workInProgress2.updateQueue === current3 && (workInProgress2.updateQueue = {
            baseState: current3.baseState,
            firstBaseUpdate: current3.firstBaseUpdate,
            lastBaseUpdate: current3.lastBaseUpdate,
            shared: current3.shared,
            callbacks: null
          });
        }
        function createUpdate(lane) {
          return {
            lane,
            tag: UpdateState,
            payload: null,
            callback: null,
            next: null
          };
        }
        function enqueueUpdate(fiber, update, lane) {
          var updateQueue = fiber.updateQueue;
          if (null === updateQueue) return null;
          updateQueue = updateQueue.shared;
          if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
            var componentName2 = getComponentNameFromFiber(fiber);
            console.error(
              "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
              componentName2
            );
            didWarnUpdateInsideUpdate = true;
          }
          if ((executionContext & RenderContext) !== NoContext)
            return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
          enqueueUpdate$1(fiber, updateQueue, update, lane);
          return getRootForUpdatedFiber(fiber);
        }
        function entangleTransitions(root2, fiber, lane) {
          fiber = fiber.updateQueue;
          if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {
            var queueLanes = fiber.lanes;
            queueLanes &= root2.pendingLanes;
            lane |= queueLanes;
            fiber.lanes = lane;
            markRootEntangled(root2, lane);
          }
        }
        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
          var queue = workInProgress2.updateQueue, current3 = workInProgress2.alternate;
          if (null !== current3 && (current3 = current3.updateQueue, queue === current3)) {
            var newFirst = null, newLast = null;
            queue = queue.firstBaseUpdate;
            if (null !== queue) {
              do {
                var clone3 = {
                  lane: queue.lane,
                  tag: queue.tag,
                  payload: queue.payload,
                  callback: null,
                  next: null
                };
                null === newLast ? newFirst = newLast = clone3 : newLast = newLast.next = clone3;
                queue = queue.next;
              } while (null !== queue);
              null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
            } else newFirst = newLast = capturedUpdate;
            queue = {
              baseState: current3.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: current3.shared,
              callbacks: current3.callbacks
            };
            workInProgress2.updateQueue = queue;
            return;
          }
          workInProgress2 = queue.lastBaseUpdate;
          null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
          queue.lastBaseUpdate = capturedUpdate;
        }
        function suspendIfUpdateReadFromEntangledAsyncAction() {
          if (didReadFromEntangledAsyncAction) {
            var entangledActionThenable = currentEntangledActionThenable;
            if (null !== entangledActionThenable) throw entangledActionThenable;
          }
        }
        function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
          didReadFromEntangledAsyncAction = false;
          var queue = workInProgress2.updateQueue;
          hasForceUpdate = false;
          currentlyProcessingQueue = queue.shared;
          var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
          if (null !== pendingQueue) {
            queue.shared.pending = null;
            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
            lastPendingUpdate.next = null;
            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
            lastBaseUpdate = lastPendingUpdate;
            var current3 = workInProgress2.alternate;
            null !== current3 && (current3 = current3.updateQueue, pendingQueue = current3.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current3.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current3.lastBaseUpdate = lastPendingUpdate));
          }
          if (null !== firstBaseUpdate) {
            var newState = queue.baseState;
            lastBaseUpdate = 0;
            current3 = firstPendingUpdate = lastPendingUpdate = null;
            pendingQueue = firstBaseUpdate;
            do {
              var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
              if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
                0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
                null !== current3 && (current3 = current3.next = {
                  lane: 0,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: null,
                  next: null
                });
                a: {
                  updateLane = workInProgress2;
                  var partialState = pendingQueue;
                  var nextProps = props, instance = instance$jscomp$0;
                  switch (partialState.tag) {
                    case ReplaceState:
                      partialState = partialState.payload;
                      if ("function" === typeof partialState) {
                        isDisallowedContextReadInDEV = true;
                        var nextState = partialState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            partialState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                        newState = nextState;
                        break a;
                      }
                      newState = partialState;
                      break a;
                    case CaptureUpdate:
                      updateLane.flags = updateLane.flags & -65537 | 128;
                    case UpdateState:
                      nextState = partialState.payload;
                      if ("function" === typeof nextState) {
                        isDisallowedContextReadInDEV = true;
                        partialState = nextState.call(
                          instance,
                          newState,
                          nextProps
                        );
                        if (updateLane.mode & StrictLegacyMode) {
                          setIsStrictModeForDevtools(true);
                          try {
                            nextState.call(instance, newState, nextProps);
                          } finally {
                            setIsStrictModeForDevtools(false);
                          }
                        }
                        isDisallowedContextReadInDEV = false;
                      } else partialState = nextState;
                      if (null === partialState || void 0 === partialState) break a;
                      newState = assign3({}, newState, partialState);
                      break a;
                    case ForceUpdate:
                      hasForceUpdate = true;
                  }
                }
                updateLane = pendingQueue.callback;
                null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
              } else
                isHiddenUpdate = {
                  lane: updateLane,
                  tag: pendingQueue.tag,
                  payload: pendingQueue.payload,
                  callback: pendingQueue.callback,
                  next: null
                }, null === current3 ? (firstPendingUpdate = current3 = isHiddenUpdate, lastPendingUpdate = newState) : current3 = current3.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
              pendingQueue = pendingQueue.next;
              if (null === pendingQueue)
                if (pendingQueue = queue.shared.pending, null === pendingQueue)
                  break;
                else
                  isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
            } while (1);
            null === current3 && (lastPendingUpdate = newState);
            queue.baseState = lastPendingUpdate;
            queue.firstBaseUpdate = firstPendingUpdate;
            queue.lastBaseUpdate = current3;
            null === firstBaseUpdate && (queue.shared.lanes = 0);
            workInProgressRootSkippedLanes |= lastBaseUpdate;
            workInProgress2.lanes = lastBaseUpdate;
            workInProgress2.memoizedState = newState;
          }
          currentlyProcessingQueue = null;
        }
        function callCallback(callback2, context) {
          if ("function" !== typeof callback2)
            throw Error(
              "Invalid argument passed as callback. Expected a function. Instead received: " + callback2
            );
          callback2.call(context);
        }
        function commitHiddenCallbacks(updateQueue, context) {
          var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
          if (null !== hiddenCallbacks)
            for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
              callCallback(hiddenCallbacks[updateQueue], context);
        }
        function commitCallbacks(updateQueue, context) {
          var callbacks = updateQueue.callbacks;
          if (null !== callbacks)
            for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
              callCallback(callbacks[updateQueue], context);
        }
        function shouldProfile(current3) {
          return (current3.mode & ProfileMode) !== NoMode;
        }
        function commitHookLayoutEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitHookEffectListMount(flags, finishedWork) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(
                  finishedWork
                ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(
                  finishedWork
                ), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
                  finishedWork,
                  callCreateInDEV,
                  updateQueue
                ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
                  var hookName = void 0;
                  hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
                  var addendum = void 0;
                  addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
                  runWithFiberInDEV(
                    finishedWork,
                    function(n, a) {
                      console.error(
                        "%s must not return anything besides a function, which is used for clean-up.%s",
                        n,
                        a
                      );
                    },
                    hookName,
                    addendum
                  );
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
          try {
            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
            if (null !== lastEffect) {
              var firstEffect = lastEffect.next;
              updateQueue = firstEffect;
              do {
                if ((updateQueue.tag & flags) === flags) {
                  var inst = updateQueue.inst, destroy = inst.destroy;
                  void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
                    finishedWork
                  ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
                    finishedWork
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), runWithFiberInDEV(
                    finishedWork,
                    callDestroyInDEV,
                    finishedWork,
                    nearestMountedAncestor,
                    destroy
                  ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
                }
                updateQueue = updateQueue.next;
              } while (updateQueue !== firstEffect);
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHookPassiveMountEffects(finishedWork, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
        }
        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
          shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          ), recordEffectDuration()) : commitHookEffectListUnmount(
            hookFlags,
            finishedWork,
            nearestMountedAncestor
          );
        }
        function commitClassCallbacks(finishedWork) {
          var updateQueue = finishedWork.updateQueue;
          if (null !== updateQueue) {
            var instance = finishedWork.stateNode;
            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
              "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ), instance.state !== finishedWork.memoizedState && console.error(
              "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
              getComponentNameFromFiber(finishedWork) || "instance"
            ));
            try {
              runWithFiberInDEV(
                finishedWork,
                commitCallbacks,
                updateQueue,
                instance
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }
        function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
          return instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
        function commitClassSnapshot(finishedWork, current3) {
          var prevProps = current3.memoizedProps, prevState = current3.memoizedState;
          current3 = finishedWork.stateNode;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current3.props !== finishedWork.memoizedProps && console.error(
            "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ), current3.state !== finishedWork.memoizedState && console.error(
            "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
            getComponentNameFromFiber(finishedWork) || "instance"
          ));
          try {
            var resolvedPrevProps = resolveClassComponentProps(
              finishedWork.type,
              prevProps,
              finishedWork.elementType === finishedWork.type
            );
            var snapshot = runWithFiberInDEV(
              finishedWork,
              callGetSnapshotBeforeUpdates,
              current3,
              resolvedPrevProps,
              prevState
            );
            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
              console.error(
                "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
                getComponentNameFromFiber(finishedWork)
              );
            }));
            current3.__reactInternalSnapshotBeforeUpdate = snapshot;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function safelyCallComponentWillUnmount(current3, nearestMountedAncestor, instance) {
          instance.props = resolveClassComponentProps(
            current3.type,
            current3.memoizedProps
          );
          instance.state = current3.memoizedState;
          shouldProfile(current3) ? (startEffectTimer(), runWithFiberInDEV(
            current3,
            callComponentWillUnmountInDEV,
            current3,
            nearestMountedAncestor,
            instance
          ), recordEffectDuration()) : runWithFiberInDEV(
            current3,
            callComponentWillUnmountInDEV,
            current3,
            nearestMountedAncestor,
            instance
          );
        }
        function commitAttachRef(finishedWork) {
          var ref = finishedWork.ref;
          if (null !== ref) {
            var instance = finishedWork.stateNode;
            if ("function" === typeof ref)
              if (shouldProfile(finishedWork))
                try {
                  startEffectTimer(), finishedWork.refCleanup = ref(instance);
                } finally {
                  recordEffectDuration();
                }
              else finishedWork.refCleanup = ref(instance);
            else
              "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
                "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
                getComponentNameFromFiber(finishedWork)
              ), ref.current = instance;
          }
        }
        function safelyAttachRef(current3, nearestMountedAncestor) {
          try {
            runWithFiberInDEV(current3, commitAttachRef, current3);
          } catch (error) {
            captureCommitPhaseError(current3, nearestMountedAncestor, error);
          }
        }
        function safelyDetachRef(current3, nearestMountedAncestor) {
          var ref = current3.ref, refCleanup = current3.refCleanup;
          if (null !== ref)
            if ("function" === typeof refCleanup)
              try {
                if (shouldProfile(current3))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current3, refCleanup);
                  } finally {
                    recordEffectDuration(current3);
                  }
                else runWithFiberInDEV(current3, refCleanup);
              } catch (error) {
                captureCommitPhaseError(current3, nearestMountedAncestor, error);
              } finally {
                current3.refCleanup = null, current3 = current3.alternate, null != current3 && (current3.refCleanup = null);
              }
            else if ("function" === typeof ref)
              try {
                if (shouldProfile(current3))
                  try {
                    startEffectTimer(), runWithFiberInDEV(current3, ref, null);
                  } finally {
                    recordEffectDuration(current3);
                  }
                else runWithFiberInDEV(current3, ref, null);
              } catch (error$6) {
                captureCommitPhaseError(current3, nearestMountedAncestor, error$6);
              }
            else ref.current = null;
        }
        function commitProfiler(finishedWork, current3, commitStartTime2, effectDuration) {
          var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
          _finishedWork$memoize = _finishedWork$memoize.onRender;
          current3 = null === current3 ? "mount" : "update";
          currentUpdateIsNested && (current3 = "nested-update");
          "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
            id,
            current3,
            finishedWork.actualDuration,
            finishedWork.treeBaseDuration,
            finishedWork.actualStartTime,
            commitStartTime2
          );
          "function" === typeof onCommit && onCommit(
            finishedWork.memoizedProps.id,
            current3,
            effectDuration,
            commitStartTime2
          );
        }
        function commitProfilerPostCommitImpl(finishedWork, current3, commitStartTime2, passiveEffectDuration) {
          var _finishedWork$memoize2 = finishedWork.memoizedProps;
          finishedWork = _finishedWork$memoize2.id;
          _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
          current3 = null === current3 ? "mount" : "update";
          currentUpdateIsNested && (current3 = "nested-update");
          "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
            finishedWork,
            current3,
            passiveEffectDuration,
            commitStartTime2
          );
        }
        function commitHostMount(finishedWork) {
          var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
          try {
            runWithFiberInDEV(
              finishedWork,
              commitMount,
              instance,
              type,
              props,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function commitHostUpdate(finishedWork, newProps, oldProps) {
          try {
            runWithFiberInDEV(
              finishedWork,
              commitUpdate,
              finishedWork.stateNode,
              finishedWork.type,
              oldProps,
              newProps,
              finishedWork
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        function isHostParent(fiber) {
          return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag || 4 === fiber.tag;
        }
        function getHostSibling(fiber) {
          a: for (; ; ) {
            for (; null === fiber.sibling; ) {
              if (null === fiber.return || isHostParent(fiber.return)) return null;
              fiber = fiber.return;
            }
            fiber.sibling.return = fiber.return;
            for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 27 !== fiber.tag && 18 !== fiber.tag; ) {
              if (fiber.flags & 2) continue a;
              if (null === fiber.child || 4 === fiber.tag) continue a;
              else fiber.child.return = fiber, fiber = fiber.child;
            }
            if (!(fiber.flags & 2)) return fiber.stateNode;
          }
        }
        function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
          var tag = node2.tag;
          if (5 === tag || 6 === tag)
            node2 = node2.stateNode, before ? 8 === parent.nodeType ? parent.parentNode.insertBefore(node2, before) : parent.insertBefore(node2, before) : (8 === parent.nodeType ? (before = parent.parentNode, before.insertBefore(node2, parent)) : (before = parent, before.appendChild(node2)), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$12));
          else if (4 !== tag && 27 !== tag && (node2 = node2.child, null !== node2))
            for (insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling; null !== node2; )
              insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling;
        }
        function insertOrAppendPlacementNode(node2, before, parent) {
          var tag = node2.tag;
          if (5 === tag || 6 === tag)
            node2 = node2.stateNode, before ? parent.insertBefore(node2, before) : parent.appendChild(node2);
          else if (4 !== tag && 27 !== tag && (node2 = node2.child, null !== node2))
            for (insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling; null !== node2; )
              insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling;
        }
        function commitPlacement(finishedWork) {
          if (27 !== finishedWork.tag) {
            a: {
              for (var parent = finishedWork.return; null !== parent; ) {
                if (isHostParent(parent)) {
                  var parentFiber = parent;
                  break a;
                }
                parent = parent.return;
              }
              throw Error(
                "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
              );
            }
            switch (parentFiber.tag) {
              case 27:
                parent = parentFiber.stateNode;
                parentFiber = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
                break;
              case 5:
                parent = parentFiber.stateNode;
                parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);
                parentFiber = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
                break;
              case 3:
              case 4:
                parent = parentFiber.stateNode.containerInfo;
                parentFiber = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  parentFiber,
                  parent
                );
                break;
              default:
                throw Error(
                  "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
                );
            }
          }
        }
        function commitBeforeMutationEffects(root2, firstChild) {
          root2 = root2.containerInfo;
          eventsEnabled = _enabled;
          root2 = getActiveElementDeep(root2);
          if (hasSelectionCapabilities(root2)) {
            if ("selectionStart" in root2)
              var JSCompiler_temp = {
                start: root2.selectionStart,
                end: root2.selectionEnd
              };
            else
              a: {
                JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
                var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
                if (selection && 0 !== selection.rangeCount) {
                  JSCompiler_temp = selection.anchorNode;
                  var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                  selection = selection.focusOffset;
                  try {
                    JSCompiler_temp.nodeType, focusNode.nodeType;
                  } catch (e$2) {
                    JSCompiler_temp = null;
                    break a;
                  }
                  var length2 = 0, start = -1, end2 = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node2 = root2, parentNode = null;
                  b: for (; ; ) {
                    for (var next2; ; ) {
                      node2 !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node2.nodeType || (start = length2 + anchorOffset);
                      node2 !== focusNode || 0 !== selection && 3 !== node2.nodeType || (end2 = length2 + selection);
                      3 === node2.nodeType && (length2 += node2.nodeValue.length);
                      if (null === (next2 = node2.firstChild)) break;
                      parentNode = node2;
                      node2 = next2;
                    }
                    for (; ; ) {
                      if (node2 === root2) break b;
                      parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length2);
                      parentNode === focusNode && ++indexWithinFocus === selection && (end2 = length2);
                      if (null !== (next2 = node2.nextSibling)) break;
                      node2 = parentNode;
                      parentNode = node2.parentNode;
                    }
                    node2 = next2;
                  }
                  JSCompiler_temp = -1 === start || -1 === end2 ? null : { start, end: end2 };
                } else JSCompiler_temp = null;
              }
            JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
          } else JSCompiler_temp = null;
          selectionInformation = {
            focusedElem: root2,
            selectionRange: JSCompiler_temp
          };
          _enabled = false;
          for (nextEffect = firstChild; null !== nextEffect; )
            if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
              root2.return = firstChild, nextEffect = root2;
            else
              for (; null !== nextEffect; ) {
                root2 = firstChild = nextEffect;
                JSCompiler_temp = root2.alternate;
                anchorOffset = root2.flags;
                switch (root2.tag) {
                  case 0:
                    break;
                  case 11:
                  case 15:
                    break;
                  case 1:
                    0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root2, JSCompiler_temp);
                    break;
                  case 3:
                    if (0 !== (anchorOffset & 1024)) {
                      if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                        clearContainerSparingly(root2);
                      else if (1 === JSCompiler_temp)
                        switch (root2.nodeName) {
                          case "HEAD":
                          case "HTML":
                          case "BODY":
                            clearContainerSparingly(root2);
                            break;
                          default:
                            root2.textContent = "";
                        }
                    }
                    break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    if (0 !== (anchorOffset & 1024))
                      throw Error(
                        "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                      );
                }
                root2 = firstChild.sibling;
                if (null !== root2) {
                  root2.return = firstChild.return;
                  nextEffect = root2;
                  break;
                }
                nextEffect = firstChild.return;
              }
          firstChild = shouldFireAfterActiveInstanceBlur;
          shouldFireAfterActiveInstanceBlur = false;
          return firstChild;
        }
        function commitLayoutEffectOnFiber(finishedRoot, current3, finishedWork) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
              break;
            case 1:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 4)
                if (finishedRoot = finishedWork.stateNode, null === current3)
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidMountInDEV,
                    finishedWork,
                    finishedRoot
                  );
                else {
                  var prevProps = resolveClassComponentProps(
                    finishedWork.type,
                    current3.memoizedProps
                  );
                  current3 = current3.memoizedState;
                  finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
                    "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ), finishedRoot.state !== finishedWork.memoizedState && console.error(
                    "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
                    getComponentNameFromFiber(finishedWork) || "instance"
                  ));
                  shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current3,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  ), recordEffectDuration()) : runWithFiberInDEV(
                    finishedWork,
                    callComponentDidUpdateInDEV,
                    finishedWork,
                    finishedRoot,
                    prevProps,
                    current3,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                }
              flags & 64 && commitClassCallbacks(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 3:
              current3 = pushNestedEffectDurations();
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
                prevProps = null;
                if (null !== finishedWork.child)
                  switch (finishedWork.child.tag) {
                    case 27:
                    case 5:
                      prevProps = finishedWork.child.stateNode;
                      break;
                    case 1:
                      prevProps = finishedWork.child.stateNode;
                  }
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitCallbacks,
                    flags,
                    prevProps
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              finishedRoot.effectDuration += popNestedEffectDurations(current3);
              break;
            case 26:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
            case 5:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              null === current3 && flags & 4 && commitHostMount(finishedWork);
              flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                finishedRoot = finishedWork.stateNode;
                finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current3,
                    commitStartTime,
                    finishedRoot.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              break;
            case 13:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
              if (!prevProps) {
                current3 = null !== current3 && null !== current3.memoizedState || offscreenSubtreeWasHidden;
                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                offscreenSubtreeIsHidden = prevProps;
                (offscreenSubtreeWasHidden = current3) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  0 !== (finishedWork.subtreeFlags & 8772)
                ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              }
              flags & 512 && ("manual" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));
              break;
            default:
              recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          }
        }
        function detachFiberAfterEffects(fiber) {
          var alternate = fiber.alternate;
          null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
          fiber.stateNode = null;
          fiber._debugOwner = null;
          fiber.return = null;
          fiber.dependencies = null;
          fiber.memoizedProps = null;
          fiber.memoizedState = null;
          fiber.pendingProps = null;
          fiber.stateNode = null;
          fiber.updateQueue = null;
        }
        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
          for (parent = parent.child; null !== parent; )
            commitDeletionEffectsOnFiber(
              finishedRoot,
              nearestMountedAncestor,
              parent
            ), parent = parent.sibling;
        }
        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
            try {
              injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          switch (deletedFiber.tag) {
            case 26:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
              break;
            case 27:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              deletedFiber = deletedFiber.stateNode;
              for (finishedRoot = deletedFiber.attributes; finishedRoot.length; )
                deletedFiber.removeAttributeNode(finishedRoot[0]);
              detachDeletedInstance(deletedFiber);
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 5:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            case 6:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (null !== hostParent)
                if (hostParentIsContainer)
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChildFromContainer,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
                else
                  try {
                    runWithFiberInDEV(
                      deletedFiber,
                      removeChild,
                      hostParent,
                      deletedFiber.stateNode
                    );
                  } catch (error) {
                    captureCommitPhaseError(
                      deletedFiber,
                      nearestMountedAncestor,
                      error
                    );
                  }
              break;
            case 18:
              null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, deletedFiber = deletedFiber.stateNode, 8 === finishedRoot.nodeType ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber) : 1 === finishedRoot.nodeType && clearSuspenseBoundary(finishedRoot, deletedFiber), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
              break;
            case 4:
              prevHostParent = hostParent;
              prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              break;
            case 0:
            case 11:
            case 14:
            case 15:
              offscreenSubtreeWasHidden || commitHookEffectListUnmount(
                Insertion,
                deletedFiber,
                nearestMountedAncestor
              );
              offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
                deletedFiber,
                nearestMountedAncestor,
                Layout
              );
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 1:
              offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
                deletedFiber,
                nearestMountedAncestor,
                prevHostParent
              ));
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 21:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              break;
            case 22:
              offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
              offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
              offscreenSubtreeWasHidden = prevHostParent;
              break;
            default:
              recursivelyTraverseDeletionEffects(
                finishedRoot,
                nearestMountedAncestor,
                deletedFiber
              );
          }
        }
        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
          if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
            try {
              runWithFiberInDEV(
                finishedWork,
                commitHydratedSuspenseInstance,
                finishedRoot
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
        }
        function getRetryCache(finishedWork) {
          switch (finishedWork.tag) {
            case 13:
            case 19:
              var retryCache = finishedWork.stateNode;
              null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
              return retryCache;
            case 22:
              return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
            default:
              throw Error(
                "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
              );
          }
        }
        function attachSuspenseRetryListeners(finishedWork, wakeables) {
          var retryCache = getRetryCache(finishedWork);
          wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              if (isDevToolsPresent)
                if (null !== inProgressLanes && null !== inProgressRoot)
                  restorePendingUpdaters(inProgressRoot, inProgressLanes);
                else
                  throw Error(
                    "Expected finished root and lanes to be set. This is a bug in React."
                  );
              wakeable.then(retry, retry);
            }
          });
        }
        function commitMutationEffects(root2, finishedWork, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          commitMutationEffectsOnFiber(finishedWork, root2);
          inProgressRoot = inProgressLanes = null;
        }
        function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
          var deletions = parentFiber.deletions;
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], parent = returnFiber;
              a: for (; null !== parent; ) {
                switch (parent.tag) {
                  case 27:
                  case 5:
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  case 3:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                  case 4:
                    hostParent = parent.stateNode.containerInfo;
                    hostParentIsContainer = true;
                    break a;
                }
                parent = parent.return;
              }
              if (null === hostParent)
                throw Error(
                  "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
                );
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
              root2 = deletedFiber;
              returnFiber = root2.alternate;
              null !== returnFiber && (returnFiber.return = null);
              root2.return = null;
            }
          if (parentFiber.subtreeFlags & 13878)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
        }
        function commitMutationEffectsOnFiber(finishedWork, root2) {
          var current3 = finishedWork.alternate, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (commitHookEffectListUnmount(
                Insertion | HasEffect,
                finishedWork,
                finishedWork.return
              ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout | HasEffect
              ));
              break;
            case 1:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current3 || safelyDetachRef(current3, current3.return));
              flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current3 = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current3 ? flags : current3.concat(flags))));
              break;
            case 26:
              var hoistableRoot = currentHoistableRoot;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current3 || safelyDetachRef(current3, current3.return));
              if (flags & 4)
                if (root2 = null !== current3 ? current3.memoizedState : null, flags = finishedWork.memoizedState, null === current3)
                  if (null === flags)
                    if (null === finishedWork.stateNode) {
                      a: {
                        flags = finishedWork.type;
                        current3 = finishedWork.memoizedProps;
                        root2 = hoistableRoot.ownerDocument || hoistableRoot;
                        b: switch (flags) {
                          case "title":
                            hoistableRoot = root2.getElementsByTagName("title")[0];
                            if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop"))
                              hoistableRoot = root2.createElement(flags), root2.head.insertBefore(
                                hoistableRoot,
                                root2.querySelector("head > title")
                              );
                            setInitialProperties(hoistableRoot, flags, current3);
                            hoistableRoot[internalInstanceKey] = finishedWork;
                            markNodeAsHoistable(hoistableRoot);
                            flags = hoistableRoot;
                            break a;
                          case "link":
                            var maybeNodes = getHydratableHoistableCache(
                              "link",
                              "href",
                              root2
                            ).get(flags + (current3.href || ""));
                            if (maybeNodes) {
                              for (var i = 0; i < maybeNodes.length; i++)
                                if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (null == current3.href ? null : current3.href) && hoistableRoot.getAttribute("rel") === (null == current3.rel ? null : current3.rel) && hoistableRoot.getAttribute("title") === (null == current3.title ? null : current3.title) && hoistableRoot.getAttribute("crossorigin") === (null == current3.crossOrigin ? null : current3.crossOrigin)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            hoistableRoot = root2.createElement(flags);
                            setInitialProperties(hoistableRoot, flags, current3);
                            root2.head.appendChild(hoistableRoot);
                            break;
                          case "meta":
                            if (maybeNodes = getHydratableHoistableCache(
                              "meta",
                              "content",
                              root2
                            ).get(flags + (current3.content || ""))) {
                              for (i = 0; i < maybeNodes.length; i++)
                                if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(
                                  current3.content,
                                  "content"
                                ), hoistableRoot.getAttribute("content") === (null == current3.content ? null : "" + current3.content) && hoistableRoot.getAttribute("name") === (null == current3.name ? null : current3.name) && hoistableRoot.getAttribute("property") === (null == current3.property ? null : current3.property) && hoistableRoot.getAttribute("http-equiv") === (null == current3.httpEquiv ? null : current3.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current3.charSet ? null : current3.charSet)) {
                                  maybeNodes.splice(i, 1);
                                  break b;
                                }
                            }
                            hoistableRoot = root2.createElement(flags);
                            setInitialProperties(hoistableRoot, flags, current3);
                            root2.head.appendChild(hoistableRoot);
                            break;
                          default:
                            throw Error(
                              'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
                            );
                        }
                        hoistableRoot[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(hoistableRoot);
                        flags = hoistableRoot;
                      }
                      finishedWork.stateNode = flags;
                    } else
                      mountHoistable(
                        hoistableRoot,
                        finishedWork.type,
                        finishedWork.stateNode
                      );
                  else
                    finishedWork.stateNode = acquireResource(
                      hoistableRoot,
                      flags,
                      finishedWork.memoizedProps
                    );
                else
                  root2 !== flags ? (null === root2 ? null !== current3.stateNode && (current3 = current3.stateNode, current3.parentNode.removeChild(current3)) : root2.count--, null === flags ? mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  ) : acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                    finishedWork,
                    finishedWork.memoizedProps,
                    current3.memoizedProps
                  );
              break;
            case 27:
              if (flags & 4 && null === finishedWork.alternate) {
                hoistableRoot = finishedWork.stateNode;
                maybeNodes = finishedWork.memoizedProps;
                try {
                  for (i = hoistableRoot.firstChild; i; ) {
                    var nextNode = i.nextSibling, nodeName = i.nodeName;
                    i[internalHoistableMarker] || "HEAD" === nodeName || "BODY" === nodeName || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === i.rel.toLowerCase() || hoistableRoot.removeChild(i);
                    i = nextNode;
                  }
                  runWithFiberInDEV(
                    finishedWork,
                    acquireSingletonInstance,
                    finishedWork.type,
                    maybeNodes,
                    hoistableRoot,
                    finishedWork
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
            case 5:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 512 && (offscreenSubtreeWasHidden || null === current3 || safelyDetachRef(current3, current3.return));
              if (finishedWork.flags & 32) {
                root2 = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(finishedWork, resetTextContent, root2);
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              flags & 4 && null != finishedWork.stateNode && (root2 = finishedWork.memoizedProps, commitHostUpdate(
                finishedWork,
                root2,
                null !== current3 ? current3.memoizedProps : root2
              ));
              flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
                "Unexpected host component type. Expected a form. This is a bug in React."
              ));
              break;
            case 6:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              if (flags & 4) {
                if (null === finishedWork.stateNode)
                  throw Error(
                    "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
                  );
                flags = finishedWork.memoizedProps;
                current3 = null !== current3 ? current3.memoizedProps : flags;
                root2 = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitTextUpdate,
                    root2,
                    current3,
                    flags
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              break;
            case 3:
              hoistableRoot = pushNestedEffectDurations();
              tagCaches = null;
              maybeNodes = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(root2.containerInfo);
              recursivelyTraverseMutationEffects(root2, finishedWork);
              currentHoistableRoot = maybeNodes;
              commitReconciliationEffects(finishedWork);
              if (flags & 4 && null !== current3 && current3.memoizedState.isDehydrated)
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHydratedContainer,
                    root2.containerInfo
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
              root2.effectDuration += popNestedEffectDurations(hoistableRoot);
              break;
            case 4:
              flags = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                finishedWork.stateNode.containerInfo
              );
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              currentHoistableRoot = flags;
              break;
            case 12:
              flags = pushNestedEffectDurations();
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
              break;
            case 13:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current3 && null !== current3.memoizedState) && (globalMostRecentFallbackTime = now$1());
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 22:
              flags & 512 && (offscreenSubtreeWasHidden || null === current3 || safelyDetachRef(current3, current3.return));
              i = null !== finishedWork.memoizedState;
              nextNode = null !== current3 && null !== current3.memoizedState;
              nodeName = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = nodeName || i;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || nextNode;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = nodeName;
              commitReconciliationEffects(finishedWork);
              root2 = finishedWork.stateNode;
              root2._current = finishedWork;
              root2._visibility &= ~OffscreenDetached;
              root2._visibility |= root2._pendingVisibility & OffscreenDetached;
              if (flags & 8192 && (root2._visibility = i ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, i && (root2 = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current3 || nextNode || root2 || recursivelyTraverseDisappearLayoutEffects(finishedWork)), null === finishedWork.memoizedProps || "manual" !== finishedWork.memoizedProps.mode))
                a: for (current3 = null, root2 = finishedWork; ; ) {
                  if (5 === root2.tag || 26 === root2.tag || 27 === root2.tag) {
                    if (null === current3) {
                      nextNode = current3 = root2;
                      try {
                        hoistableRoot = nextNode.stateNode, i ? runWithFiberInDEV(
                          nextNode,
                          hideInstance,
                          hoistableRoot
                        ) : runWithFiberInDEV(
                          nextNode,
                          unhideInstance,
                          nextNode.stateNode,
                          nextNode.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(nextNode, nextNode.return, error);
                      }
                    }
                  } else if (6 === root2.tag) {
                    if (null === current3) {
                      nextNode = root2;
                      try {
                        maybeNodes = nextNode.stateNode, i ? runWithFiberInDEV(
                          nextNode,
                          hideTextInstance,
                          maybeNodes
                        ) : runWithFiberInDEV(
                          nextNode,
                          unhideTextInstance,
                          maybeNodes,
                          nextNode.memoizedProps
                        );
                      } catch (error) {
                        captureCommitPhaseError(nextNode, nextNode.return, error);
                      }
                    }
                  } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                    root2.child.return = root2;
                    root2 = root2.child;
                    continue;
                  }
                  if (root2 === finishedWork) break a;
                  for (; null === root2.sibling; ) {
                    if (null === root2.return || root2.return === finishedWork)
                      break a;
                    current3 === root2 && (current3 = null);
                    root2 = root2.return;
                  }
                  current3 === root2 && (current3 = null);
                  root2.sibling.return = root2.return;
                  root2 = root2.sibling;
                }
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current3 = flags.retryQueue, null !== current3 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current3))));
              break;
            case 19:
              recursivelyTraverseMutationEffects(root2, finishedWork);
              commitReconciliationEffects(finishedWork);
              flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
              break;
            case 21:
              break;
            default:
              recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
          }
        }
        function commitReconciliationEffects(finishedWork) {
          var flags = finishedWork.flags;
          if (flags & 2) {
            try {
              runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
            finishedWork.flags &= -3;
          }
          flags & 4096 && (finishedWork.flags &= -4097);
        }
        function recursivelyResetForms(parentFiber) {
          if (parentFiber.subtreeFlags & 1024)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var fiber = parentFiber;
              recursivelyResetForms(fiber);
              5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
              parentFiber = parentFiber.sibling;
            }
        }
        function commitLayoutEffects(finishedWork, root2, committedLanes) {
          inProgressLanes = committedLanes;
          inProgressRoot = root2;
          commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
          inProgressRoot = inProgressLanes = null;
        }
        function recursivelyTraverseLayoutEffects(root2, parentFiber) {
          if (parentFiber.subtreeFlags & 8772)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
        }
        function disappearLayoutEffects(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookLayoutUnmountEffects(
                finishedWork,
                finishedWork.return,
                Layout
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance = finishedWork.stateNode;
              "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 26:
            case 27:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              safelyDetachRef(finishedWork, finishedWork.return);
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
        }
        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
        }
        function reappearLayoutEffects(finishedRoot, current3, finishedWork, includeWorkInProgressEffects) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookLayoutEffects(finishedWork, Layout);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current3 = finishedWork.stateNode;
              "function" === typeof current3.componentDidMount && runWithFiberInDEV(
                finishedWork,
                callComponentDidMountInDEV,
                finishedWork,
                current3
              );
              current3 = finishedWork.updateQueue;
              if (null !== current3) {
                finishedRoot = finishedWork.stateNode;
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitHiddenCallbacks,
                    current3,
                    finishedRoot
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 26:
            case 27:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current3 && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              if (includeWorkInProgressEffects && flags & 4) {
                flags = pushNestedEffectDurations();
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
                includeWorkInProgressEffects = finishedWork.stateNode;
                includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfiler,
                    finishedWork,
                    current3,
                    commitStartTime,
                    includeWorkInProgressEffects.effectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraverseReappearLayoutEffects(
                  finishedRoot,
                  finishedWork,
                  includeWorkInProgressEffects
                );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
        }
        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reappearLayoutEffects(
              finishedRoot,
              parentFiber.alternate,
              parentFiber,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function commitOffscreenPassiveMountEffects(current3, finishedWork) {
          var previousCache = null;
          null !== current3 && null !== current3.memoizedState && null !== current3.memoizedState.cachePool && (previousCache = current3.memoizedState.cachePool.pool);
          current3 = null;
          null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current3 = finishedWork.memoizedState.cachePool.pool);
          current3 !== previousCache && (null != current3 && retainCache(current3), null != previousCache && releaseCache(previousCache));
        }
        function commitCachePassiveMountEffect(current3, finishedWork) {
          current3 = null;
          null !== finishedWork.alternate && (current3 = finishedWork.alternate.memoizedState.cache);
          finishedWork = finishedWork.memoizedState.cache;
          finishedWork !== current3 && (retainCache(finishedWork), null != current3 && releaseCache(current3));
        }
        function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveMountOnFiber(
                root2,
                parentFiber,
                committedLanes,
                committedTransitions
              ), parentFiber = parentFiber.sibling;
        }
        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
              break;
            case 3:
              var prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
              finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
              break;
            case 12:
              if (flags & 2048) {
                prevEffectDuration = pushNestedEffectDurations();
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
                finishedRoot = finishedWork.stateNode;
                finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
                try {
                  runWithFiberInDEV(
                    finishedWork,
                    commitProfilerPostCommitImpl,
                    finishedWork,
                    finishedWork.alternate,
                    commitStartTime,
                    finishedRoot.passiveEffectDuration
                  );
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              } else
                recursivelyTraversePassiveMountEffects(
                  finishedRoot,
                  finishedWork,
                  committedLanes,
                  committedTransitions
                );
              break;
            case 23:
              break;
            case 22:
              prevEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              ) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                0 !== (finishedWork.subtreeFlags & 10256)
              ));
              flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
          }
        }
        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
          includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            reconnectPassiveEffects(
              finishedRoot,
              parentFiber,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ), parentFiber = parentFiber.sibling;
        }
        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
          var flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookPassiveMountEffects(finishedWork, Passive);
              break;
            case 23:
              break;
            case 22:
              var _instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
        }
        function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
              switch (finishedWork.tag) {
                case 22:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
                  flags & 2048 && commitOffscreenPassiveMountEffects(
                    finishedWork.alternate,
                    finishedWork
                  );
                  break;
                case 24:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
                  flags & 2048 && commitCachePassiveMountEffect(
                    finishedWork.alternate,
                    finishedWork
                  );
                  break;
                default:
                  recursivelyTraverseAtomicPassiveEffects(
                    finishedRoot,
                    finishedWork
                  );
              }
              parentFiber = parentFiber.sibling;
            }
        }
        function recursivelyAccumulateSuspenseyCommit(parentFiber) {
          if (parentFiber.subtreeFlags & suspenseyCommitFlag)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function accumulateSuspenseyCommitOnFiber(fiber) {
          switch (fiber.tag) {
            case 26:
              recursivelyAccumulateSuspenseyCommit(fiber);
              fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
                currentHoistableRoot,
                fiber.memoizedState,
                fiber.memoizedProps
              );
              break;
            case 5:
              recursivelyAccumulateSuspenseyCommit(fiber);
              break;
            case 3:
            case 4:
              var previousHoistableRoot = currentHoistableRoot;
              currentHoistableRoot = getHoistableRoot(
                fiber.stateNode.containerInfo
              );
              recursivelyAccumulateSuspenseyCommit(fiber);
              currentHoistableRoot = previousHoistableRoot;
              break;
            case 22:
              null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
              break;
            default:
              recursivelyAccumulateSuspenseyCommit(fiber);
          }
        }
        function detachAlternateSiblings(parentFiber) {
          var previousFiber = parentFiber.alternate;
          if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
            previousFiber.child = null;
            do
              previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
            while (null !== parentFiber);
          }
        }
        function recursivelyTraversePassiveUnmountEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          if (parentFiber.subtreeFlags & 10256)
            for (parentFiber = parentFiber.child; null !== parentFiber; )
              commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
        }
        function commitPassiveUnmountOnFiber(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive | HasEffect
              );
              break;
            case 3:
              var prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
              break;
            case 12:
              prevEffectDuration = pushNestedEffectDurations();
              recursivelyTraversePassiveUnmountEffects(finishedWork);
              finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
              break;
            case 22:
              prevEffectDuration = finishedWork.stateNode;
              null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
              break;
            default:
              recursivelyTraversePassiveUnmountEffects(finishedWork);
          }
        }
        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
          var deletions = parentFiber.deletions;
          if (0 !== (parentFiber.flags & 16)) {
            if (null !== deletions)
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                nextEffect = childToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                  childToDelete,
                  parentFiber
                );
              }
            detachAlternateSiblings(parentFiber);
          }
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
        }
        function disconnectPassiveEffect(finishedWork) {
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookPassiveUnmountEffects(
                finishedWork,
                finishedWork.return,
                Passive
              );
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
              break;
            case 22:
              var instance = finishedWork.stateNode;
              instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(finishedWork);
          }
        }
        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
          for (; null !== nextEffect; ) {
            var fiber = nextEffect, current3 = fiber;
            switch (current3.tag) {
              case 0:
              case 11:
              case 15:
                commitHookPassiveUnmountEffects(
                  current3,
                  nearestMountedAncestor,
                  Passive
                );
                break;
              case 23:
              case 22:
                null !== current3.memoizedState && null !== current3.memoizedState.cachePool && (current3 = current3.memoizedState.cachePool.pool, null != current3 && retainCache(current3));
                break;
              case 24:
                releaseCache(current3.memoizedState.cache);
            }
            current3 = fiber.child;
            if (null !== current3) current3.return = fiber, nextEffect = current3;
            else
              a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
                current3 = nextEffect;
                var sibling = current3.sibling, returnFiber = current3.return;
                detachFiberAfterEffects(current3);
                if (current3 === fiber) {
                  nextEffect = null;
                  break a;
                }
                if (null !== sibling) {
                  sibling.return = returnFiber;
                  nextEffect = sibling;
                  break a;
                }
                nextEffect = returnFiber;
              }
          }
        }
        function FiberNode(tag, pendingProps, key, mode) {
          this.tag = tag;
          this.key = key;
          this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
          this.index = 0;
          this.refCleanup = this.ref = null;
          this.pendingProps = pendingProps;
          this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
          this.mode = mode;
          this.subtreeFlags = this.flags = 0;
          this.deletions = null;
          this.childLanes = this.lanes = 0;
          this.alternate = null;
          this.actualDuration = -0;
          this.actualStartTime = -1.1;
          this.treeBaseDuration = this.selfBaseDuration = -0;
          this._debugOwner = this._debugInfo = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
        }
        function shouldConstruct(Component4) {
          Component4 = Component4.prototype;
          return !(!Component4 || !Component4.isReactComponent);
        }
        function createWorkInProgress(current3, pendingProps) {
          var workInProgress2 = current3.alternate;
          null === workInProgress2 ? (workInProgress2 = createFiber(
            current3.tag,
            pendingProps,
            current3.key,
            current3.mode
          ), workInProgress2.elementType = current3.elementType, workInProgress2.type = current3.type, workInProgress2.stateNode = current3.stateNode, workInProgress2._debugOwner = current3._debugOwner, workInProgress2._debugHookTypes = current3._debugHookTypes, workInProgress2.alternate = current3, current3.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current3.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
          workInProgress2.flags = current3.flags & 31457280;
          workInProgress2.childLanes = current3.childLanes;
          workInProgress2.lanes = current3.lanes;
          workInProgress2.child = current3.child;
          workInProgress2.memoizedProps = current3.memoizedProps;
          workInProgress2.memoizedState = current3.memoizedState;
          workInProgress2.updateQueue = current3.updateQueue;
          pendingProps = current3.dependencies;
          workInProgress2.dependencies = null === pendingProps ? null : {
            lanes: pendingProps.lanes,
            firstContext: pendingProps.firstContext,
            _debugThenableState: pendingProps._debugThenableState
          };
          workInProgress2.sibling = current3.sibling;
          workInProgress2.index = current3.index;
          workInProgress2.ref = current3.ref;
          workInProgress2.refCleanup = current3.refCleanup;
          workInProgress2.selfBaseDuration = current3.selfBaseDuration;
          workInProgress2.treeBaseDuration = current3.treeBaseDuration;
          workInProgress2._debugInfo = current3._debugInfo;
          workInProgress2._debugNeedsRemount = current3._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case 0:
            case 15:
              workInProgress2.type = resolveFunctionForHotReloading(current3.type);
              break;
            case 1:
              workInProgress2.type = resolveFunctionForHotReloading(current3.type);
              break;
            case 11:
              workInProgress2.type = resolveForwardRefForHotReloading(current3.type);
          }
          return workInProgress2;
        }
        function resetWorkInProgress(workInProgress2, renderLanes2) {
          workInProgress2.flags &= 31457282;
          var current3 = workInProgress2.alternate;
          null === current3 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current3.childLanes, workInProgress2.lanes = current3.lanes, workInProgress2.child = current3.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current3.memoizedProps, workInProgress2.memoizedState = current3.memoizedState, workInProgress2.updateQueue = current3.updateQueue, workInProgress2.type = current3.type, renderLanes2 = current3.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
            lanes: renderLanes2.lanes,
            firstContext: renderLanes2.firstContext,
            _debugThenableState: renderLanes2._debugThenableState
          }, workInProgress2.selfBaseDuration = current3.selfBaseDuration, workInProgress2.treeBaseDuration = current3.treeBaseDuration);
          return workInProgress2;
        }
        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
          var fiberTag = 0, resolvedType = type;
          if ("function" === typeof type)
            shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
          else if ("string" === typeof type)
            fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
          else
            a: switch (type) {
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(
                  pendingProps.children,
                  mode,
                  lanes,
                  key
                );
              case REACT_STRICT_MODE_TYPE:
                fiberTag = 8;
                mode |= StrictLegacyMode;
                mode |= StrictEffectsMode;
                break;
              case REACT_PROFILER_TYPE:
                return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
                  'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
                  typeof type.id
                ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
              case REACT_SUSPENSE_TYPE:
                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
              case REACT_SUSPENSE_LIST_TYPE:
                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
              case REACT_OFFSCREEN_TYPE:
                return createFiberFromOffscreen(pendingProps, mode, lanes, key);
              default:
                if ("object" === typeof type && null !== type)
                  switch (type.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                    case REACT_CONTEXT_TYPE:
                      fiberTag = 10;
                      break a;
                    case REACT_CONSUMER_TYPE:
                      fiberTag = 9;
                      break a;
                    case REACT_FORWARD_REF_TYPE2:
                      fiberTag = 11;
                      resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      break a;
                    case REACT_MEMO_TYPE2:
                      fiberTag = 14;
                      break a;
                    case REACT_LAZY_TYPE:
                      fiberTag = 16;
                      resolvedType = null;
                      break a;
                  }
                resolvedType = "";
                if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
                  resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
                (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
                fiberTag = 29;
                pendingProps = Error(
                  "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
                );
                resolvedType = null;
            }
          key = createFiber(fiberTag, pendingProps, key, mode);
          key.elementType = type;
          key.type = resolvedType;
          key.lanes = lanes;
          key._debugOwner = owner;
          return key;
        }
        function createFiberFromElement(element, mode, lanes) {
          mode = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            element._owner,
            mode,
            lanes
          );
          mode._debugOwner = element._owner;
          return mode;
        }
        function createFiberFromFragment(elements, mode, lanes, key) {
          elements = createFiber(7, elements, key, mode);
          elements.lanes = lanes;
          return elements;
        }
        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
          pendingProps = createFiber(22, pendingProps, key, mode);
          pendingProps.elementType = REACT_OFFSCREEN_TYPE;
          pendingProps.lanes = lanes;
          var primaryChildInstance = {
            _visibility: OffscreenVisible,
            _pendingVisibility: OffscreenVisible,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null,
            _current: null,
            detach: function() {
              var instance = primaryChildInstance, fiber = instance._current;
              if (null === fiber)
                throw Error(
                  "Calling Offscreen.detach before instance handle has been set."
                );
              if (0 === (instance._pendingVisibility & OffscreenDetached)) {
                var root2 = enqueueConcurrentRenderForLane(fiber, 2);
                null !== root2 && (instance._pendingVisibility |= OffscreenDetached, scheduleUpdateOnFiber(root2, fiber, 2));
              }
            },
            attach: function() {
              var instance = primaryChildInstance, fiber = instance._current;
              if (null === fiber)
                throw Error(
                  "Calling Offscreen.detach before instance handle has been set."
                );
              if (0 !== (instance._pendingVisibility & OffscreenDetached)) {
                var root2 = enqueueConcurrentRenderForLane(fiber, 2);
                null !== root2 && (instance._pendingVisibility &= ~OffscreenDetached, scheduleUpdateOnFiber(root2, fiber, 2));
              }
            }
          };
          pendingProps.stateNode = primaryChildInstance;
          return pendingProps;
        }
        function createFiberFromText(content, mode, lanes) {
          content = createFiber(6, content, null, mode);
          content.lanes = lanes;
          return content;
        }
        function createFiberFromPortal(portal, mode, lanes) {
          mode = createFiber(
            4,
            null !== portal.children ? portal.children : [],
            portal.key,
            mode
          );
          mode.lanes = lanes;
          mode.stateNode = {
            containerInfo: portal.containerInfo,
            pendingChildren: null,
            implementation: portal.implementation
          };
          return mode;
        }
        function markUpdate(workInProgress2) {
          workInProgress2.flags |= 4;
        }
        function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
          if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
            workInProgress2.flags &= -16777217;
          else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
            resource = suspenseHandlerStackCursor.current;
            if (null !== resource && ((workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
              throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
            workInProgress2.flags |= 8192;
          }
        }
        function scheduleRetryEffect(workInProgress2, retryQueue) {
          null !== retryQueue && (workInProgress2.flags |= 4);
          workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
        }
        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
          if (!isHydrating)
            switch (renderState.tailMode) {
              case "hidden":
                hasRenderedATailFallback = renderState.tail;
                for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                  null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
                break;
              case "collapsed":
                lastTailNode = renderState.tail;
                for (var _lastTailNode = null; null !== lastTailNode; )
                  null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
            }
        }
        function bubbleProperties(completedWork) {
          var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
          if (didBailout)
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
                newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
              completedWork.treeBaseDuration = _treeBaseDuration;
            } else
              for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
                newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          else if ((completedWork.mode & ProfileMode) !== NoMode) {
            _treeBaseDuration = completedWork.actualDuration;
            _child2 = completedWork.selfBaseDuration;
            for (var child = completedWork.child; null !== child; )
              newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
            completedWork.actualDuration = _treeBaseDuration;
            completedWork.treeBaseDuration = _child2;
          } else
            for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
              newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
          completedWork.subtreeFlags |= subtreeFlags;
          completedWork.childLanes = newChildLanes;
          return didBailout;
        }
        function completeWork(current3, workInProgress2, renderLanes2) {
          var newProps = workInProgress2.pendingProps;
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
              return bubbleProperties(workInProgress2), null;
            case 1:
              return bubbleProperties(workInProgress2), null;
            case 3:
              newProps = workInProgress2.stateNode;
              renderLanes2 = null;
              null !== current3 && (renderLanes2 = current3.memoizedState.cache);
              workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048);
              popProvider(CacheContext, workInProgress2);
              popHostContainer(workInProgress2);
              newProps.pendingContext && (newProps.context = newProps.pendingContext, newProps.pendingContext = null);
              if (null === current3 || null === current3.child)
                popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current3 || current3.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));
              bubbleProperties(workInProgress2);
              return null;
            case 26:
              return renderLanes2 = workInProgress2.memoizedState, null === current3 ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current3.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
                workInProgress2,
                renderLanes2
              )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current3.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
            case 27:
              popHostContext(workInProgress2);
              renderLanes2 = requiredContext(rootInstanceStackCursor.current);
              var _type = workInProgress2.type;
              if (null !== current3 && null != workInProgress2.stateNode)
                current3.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                current3 = getHostContext();
                popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current3) : (current3 = resolveSingletonInstance(
                  _type,
                  newProps,
                  renderLanes2,
                  current3,
                  true
                ), workInProgress2.stateNode = current3, markUpdate(workInProgress2));
              }
              bubbleProperties(workInProgress2);
              return null;
            case 5:
              popHostContext(workInProgress2);
              renderLanes2 = workInProgress2.type;
              if (null !== current3 && null != workInProgress2.stateNode)
                current3.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if (!newProps) {
                  if (null === workInProgress2.stateNode)
                    throw Error(
                      "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                    );
                  bubbleProperties(workInProgress2);
                  return null;
                }
                _type = getHostContext();
                if (popHydrationState(workInProgress2))
                  prepareToHydrateHostInstance(workInProgress2, _type);
                else {
                  current3 = requiredContext(rootInstanceStackCursor.current);
                  validateDOMNesting(renderLanes2, _type.ancestorInfo);
                  _type = _type.context;
                  current3 = getOwnerDocumentFromRootContainer(current3);
                  switch (_type) {
                    case HostContextNamespaceSvg:
                      current3 = current3.createElementNS(SVG_NAMESPACE, renderLanes2);
                      break;
                    case HostContextNamespaceMath:
                      current3 = current3.createElementNS(
                        MATH_NAMESPACE,
                        renderLanes2
                      );
                      break;
                    default:
                      switch (renderLanes2) {
                        case "svg":
                          current3 = current3.createElementNS(
                            SVG_NAMESPACE,
                            renderLanes2
                          );
                          break;
                        case "math":
                          current3 = current3.createElementNS(
                            MATH_NAMESPACE,
                            renderLanes2
                          );
                          break;
                        case "script":
                          current3 = current3.createElement("div");
                          current3.innerHTML = "<script><\/script>";
                          current3 = current3.removeChild(current3.firstChild);
                          break;
                        case "select":
                          current3 = "string" === typeof newProps.is ? current3.createElement("select", { is: newProps.is }) : current3.createElement("select");
                          newProps.multiple ? current3.multiple = true : newProps.size && (current3.size = newProps.size);
                          break;
                        default:
                          current3 = "string" === typeof newProps.is ? current3.createElement(renderLanes2, {
                            is: newProps.is
                          }) : current3.createElement(renderLanes2), -1 === renderLanes2.indexOf("-") && (renderLanes2 !== renderLanes2.toLowerCase() && console.error(
                            "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
                            renderLanes2
                          ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current3) || hasOwnProperty.call(
                            warnedUnknownTags,
                            renderLanes2
                          ) || (warnedUnknownTags[renderLanes2] = true, console.error(
                            "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
                            renderLanes2
                          )));
                      }
                  }
                  current3[internalInstanceKey] = workInProgress2;
                  current3[internalPropsKey] = newProps;
                  a: for (_type = workInProgress2.child; null !== _type; ) {
                    if (5 === _type.tag || 6 === _type.tag)
                      current3.appendChild(_type.stateNode);
                    else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
                      _type.child.return = _type;
                      _type = _type.child;
                      continue;
                    }
                    if (_type === workInProgress2) break a;
                    for (; null === _type.sibling; ) {
                      if (null === _type.return || _type.return === workInProgress2)
                        break a;
                      _type = _type.return;
                    }
                    _type.sibling.return = _type.return;
                    _type = _type.sibling;
                  }
                  workInProgress2.stateNode = current3;
                  a: switch (setInitialProperties(current3, renderLanes2, newProps), renderLanes2) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      current3 = !!newProps.autoFocus;
                      break a;
                    case "img":
                      current3 = true;
                      break a;
                    default:
                      current3 = false;
                  }
                  current3 && markUpdate(workInProgress2);
                }
              }
              bubbleProperties(workInProgress2);
              workInProgress2.flags &= -16777217;
              return null;
            case 6:
              if (current3 && null != workInProgress2.stateNode)
                current3.memoizedProps !== newProps && markUpdate(workInProgress2);
              else {
                if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                  throw Error(
                    "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
                  );
                current3 = requiredContext(rootInstanceStackCursor.current);
                renderLanes2 = getHostContext();
                if (popHydrationState(workInProgress2)) {
                  current3 = workInProgress2.stateNode;
                  newProps = workInProgress2.memoizedProps;
                  _type = !didSuspendOrErrorDEV;
                  renderLanes2 = null;
                  var returnFiber = hydrationParentFiber;
                  if (null !== returnFiber)
                    switch (returnFiber.tag) {
                      case 3:
                        _type && (_type = diffHydratedTextForDevWarnings(
                          current3,
                          newProps,
                          renderLanes2
                        ), null !== _type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = _type));
                        break;
                      case 27:
                      case 5:
                        renderLanes2 = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(
                          current3,
                          newProps,
                          renderLanes2
                        ), null !== _type && (buildHydrationDiffNode(
                          workInProgress2,
                          0
                        ).serverProps = _type));
                    }
                  current3[internalInstanceKey] = workInProgress2;
                  current3 = current3.nodeValue === newProps || null !== renderLanes2 && true === renderLanes2.suppressHydrationWarning || checkForUnmatchedText(current3.nodeValue, newProps) ? true : false;
                  current3 || throwOnHydrationMismatch(workInProgress2);
                } else
                  renderLanes2 = renderLanes2.ancestorInfo.current, null != renderLanes2 && validateTextNesting(newProps, renderLanes2.tag), current3 = getOwnerDocumentFromRootContainer(current3).createTextNode(
                    newProps
                  ), current3[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current3;
              }
              bubbleProperties(workInProgress2);
              return null;
            case 13:
              newProps = workInProgress2.memoizedState;
              if (null === current3 || null !== current3.memoizedState && null !== current3.memoizedState.dehydrated) {
                _type = popHydrationState(workInProgress2);
                if (null !== newProps && null !== newProps.dehydrated) {
                  if (null === current3) {
                    if (!_type)
                      throw Error(
                        "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
                      );
                    _type = workInProgress2.memoizedState;
                    _type = null !== _type ? _type.dehydrated : null;
                    if (!_type)
                      throw Error(
                        "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
                      );
                    _type[internalInstanceKey] = workInProgress2;
                    bubbleProperties(workInProgress2);
                    (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                  } else
                    emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
                  _type = false;
                } else
                  null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), _type = true;
                if (!_type) {
                  if (workInProgress2.flags & 256)
                    return popSuspenseHandler(workInProgress2), workInProgress2;
                  popSuspenseHandler(workInProgress2);
                  return null;
                }
              }
              popSuspenseHandler(workInProgress2);
              if (0 !== (workInProgress2.flags & 128))
                return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
              newProps = null !== newProps;
              current3 = null !== current3 && null !== current3.memoizedState;
              newProps && (renderLanes2 = workInProgress2.child, _type = null, null !== renderLanes2.alternate && null !== renderLanes2.alternate.memoizedState && null !== renderLanes2.alternate.memoizedState.cachePool && (_type = renderLanes2.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== renderLanes2.memoizedState && null !== renderLanes2.memoizedState.cachePool && (returnFiber = renderLanes2.memoizedState.cachePool.pool), returnFiber !== _type && (renderLanes2.flags |= 2048));
              newProps !== current3 && newProps && (workInProgress2.child.flags |= 8192);
              scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
              bubbleProperties(workInProgress2);
              (workInProgress2.mode & ProfileMode) !== NoMode && newProps && (current3 = workInProgress2.child, null !== current3 && (workInProgress2.treeBaseDuration -= current3.treeBaseDuration));
              return null;
            case 4:
              return popHostContainer(workInProgress2), null === current3 && listenToAllSupportedEvents(
                workInProgress2.stateNode.containerInfo
              ), bubbleProperties(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
            case 19:
              pop(suspenseStackCursor, workInProgress2);
              _type = workInProgress2.memoizedState;
              if (null === _type) return bubbleProperties(workInProgress2), null;
              newProps = 0 !== (workInProgress2.flags & 128);
              returnFiber = _type.rendering;
              if (null === returnFiber)
                if (newProps) cutOffTailIfNeeded(_type, false);
                else {
                  if (workInProgressRootExitStatus !== RootInProgress || null !== current3 && 0 !== (current3.flags & 128))
                    for (current3 = workInProgress2.child; null !== current3; ) {
                      returnFiber = findFirstSuspended(current3);
                      if (null !== returnFiber) {
                        workInProgress2.flags |= 128;
                        cutOffTailIfNeeded(_type, false);
                        current3 = returnFiber.updateQueue;
                        workInProgress2.updateQueue = current3;
                        scheduleRetryEffect(workInProgress2, current3);
                        workInProgress2.subtreeFlags = 0;
                        current3 = renderLanes2;
                        for (newProps = workInProgress2.child; null !== newProps; )
                          resetWorkInProgress(newProps, current3), newProps = newProps.sibling;
                        push(
                          suspenseStackCursor,
                          suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
                          workInProgress2
                        );
                        return workInProgress2.child;
                      }
                      current3 = current3.sibling;
                    }
                  null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                }
              else {
                if (!newProps)
                  if (current3 = findFirstSuspended(returnFiber), null !== current3) {
                    if (workInProgress2.flags |= 128, newProps = true, current3 = current3.updateQueue, workInProgress2.updateQueue = current3, scheduleRetryEffect(workInProgress2, current3), cutOffTailIfNeeded(_type, true), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating)
                      return bubbleProperties(workInProgress2), null;
                  } else
                    2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
                _type.isBackwards ? (returnFiber.sibling = workInProgress2.child, workInProgress2.child = returnFiber) : (current3 = _type.last, null !== current3 ? current3.sibling = returnFiber : workInProgress2.child = returnFiber, _type.last = returnFiber);
              }
              if (null !== _type.tail)
                return current3 = _type.tail, _type.rendering = current3, _type.tail = current3.sibling, _type.renderingStartTime = now$1(), current3.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = newProps ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), current3;
              bubbleProperties(workInProgress2);
              return null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current3 ? null !== current3.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), newProps = workInProgress2.updateQueue, null !== newProps && scheduleRetryEffect(workInProgress2, newProps.retryQueue), newProps = null, null !== current3 && null !== current3.memoizedState && null !== current3.memoizedState.cachePool && (newProps = current3.memoizedState.cachePool.pool), renderLanes2 = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (renderLanes2 = workInProgress2.memoizedState.cachePool.pool), renderLanes2 !== newProps && (workInProgress2.flags |= 2048), null !== current3 && pop(resumedCache, workInProgress2), null;
            case 24:
              return newProps = null, null !== current3 && (newProps = current3.memoizedState.cache), workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
            case 25:
              return null;
          }
          throw Error(
            "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
          );
        }
        function unwindWork(current3, workInProgress2) {
          popTreeContext(workInProgress2);
          switch (workInProgress2.tag) {
            case 1:
              return current3 = workInProgress2.flags, current3 & 65536 ? (workInProgress2.flags = current3 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 3:
              return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current3 = workInProgress2.flags, 0 !== (current3 & 65536) && 0 === (current3 & 128) ? (workInProgress2.flags = current3 & -65537 | 128, workInProgress2) : null;
            case 26:
            case 27:
            case 5:
              return popHostContext(workInProgress2), null;
            case 13:
              popSuspenseHandler(workInProgress2);
              current3 = workInProgress2.memoizedState;
              if (null !== current3 && null !== current3.dehydrated) {
                if (null === workInProgress2.alternate)
                  throw Error(
                    "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
                  );
                resetHydrationState();
              }
              current3 = workInProgress2.flags;
              return current3 & 65536 ? (workInProgress2.flags = current3 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 19:
              return pop(suspenseStackCursor, workInProgress2), null;
            case 4:
              return popHostContainer(workInProgress2), null;
            case 10:
              return popProvider(workInProgress2.type, workInProgress2), null;
            case 22:
            case 23:
              return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current3 && pop(resumedCache, workInProgress2), current3 = workInProgress2.flags, current3 & 65536 ? (workInProgress2.flags = current3 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
            case 24:
              return popProvider(CacheContext, workInProgress2), null;
            case 25:
              return null;
            default:
              return null;
          }
        }
        function unwindInterruptedWork(current3, interruptedWork) {
          popTreeContext(interruptedWork);
          switch (interruptedWork.tag) {
            case 3:
              popProvider(CacheContext, interruptedWork);
              popHostContainer(interruptedWork);
              break;
            case 26:
            case 27:
            case 5:
              popHostContext(interruptedWork);
              break;
            case 4:
              popHostContainer(interruptedWork);
              break;
            case 13:
              popSuspenseHandler(interruptedWork);
              break;
            case 19:
              pop(suspenseStackCursor, interruptedWork);
              break;
            case 10:
              popProvider(interruptedWork.type, interruptedWork);
              break;
            case 22:
            case 23:
              popSuspenseHandler(interruptedWork);
              popHiddenContext(interruptedWork);
              null !== current3 && pop(resumedCache, interruptedWork);
              break;
            case 24:
              popProvider(CacheContext, interruptedWork);
          }
        }
        function onCommitRoot() {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
        function isConcurrentActEnvironment() {
          var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
          isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
            "The current testing environment is not configured to support act(...)"
          );
          return isReactActEnvironmentGlobal;
        }
        function requestUpdateLane(fiber) {
          if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
            return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
          var transition = ReactSharedInternals.T;
          return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
        }
        function requestDeferredLane() {
          0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
          var suspenseHandler = suspenseHandlerStackCursor.current;
          null !== suspenseHandler && (suspenseHandler.flags |= 32);
          return workInProgressDeferredLane;
        }
        function scheduleUpdateOnFiber(root2, fiber, lane) {
          isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
          isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
          if (root2 === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root2.cancelPendingCommit)
            prepareFreshStack(root2, 0), markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            );
          markRootUpdated$1(root2, lane);
          if (0 !== (executionContext & RenderContext) && root2 === workInProgressRoot) {
            if (isRendering)
              switch (fiber.tag) {
                case 0:
                case 11:
                case 15:
                  root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                  didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
                    "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
                    fiber,
                    root2,
                    root2
                  ));
                  break;
                case 1:
                  didWarnAboutUpdateInRender || (console.error(
                    "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
                  ), didWarnAboutUpdateInRender = true);
              }
          } else
            isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
              root2,
              workInProgressRootRenderLanes,
              workInProgressDeferredLane,
              false
            )), ensureRootIsScheduled(root2);
        }
        function performWorkOnRoot(root2, lanes, forceSync) {
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root2.expiredLanes) || checkIfRootIsPrerendering(root2, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true), renderWasConcurrent = shouldTimeSlice;
          do {
            if (exitStatus === RootInProgress) {
              workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root2, lanes, 0, false);
              break;
            } else if (exitStatus === RootDidNotComplete)
              markRootSuspended(
                root2,
                lanes,
                0,
                !workInProgressRootDidSkipSuspendedSiblings
              );
            else {
              forceSync = root2.current.alternate;
              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
                exitStatus = renderRootSync(root2, lanes, false);
                renderWasConcurrent = false;
                continue;
              }
              if (exitStatus === RootErrored) {
                renderWasConcurrent = lanes;
                if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
                  var errorRetryLanes = 0;
                else
                  errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
                if (0 !== errorRetryLanes) {
                  lanes = errorRetryLanes;
                  a: {
                    exitStatus = root2;
                    var errorRetryLanes$jscomp$0 = errorRetryLanes;
                    errorRetryLanes = workInProgressRootConcurrentErrors;
                    var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
                    wasRootDehydrated && (prepareFreshStack(
                      exitStatus,
                      errorRetryLanes$jscomp$0
                    ).flags |= 256);
                    errorRetryLanes$jscomp$0 = renderRootSync(
                      exitStatus,
                      errorRetryLanes$jscomp$0,
                      false
                    );
                    if (errorRetryLanes$jscomp$0 !== RootErrored) {
                      if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                        exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                        workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                        exitStatus = RootSuspendedWithDelay;
                        break a;
                      }
                      exitStatus = workInProgressRootRecoverableErrors;
                      workInProgressRootRecoverableErrors = errorRetryLanes;
                      null !== exitStatus && queueRecoverableErrors(exitStatus);
                    }
                    exitStatus = errorRetryLanes$jscomp$0;
                  }
                  renderWasConcurrent = false;
                  if (exitStatus !== RootErrored) continue;
                }
              }
              if (exitStatus === RootFatalErrored) {
                prepareFreshStack(root2, 0);
                markRootSuspended(root2, lanes, 0, true);
                break;
              }
              a: {
                shouldTimeSlice = root2;
                switch (exitStatus) {
                  case RootInProgress:
                  case RootFatalErrored:
                    throw Error("Root did not complete. This is a bug in React.");
                  case RootSuspendedWithDelay:
                    if ((lanes & 4194176) === lanes) {
                      markRootSuspended(
                        shouldTimeSlice,
                        lanes,
                        workInProgressDeferredLane,
                        !workInProgressRootDidSkipSuspendedSiblings
                      );
                      break a;
                    }
                    break;
                  case RootErrored:
                    workInProgressRootRecoverableErrors = null;
                    break;
                  case RootSuspended:
                  case RootCompleted:
                    break;
                  default:
                    throw Error("Unknown root exit status.");
                }
                shouldTimeSlice.finishedWork = forceSync;
                shouldTimeSlice.finishedLanes = lanes;
                if (null !== ReactSharedInternals.actQueue)
                  commitRoot(
                    shouldTimeSlice,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    IMMEDIATE_COMMIT,
                    renderStartTime,
                    0
                  );
                else {
                  if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {
                    markRootSuspended(
                      shouldTimeSlice,
                      lanes,
                      workInProgressDeferredLane,
                      !workInProgressRootDidSkipSuspendedSiblings
                    );
                    if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
                    shouldTimeSlice.timeoutHandle = scheduleTimeout(
                      commitRootWhenReady.bind(
                        null,
                        shouldTimeSlice,
                        forceSync,
                        workInProgressRootRecoverableErrors,
                        workInProgressTransitions,
                        workInProgressRootDidIncludeRecursiveRenderUpdate,
                        lanes,
                        workInProgressDeferredLane,
                        workInProgressRootInterleavedUpdatedLanes,
                        workInProgressSuspendedRetryLanes,
                        workInProgressRootDidSkipSuspendedSiblings,
                        THROTTLED_COMMIT,
                        renderStartTime,
                        0
                      ),
                      exitStatus
                    );
                    break a;
                  }
                  commitRootWhenReady(
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    IMMEDIATE_COMMIT,
                    renderStartTime,
                    0
                  );
                }
              }
            }
            break;
          } while (1);
          ensureRootIsScheduled(root2);
        }
        function queueRecoverableErrors(errors2) {
          null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors2 : workInProgressRootRecoverableErrors.push.apply(
            workInProgressRootRecoverableErrors,
            errors2
          );
        }
        function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          var subtreeFlags = finishedWork.subtreeFlags;
          if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {
            if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop5 }, accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {
              root2.cancelPendingCommit = finishedWork(
                commitRoot.bind(
                  null,
                  root2,
                  recoverableErrors,
                  transitions,
                  didIncludeRenderPhaseUpdate,
                  spawnedLane,
                  updatedLanes,
                  suspendedRetryLanes,
                  SUSPENDED_COMMIT,
                  completedRenderStartTime,
                  completedRenderEndTime
                )
              );
              markRootSuspended(
                root2,
                lanes,
                spawnedLane,
                !didSkipSuspendedSiblings
              );
              return;
            }
          }
          commitRoot(
            root2,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            suspendedCommitReason,
            completedRenderStartTime,
            completedRenderEndTime
          );
        }
        function isRenderConsistentWithExternalStores(finishedWork) {
          for (var node2 = finishedWork; ; ) {
            var tag = node2.tag;
            if ((0 === tag || 11 === tag || 15 === tag) && node2.flags & 16384 && (tag = node2.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
              for (var i = 0; i < tag.length; i++) {
                var check = tag[i], getSnapshot = check.getSnapshot;
                check = check.value;
                try {
                  if (!objectIs(getSnapshot(), check)) return false;
                } catch (error) {
                  return false;
                }
              }
            tag = node2.child;
            if (node2.subtreeFlags & 16384 && null !== tag)
              tag.return = node2, node2 = tag;
            else {
              if (node2 === finishedWork) break;
              for (; null === node2.sibling; ) {
                if (null === node2.return || node2.return === finishedWork) return true;
                node2 = node2.return;
              }
              node2.sibling.return = node2.return;
              node2 = node2.sibling;
            }
          }
          return true;
        }
        function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
          suspendedLanes &= ~workInProgressRootPingedLanes;
          suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
          root2.suspendedLanes |= suspendedLanes;
          root2.pingedLanes &= ~suspendedLanes;
          didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
          didAttemptEntireTree = root2.expirationTimes;
          for (var lanes = suspendedLanes; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index;
            didAttemptEntireTree[index] = -1;
            lanes &= ~lane;
          }
          0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
        }
        function flushSyncWork$1() {
          return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
        }
        function resetWorkInProgressStack() {
          if (null !== workInProgress) {
            if (workInProgressSuspendedReason === NotSuspended)
              var interruptedWork = workInProgress.return;
            else
              interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
            for (; null !== interruptedWork; )
              unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
            workInProgress = null;
          }
        }
        function prepareFreshStack(root2, lanes) {
          root2.finishedWork = null;
          root2.finishedLanes = 0;
          var timeoutHandle = root2.timeoutHandle;
          timeoutHandle !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
          timeoutHandle = root2.cancelPendingCommit;
          null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
          resetWorkInProgressStack();
          workInProgressRoot = root2;
          workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
          workInProgressRootRenderLanes = lanes;
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          workInProgressRootDidSkipSuspendedSiblings = false;
          workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
          workInProgressRootDidAttachPingListener = false;
          workInProgressRootExitStatus = RootInProgress;
          workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
          workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
          workInProgressRootDidIncludeRecursiveRenderUpdate = false;
          0 !== (lanes & 8) && (lanes |= lanes & 32);
          var allEntangledLanes = root2.entangledLanes;
          if (0 !== allEntangledLanes)
            for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
              var index = 31 - clz32(allEntangledLanes), lane = 1 << index;
              lanes |= root2[index];
              allEntangledLanes &= ~lane;
            }
          entangledRenderLanes = lanes;
          finishQueueingConcurrentUpdates();
          ReactStrictModeWarnings.discardPendingWarnings();
          return timeoutHandle;
        }
        function handleThrow(root2, thrownValue) {
          currentlyRenderingFiber$1 = null;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          ReactSharedInternals.getCurrentStack = null;
          isRendering = false;
          current2 = null;
          thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
          workInProgressThrownValue = thrownValue;
          var erroredWork = workInProgress;
          if (null === erroredWork)
            workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
          else
            switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
              case SuspendedOnError:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(
                  erroredWork,
                  thrownValue,
                  workInProgressRootRenderLanes
                );
                break;
              case SuspendedOnData:
              case SuspendedOnImmediate:
              case SuspendedOnDeprecatedThrowPromise:
              case SuspendedAndReadyToContinue:
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(
                  erroredWork,
                  thrownValue,
                  workInProgressRootRenderLanes
                );
            }
        }
        function pushDispatcher() {
          var prevDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = ContextOnlyDispatcher;
          return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
        }
        function pushAsyncDispatcher() {
          var prevAsyncDispatcher = ReactSharedInternals.A;
          ReactSharedInternals.A = DefaultAsyncDispatcher;
          return prevAsyncDispatcher;
        }
        function renderDidSuspendDelayIfPossible() {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
          workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
          0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
            workInProgressRoot,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        }
        function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            prepareFreshStack(root2, lanes);
          }
          markRenderStarted(lanes);
          lanes = false;
          memoizedUpdaters = workInProgressRootExitStatus;
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    memoizedUpdaters = RootDidNotComplete;
                    break a;
                  case SuspendedOnImmediate:
                  case SuspendedOnData:
                  case SuspendedOnDeprecatedThrowPromise:
                    null === suspenseHandlerStackCursor.current && (lanes = true);
                    var reason = workInProgressSuspendedReason;
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                    if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                      memoizedUpdaters = RootInProgress;
                      break a;
                    }
                    break;
                  default:
                    reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                }
              }
              workLoopSync();
              memoizedUpdaters = workInProgressRootExitStatus;
              break;
            } catch (thrownValue$8) {
              handleThrow(root2, thrownValue$8);
            }
          while (1);
          lanes && root2.shellSuspendCounter++;
          resetContextDependencies();
          executionContext = prevExecutionContext;
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          markRenderStopped();
          null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
          return memoizedUpdaters;
        }
        function workLoopSync() {
          for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
        }
        function renderRootConcurrent(root2, lanes) {
          var prevExecutionContext = executionContext;
          executionContext |= RenderContext;
          var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
              movePendingFibersToMemoized(root2, lanes);
            }
            workInProgressTransitions = null;
            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
            prepareFreshStack(root2, lanes);
          } else
            workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
              root2,
              lanes
            );
          markRenderStarted(lanes);
          a: do
            try {
              if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
                b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
                  case SuspendedOnError:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnError
                    );
                    break;
                  case SuspendedOnData:
                    if (isThenableResolved(memoizedUpdaters)) {
                      workInProgressSuspendedReason = NotSuspended;
                      workInProgressThrownValue = null;
                      replaySuspendedUnitOfWork(lanes);
                      break;
                    }
                    lanes = function() {
                      workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root2 && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
                      ensureRootIsScheduled(root2);
                    };
                    memoizedUpdaters.then(lanes, lanes);
                    break a;
                  case SuspendedOnImmediate:
                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;
                    break a;
                  case SuspendedOnInstance:
                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
                    break a;
                  case SuspendedAndReadyToContinue:
                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedAndReadyToContinue
                    ));
                    break;
                  case SuspendedOnInstanceAndReadyToContinue:
                    var resource = null;
                    switch (workInProgress.tag) {
                      case 26:
                        resource = workInProgress.memoizedState;
                      case 5:
                      case 27:
                        var hostFiber = workInProgress;
                        if (resource ? preloadResource(resource) : 1) {
                          workInProgressSuspendedReason = NotSuspended;
                          workInProgressThrownValue = null;
                          var sibling = hostFiber.sibling;
                          if (null !== sibling) workInProgress = sibling;
                          else {
                            var returnFiber = hostFiber.return;
                            null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                          }
                          break b;
                        }
                        break;
                      default:
                        console.error(
                          "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
                        );
                    }
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnInstanceAndReadyToContinue
                    );
                    break;
                  case SuspendedOnDeprecatedThrowPromise:
                    workInProgressSuspendedReason = NotSuspended;
                    workInProgressThrownValue = null;
                    throwAndUnwindWorkLoop(
                      root2,
                      lanes,
                      memoizedUpdaters,
                      SuspendedOnDeprecatedThrowPromise
                    );
                    break;
                  case SuspendedOnHydration:
                    resetWorkInProgressStack();
                    workInProgressRootExitStatus = RootDidNotComplete;
                    break a;
                  default:
                    throw Error(
                      "Unexpected SuspendedReason. This is a bug in React."
                    );
                }
              null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();
              break;
            } catch (thrownValue$9) {
              handleThrow(root2, thrownValue$9);
            }
          while (1);
          resetContextDependencies();
          ReactSharedInternals.H = prevDispatcher;
          ReactSharedInternals.A = prevAsyncDispatcher;
          executionContext = prevExecutionContext;
          if (null !== workInProgress)
            return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
          markRenderStopped();
          workInProgressRoot = null;
          workInProgressRootRenderLanes = 0;
          finishQueueingConcurrentUpdates();
          return workInProgressRootExitStatus;
        }
        function workLoopConcurrent() {
          for (; null !== workInProgress && !shouldYield(); )
            performUnitOfWork(workInProgress);
        }
        function performUnitOfWork(unitOfWork) {
          var current3 = unitOfWork.alternate;
          (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current3 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current3,
            unitOfWork,
            entangledRenderLanes
          ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current3 = runWithFiberInDEV(
            unitOfWork,
            beginWork,
            current3,
            unitOfWork,
            entangledRenderLanes
          );
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === current3 ? completeUnitOfWork(unitOfWork) : workInProgress = current3;
        }
        function replaySuspendedUnitOfWork(unitOfWork) {
          var next2 = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
          unitOfWork.memoizedProps = unitOfWork.pendingProps;
          null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
        }
        function replayBeginWork(unitOfWork) {
          var current3 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
          isProfilingMode && startProfilerTimer(unitOfWork);
          switch (unitOfWork.tag) {
            case 15:
            case 0:
              current3 = replayFunctionComponent(
                current3,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type,
                void 0,
                workInProgressRootRenderLanes
              );
              break;
            case 11:
              current3 = replayFunctionComponent(
                current3,
                unitOfWork,
                unitOfWork.pendingProps,
                unitOfWork.type.render,
                unitOfWork.ref,
                workInProgressRootRenderLanes
              );
              break;
            case 5:
              resetHooksOnUnwind(unitOfWork);
            default:
              unwindInterruptedWork(current3, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current3 = beginWork(current3, unitOfWork, entangledRenderLanes);
          }
          isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
          return current3;
        }
        function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
          resetContextDependencies();
          resetHooksOnUnwind(unitOfWork);
          thenableState$1 = null;
          thenableIndexCounter$1 = 0;
          var returnFiber = unitOfWork.return;
          try {
            if (throwException(
              root2,
              returnFiber,
              unitOfWork,
              thrownValue,
              workInProgressRootRenderLanes
            )) {
              workInProgressRootExitStatus = RootFatalErrored;
              logUncaughtError(
                root2,
                createCapturedValueAtFiber(thrownValue, root2.current)
              );
              workInProgress = null;
              return;
            }
          } catch (error) {
            if (null !== returnFiber) throw workInProgress = returnFiber, error;
            workInProgressRootExitStatus = RootFatalErrored;
            logUncaughtError(
              root2,
              createCapturedValueAtFiber(thrownValue, root2.current)
            );
            workInProgress = null;
            return;
          }
          if (unitOfWork.flags & 32768) {
            if (isHydrating || suspendedReason === SuspendedOnError) root2 = true;
            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
              root2 = false;
            else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
              suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
            unwindUnitOfWork(unitOfWork, root2);
          } else completeUnitOfWork(unitOfWork);
        }
        function completeUnitOfWork(unitOfWork) {
          var completedWork = unitOfWork;
          do {
            if (0 !== (completedWork.flags & 32768)) {
              unwindUnitOfWork(
                completedWork,
                workInProgressRootDidSkipSuspendedSiblings
              );
              return;
            }
            var current3 = completedWork.alternate;
            unitOfWork = completedWork.return;
            startProfilerTimer(completedWork);
            current3 = runWithFiberInDEV(
              completedWork,
              completeWork,
              current3,
              completedWork,
              entangledRenderLanes
            );
            (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
            if (null !== current3) {
              workInProgress = current3;
              return;
            }
            completedWork = completedWork.sibling;
            if (null !== completedWork) {
              workInProgress = completedWork;
              return;
            }
            workInProgress = completedWork = unitOfWork;
          } while (null !== completedWork);
          workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
        }
        function unwindUnitOfWork(unitOfWork, skipSiblings) {
          do {
            var next2 = unwindWork(unitOfWork.alternate, unitOfWork);
            if (null !== next2) {
              next2.flags &= 32767;
              workInProgress = next2;
              return;
            }
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
              next2 = unitOfWork.actualDuration;
              for (var child = unitOfWork.child; null !== child; )
                next2 += child.actualDuration, child = child.sibling;
              unitOfWork.actualDuration = next2;
            }
            next2 = unitOfWork.return;
            null !== next2 && (next2.flags |= 32768, next2.subtreeFlags = 0, next2.deletions = null);
            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
              workInProgress = unitOfWork;
              return;
            }
            workInProgress = unitOfWork = next2;
          } while (null !== unitOfWork);
          workInProgressRootExitStatus = RootDidNotComplete;
          workInProgress = null;
        }
        function commitRoot(root2, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
          var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, ReactSharedInternals.T = null, commitRootImpl(
              root2,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              previousUpdateLanePriority,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              suspendedCommitReason,
              completedRenderStartTime,
              completedRenderEndTime
            );
          } finally {
            ReactSharedInternals.T = prevTransition, ReactDOMSharedInternals.p = previousUpdateLanePriority;
          }
        }
        function commitRootImpl(root2, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {
          do
            flushPassiveEffects();
          while (null !== rootWithPendingPassiveEffects);
          ReactStrictModeWarnings.flushLegacyContextWarning();
          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
            throw Error("Should not already be working.");
          var finishedWork = root2.finishedWork;
          didIncludeRenderPhaseUpdate = root2.finishedLanes;
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);
          if (null === finishedWork) return markCommitStopped(), null;
          0 === didIncludeRenderPhaseUpdate && console.error(
            "root.finishedLanes should not be empty during a commit. This is a bug in React."
          );
          root2.finishedWork = null;
          root2.finishedLanes = 0;
          if (finishedWork === root2.current)
            throw Error(
              "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
            );
          root2.callbackNode = null;
          root2.callbackPriority = 0;
          root2.cancelPendingCommit = null;
          var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
          remainingLanes |= concurrentlyUpdatedLanes;
          markRootFinished(
            root2,
            didIncludeRenderPhaseUpdate,
            remainingLanes,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = true, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects(true);
            return null;
          }));
          commitStartTime = now();
          transitions = 0 !== (finishedWork.flags & 15990);
          0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = ReactDOMSharedInternals.p, ReactDOMSharedInternals.p = DiscreteEventPriority, updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root2, finishedWork), commitMutationEffects(
            root2,
            finishedWork,
            didIncludeRenderPhaseUpdate
          ), restoreSelection(selectionInformation, root2.containerInfo), _enabled = !!eventsEnabled, selectionInformation = eventsEnabled = null, root2.current = finishedWork, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(
            didIncludeRenderPhaseUpdate
          ), commitLayoutEffects(finishedWork, root2, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, ReactDOMSharedInternals.p = spawnedLane, ReactSharedInternals.T = transitions) : root2.current = finishedWork;
          (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = false, rootWithPendingPassiveEffects = root2, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root2, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
          remainingLanes = root2.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          transitions || commitDoubleInvokeEffectsInDEV(root2);
          onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);
          isDevToolsPresent && root2.memoizedUpdaters.clear();
          onCommitRoot();
          ensureRootIsScheduled(root2);
          if (null !== recoverableErrors)
            for (renderPriorityLevel = root2.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)
              remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(
                remainingLanes.source,
                renderPriorityLevel,
                remainingLanes.value,
                transitions
              );
          0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
          remainingLanes = root2.pendingLanes;
          0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2)) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0, false);
          markCommitStopped();
          return null;
        }
        function makeErrorInfo(componentStack) {
          componentStack = { componentStack };
          Object.defineProperty(componentStack, "digest", {
            get: function() {
              console.error(
                'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
              );
            }
          });
          return componentStack;
        }
        function releaseRootPooledCache(root2, remainingLanes) {
          0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
        }
        function flushPassiveEffects() {
          if (null !== rootWithPendingPassiveEffects) {
            var root2 = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;
            pendingPassiveEffectsRemainingLanes = 0;
            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
            renderPriority = ReactSharedInternals.T;
            var previousPriority = ReactDOMSharedInternals.p;
            try {
              ReactDOMSharedInternals.p = priority;
              ReactSharedInternals.T = null;
              if (null === rootWithPendingPassiveEffects)
                var JSCompiler_inline_result = false;
              else {
                priority = pendingPassiveTransitions;
                pendingPassiveTransitions = null;
                var root$jscomp$0 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;
                rootWithPendingPassiveEffects = null;
                pendingPassiveEffectsLanes = 0;
                if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
                  throw Error(
                    "Cannot flush passive effects while already rendering."
                  );
                isFlushingPassiveEffects = true;
                didScheduleUpdateDuringPassiveEffects = false;
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
                var prevExecutionContext = executionContext;
                executionContext |= CommitContext;
                commitPassiveUnmountOnFiber(root$jscomp$0.current);
                commitPassiveMountOnFiber(
                  root$jscomp$0,
                  root$jscomp$0.current,
                  lanes,
                  priority
                );
                null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
                commitDoubleInvokeEffectsInDEV(root$jscomp$0);
                executionContext = prevExecutionContext;
                flushSyncWorkAcrossRoots_impl(0, false);
                didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
                didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
                if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
                  try {
                    injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
                  } catch (err) {
                    hasLoggedError || (hasLoggedError = true, console.error(
                      "React instrumentation encountered an error: %s",
                      err
                    ));
                  }
                var stateNode = root$jscomp$0.current.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
                JSCompiler_inline_result = true;
              }
              return JSCompiler_inline_result;
            } finally {
              ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
            }
          }
          return false;
        }
        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
          rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
          null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
        }
        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
          isRunningInsertionEffect = false;
          if (3 === sourceFiber.tag)
            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
          else {
            for (; null !== nearestMountedAncestor; ) {
              if (3 === nearestMountedAncestor.tag) {
                captureCommitPhaseErrorOnRoot(
                  nearestMountedAncestor,
                  sourceFiber,
                  error
                );
                return;
              }
              if (1 === nearestMountedAncestor.tag) {
                var instance = nearestMountedAncestor.stateNode;
                if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
                  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                  error = createClassErrorUpdate(2);
                  instance = enqueueUpdate(nearestMountedAncestor, error, 2);
                  null !== instance && (initializeClassErrorUpdate(
                    error,
                    instance,
                    nearestMountedAncestor,
                    sourceFiber
                  ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
                  return;
                }
              }
              nearestMountedAncestor = nearestMountedAncestor.return;
            }
            console.error(
              "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
              error
            );
          }
        }
        function attachPingListener(root2, wakeable, lanes) {
          var pingCache = root2.pingCache;
          if (null === pingCache) {
            pingCache = root2.pingCache = new PossiblyWeakMap();
            var threadIDs = /* @__PURE__ */ new Set();
            pingCache.set(wakeable, threadIDs);
          } else
            threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
          threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
        }
        function pingSuspendedRoot(root2, wakeable, pingedLanes) {
          var pingCache = root2.pingCache;
          null !== pingCache && pingCache.delete(wakeable);
          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          root2.warmLanes &= ~pingedLanes;
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
            "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
          );
          workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
          ensureRootIsScheduled(root2);
        }
        function retryTimedOutBoundary(boundaryFiber, retryLane) {
          0 === retryLane && (retryLane = claimNextRetryLane());
          boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
          null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
        }
        function retryDehydratedSuspenseBoundary(boundaryFiber) {
          var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function resolveRetryWakeable(boundaryFiber, wakeable) {
          var retryLane = 0;
          switch (boundaryFiber.tag) {
            case 13:
              var retryCache = boundaryFiber.stateNode;
              var suspenseState = boundaryFiber.memoizedState;
              null !== suspenseState && (retryLane = suspenseState.retryLane);
              break;
            case 19:
              retryCache = boundaryFiber.stateNode;
              break;
            case 22:
              retryCache = boundaryFiber.stateNode._retryCache;
              break;
            default:
              throw Error(
                "Pinged unknown suspense boundary type. This is probably a bug in React."
              );
          }
          null !== retryCache && retryCache.delete(wakeable);
          retryTimedOutBoundary(boundaryFiber, retryLane);
        }
        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
          if (0 !== (parentFiber.subtreeFlags & 33562624))
            for (parentFiber = parentFiber.child; null !== parentFiber; ) {
              var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
              isStrictModeFiber = isInStrictMode || isStrictModeFiber;
              22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber,
                (fiber.mode & NoStrictPassiveEffectsMode) === NoMode
              ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
                root2,
                fiber,
                isStrictModeFiber
              ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
                fiber,
                doubleInvokeEffectsOnFiber,
                root2,
                fiber
              ) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(
                fiber,
                recursivelyTraverseAndDoubleInvokeEffectsInDEV,
                root2,
                fiber,
                isStrictModeFiber
              ));
              parentFiber = parentFiber.sibling;
            }
        }
        function doubleInvokeEffectsOnFiber(root2, fiber) {
          var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : true;
          setIsStrictModeForDevtools(true);
          try {
            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root2, fiber, 0, null, false);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        function commitDoubleInvokeEffectsInDEV(root2) {
          var doubleInvokeEffects = true;
          root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
          recursivelyTraverseAndDoubleInvokeEffectsInDEV(
            root2,
            root2.current,
            doubleInvokeEffects
          );
        }
        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
          if ((executionContext & RenderContext) === NoContext) {
            var tag = fiber.tag;
            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
              tag = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (null !== didWarnStateUpdateForNotYetMountedComponent) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
                didWarnStateUpdateForNotYetMountedComponent.add(tag);
              } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
              runWithFiberInDEV(fiber, function() {
                console.error(
                  "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
                );
              });
            }
          }
        }
        function restorePendingUpdaters(root2, lanes) {
          isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
            addFiberToLanesMap(root2, schedulingFiber, lanes);
          });
        }
        function scheduleCallback$1(priorityLevel, callback2) {
          var actQueue = ReactSharedInternals.actQueue;
          return null !== actQueue ? (actQueue.push(callback2), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback2);
        }
        function warnIfUpdatesNotWrappedWithActDEV(fiber) {
          isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
            console.error(
              "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
              getComponentNameFromFiber(fiber)
            );
          });
        }
        function ensureRootIsScheduled(root2) {
          root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
          mightHavePendingSyncWork = true;
          null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateTask(processRootScheduleInMicrotask));
        }
        function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
          if (!isFlushingWork && mightHavePendingSyncWork) {
            isFlushingWork = true;
            do {
              var didPerformSomeWork = false;
              for (var root2 = firstScheduledRoot; null !== root2; ) {
                if (!onlyLegacy)
                  if (0 !== syncTransitionLanes) {
                    var pendingLanes = root2.pendingLanes;
                    if (0 === pendingLanes) var nextLanes = 0;
                    else {
                      var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
                      nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                      nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                      nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;
                    }
                    0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                  } else
                    nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
                      root2,
                      root2 === workInProgressRoot ? nextLanes : 0
                    ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
                root2 = root2.next;
              }
            } while (didPerformSomeWork);
            isFlushingWork = false;
          }
        }
        function processRootScheduleInMicrotask() {
          mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
          var syncTransitionLanes = 0;
          0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
          for (var currentTime = now$1(), prev2 = null, root2 = firstScheduledRoot; null !== root2; ) {
            var next2 = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
            if (0 === nextLanes)
              root2.next = null, null === prev2 ? firstScheduledRoot = next2 : prev2.next = next2, null === next2 && (lastScheduledRoot = prev2);
            else if (prev2 = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
              mightHavePendingSyncWork = true;
            root2 = next2;
          }
          flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
        }
        function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
          for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
            if (-1 === expirationTime) {
              if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
                expirationTimes[index] = computeExpirationTime(lane, currentTime);
            } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
            lanes &= ~lane;
          }
          currentTime = workInProgressRoot;
          suspendedLanes = workInProgressRootRenderLanes;
          suspendedLanes = getNextLanes(
            root2,
            root2 === currentTime ? suspendedLanes : 0
          );
          pingedLanes = root2.callbackNode;
          if (0 === suspendedLanes || root2 === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root2.cancelPendingCommit)
            return null !== pingedLanes && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
          if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
            currentTime = suspendedLanes & -suspendedLanes;
            if (currentTime !== root2.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
              cancelCallback(pingedLanes);
            else return currentTime;
            switch (lanesToEventPriority(suspendedLanes)) {
              case DiscreteEventPriority:
              case ContinuousEventPriority:
                suspendedLanes = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                suspendedLanes = NormalPriority$1;
                break;
              case IdleEventPriority:
                suspendedLanes = IdlePriority;
                break;
              default:
                suspendedLanes = NormalPriority$1;
            }
            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
            root2.callbackPriority = currentTime;
            root2.callbackNode = suspendedLanes;
            return currentTime;
          }
          null !== pingedLanes && cancelCallback(pingedLanes);
          root2.callbackPriority = 2;
          root2.callbackNode = null;
          return 2;
        }
        function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
          nestedUpdateScheduled = currentUpdateIsNested = false;
          var originalCallbackNode = root2.callbackNode;
          if (flushPassiveEffects() && root2.callbackNode !== originalCallbackNode)
            return null;
          var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
          workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
            root2,
            root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0
          );
          if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
          performWorkOnRoot(
            root2,
            workInProgressRootRenderLanes$jscomp$0,
            didTimeout
          );
          scheduleTaskForRootDuringMicrotask(root2, now$1());
          return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
        }
        function performSyncWorkOnRoot(root2, lanes) {
          if (flushPassiveEffects()) return null;
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
          performWorkOnRoot(root2, lanes, true);
        }
        function cancelCallback(callbackNode) {
          callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
        }
        function scheduleImmediateTask(cb) {
          null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
            cb();
            return null;
          });
          scheduleMicrotask(function() {
            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();
          });
        }
        function requestTransitionLane() {
          0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
          return currentEventTransitionLane;
        }
        function coerceFormActionProp(actionProp) {
          if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
            return null;
          if ("function" === typeof actionProp) return actionProp;
          checkAttributeStringCoercion(actionProp, "action");
          return sanitizeURL("" + actionProp);
        }
        function createFormDataWithSubmitter(form, submitter) {
          var temp = submitter.ownerDocument.createElement("input");
          temp.name = submitter.name;
          temp.value = submitter.value;
          form.id && temp.setAttribute("form", form.id);
          submitter.parentNode.insertBefore(temp, submitter);
          form = new FormData(form);
          temp.parentNode.removeChild(temp);
          return form;
        }
        function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
          if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
            var action = coerceFormActionProp(
              (nativeEventTarget[internalPropsKey] || null).action
            ), submitter = nativeEvent.submitter;
            submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
            var event = new SyntheticEvent(
              "action",
              "action",
              null,
              nativeEvent,
              nativeEventTarget
            );
            dispatchQueue.push({
              event,
              listeners: [
                {
                  instance: null,
                  listener: function() {
                    if (nativeEvent.defaultPrevented) {
                      if (0 !== currentEventTransitionLane) {
                        var formData = submitter ? createFormDataWithSubmitter(
                          nativeEventTarget,
                          submitter
                        ) : new FormData(nativeEventTarget), pendingState = {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        };
                        Object.freeze(pendingState);
                        startHostTransition(
                          maybeTargetInst,
                          pendingState,
                          null,
                          formData
                        );
                      }
                    } else
                      "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
                        nativeEventTarget,
                        submitter
                      ) : new FormData(nativeEventTarget), pendingState = {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      }, Object.freeze(pendingState), startHostTransition(
                        maybeTargetInst,
                        pendingState,
                        action,
                        formData
                      ));
                  },
                  currentTarget: nativeEventTarget
                }
              ]
            });
          }
        }
        function processDispatchQueue(dispatchQueue, eventSystemFlags) {
          eventSystemFlags = 0 !== (eventSystemFlags & 4);
          for (var i = 0; i < dispatchQueue.length; i++) {
            var _dispatchQueue$i = dispatchQueue[i];
            a: {
              var previousInstance = void 0, event = _dispatchQueue$i.event;
              _dispatchQueue$i = _dispatchQueue$i.listeners;
              if (eventSystemFlags)
                for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                  var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  previousInstance = event;
                  previousInstance.currentTarget = currentTarget;
                  try {
                    _dispatchListeners$i(previousInstance);
                  } catch (error) {
                    reportGlobalError(error);
                  }
                  previousInstance.currentTarget = null;
                  previousInstance = instance;
                }
              else
                for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                  _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                  instance = _dispatchListeners$i.instance;
                  currentTarget = _dispatchListeners$i.currentTarget;
                  _dispatchListeners$i = _dispatchListeners$i.listener;
                  if (instance !== previousInstance && event.isPropagationStopped())
                    break a;
                  previousInstance = event;
                  previousInstance.currentTarget = currentTarget;
                  try {
                    _dispatchListeners$i(previousInstance);
                  } catch (error) {
                    reportGlobalError(error);
                  }
                  previousInstance.currentTarget = null;
                  previousInstance = instance;
                }
            }
          }
        }
        function listenToNonDelegatedEvent(domEventName, targetElement) {
          nonDelegatedEvents.has(domEventName) || console.error(
            'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
            domEventName
          );
          var listenerSet = targetElement[internalEventHandlersKey];
          void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
          var listenerSetKey = domEventName + "__bubble";
          listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
        }
        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
          nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
            'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
            domEventName
          );
          var eventSystemFlags = 0;
          isCapturePhaseListener && (eventSystemFlags |= 4);
          addTrappedEventListener(
            target,
            domEventName,
            eventSystemFlags,
            isCapturePhaseListener
          );
        }
        function listenToAllSupportedEvents(rootContainerElement) {
          if (!rootContainerElement[listeningMarker]) {
            rootContainerElement[listeningMarker] = true;
            allNativeEvents.forEach(function(domEventName) {
              "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
            });
            var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
            null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
          }
        }
        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
          switch (getEventPriority(domEventName)) {
            case DiscreteEventPriority:
              var listenerWrapper = dispatchDiscreteEvent;
              break;
            case ContinuousEventPriority:
              listenerWrapper = dispatchContinuousEvent;
              break;
            default:
              listenerWrapper = dispatchEvent;
          }
          eventSystemFlags = listenerWrapper.bind(
            null,
            domEventName,
            eventSystemFlags,
            targetContainer
          );
          listenerWrapper = void 0;
          !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
          isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            capture: true,
            passive: listenerWrapper
          }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
            passive: listenerWrapper
          }) : targetContainer.addEventListener(
            domEventName,
            eventSystemFlags,
            false
          );
        }
        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
          var ancestorInst = targetInst$jscomp$0;
          if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
            a: for (; ; ) {
              if (null === targetInst$jscomp$0) return;
              var nodeTag = targetInst$jscomp$0.tag;
              if (3 === nodeTag || 4 === nodeTag) {
                var container = targetInst$jscomp$0.stateNode.containerInfo;
                if (container === targetContainer || 8 === container.nodeType && container.parentNode === targetContainer)
                  break;
                if (4 === nodeTag)
                  for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                    var grandTag = nodeTag.tag;
                    if (3 === grandTag || 4 === grandTag) {
                      if (grandTag = nodeTag.stateNode.containerInfo, grandTag === targetContainer || 8 === grandTag.nodeType && grandTag.parentNode === targetContainer)
                        return;
                    }
                    nodeTag = nodeTag.return;
                  }
                for (; null !== container; ) {
                  nodeTag = getClosestInstanceFromNode(container);
                  if (null === nodeTag) return;
                  grandTag = nodeTag.tag;
                  if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                    targetInst$jscomp$0 = ancestorInst = nodeTag;
                    continue a;
                  }
                  container = container.parentNode;
                }
              }
              targetInst$jscomp$0 = targetInst$jscomp$0.return;
            }
          batchedUpdates$1(function() {
            var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
            a: {
              var reactName = topLevelEventsToReactNames.get(domEventName);
              if (void 0 !== reactName) {
                var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
                switch (domEventName) {
                  case "keypress":
                    if (0 === getEventCharCode(nativeEvent)) break a;
                  case "keydown":
                  case "keyup":
                    SyntheticEventCtor = SyntheticKeyboardEvent;
                    break;
                  case "focusin":
                    reactEventType = "focus";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "focusout":
                    reactEventType = "blur";
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "beforeblur":
                  case "afterblur":
                    SyntheticEventCtor = SyntheticFocusEvent;
                    break;
                  case "click":
                    if (2 === nativeEvent.button) break a;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                    SyntheticEventCtor = SyntheticMouseEvent;
                    break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                    SyntheticEventCtor = SyntheticDragEvent;
                    break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                    SyntheticEventCtor = SyntheticTouchEvent;
                    break;
                  case ANIMATION_END:
                  case ANIMATION_ITERATION:
                  case ANIMATION_START:
                    SyntheticEventCtor = SyntheticAnimationEvent;
                    break;
                  case TRANSITION_END:
                    SyntheticEventCtor = SyntheticTransitionEvent;
                    break;
                  case "scroll":
                  case "scrollend":
                    SyntheticEventCtor = SyntheticUIEvent;
                    break;
                  case "wheel":
                    SyntheticEventCtor = SyntheticWheelEvent;
                    break;
                  case "copy":
                  case "cut":
                  case "paste":
                    SyntheticEventCtor = SyntheticClipboardEvent;
                    break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                    SyntheticEventCtor = SyntheticPointerEvent;
                    break;
                  case "toggle":
                  case "beforetoggle":
                    SyntheticEventCtor = SyntheticToggleEvent;
                }
                var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
                inCapturePhase = [];
                for (var instance = targetInst, lastHostComponent; null !== instance; ) {
                  var _instance2 = instance;
                  lastHostComponent = _instance2.stateNode;
                  _instance2 = _instance2.tag;
                  5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
                    createDispatchListener(
                      instance,
                      _instance2,
                      lastHostComponent
                    )
                  ));
                  if (accumulateTargetOnly) break;
                  instance = instance.return;
                }
                0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                  reactName,
                  reactEventType,
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: reactName,
                  listeners: inCapturePhase
                }));
              }
            }
            if (0 === (eventSystemFlags & 7)) {
              a: {
                reactName = "mouseover" === domEventName || "pointerover" === domEventName;
                SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
                if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                  break a;
                if (SyntheticEventCtor || reactName) {
                  reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                  if (SyntheticEventCtor) {
                    if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                      reactEventType = null;
                  } else SyntheticEventCtor = null, reactEventType = targetInst;
                  if (SyntheticEventCtor !== reactEventType) {
                    inCapturePhase = SyntheticMouseEvent;
                    _instance2 = "onMouseLeave";
                    reactEventName = "onMouseEnter";
                    instance = "mouse";
                    if ("pointerout" === domEventName || "pointerover" === domEventName)
                      inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                    accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                    lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                    reactName = new inCapturePhase(
                      _instance2,
                      instance + "leave",
                      SyntheticEventCtor,
                      nativeEvent,
                      nativeEventTarget
                    );
                    reactName.target = accumulateTargetOnly;
                    reactName.relatedTarget = lastHostComponent;
                    _instance2 = null;
                    getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                      reactEventName,
                      instance + "enter",
                      reactEventType,
                      nativeEvent,
                      nativeEventTarget
                    ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
                    accumulateTargetOnly = _instance2;
                    if (SyntheticEventCtor && reactEventType)
                      b: {
                        inCapturePhase = SyntheticEventCtor;
                        reactEventName = reactEventType;
                        instance = 0;
                        for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                          instance++;
                        lastHostComponent = 0;
                        for (_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2))
                          lastHostComponent++;
                        for (; 0 < instance - lastHostComponent; )
                          inCapturePhase = getParent(inCapturePhase), instance--;
                        for (; 0 < lastHostComponent - instance; )
                          reactEventName = getParent(reactEventName), lastHostComponent--;
                        for (; instance--; ) {
                          if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                            break b;
                          inCapturePhase = getParent(inCapturePhase);
                          reactEventName = getParent(reactEventName);
                        }
                        inCapturePhase = null;
                      }
                    else inCapturePhase = null;
                    null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      reactName,
                      SyntheticEventCtor,
                      inCapturePhase,
                      false
                    );
                    null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                      dispatchQueue,
                      accumulateTargetOnly,
                      reactEventType,
                      inCapturePhase,
                      true
                    );
                  }
                }
              }
              a: {
                reactName = targetInst ? getNodeFromInstance(targetInst) : window;
                SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
                if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                  var getTargetInstFunc = getTargetInstForChangeEvent;
                else if (isTextInputElement(reactName))
                  if (isInputEventSupported)
                    getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                  else {
                    getTargetInstFunc = getTargetInstForInputEventPolyfill;
                    var handleEventFunc = handleEventsForInputEventPolyfill;
                  }
                else
                  SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
                if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                  createAndAccumulateChangeEvent(
                    dispatchQueue,
                    getTargetInstFunc,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break a;
                }
                handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
                "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
              }
              handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
              switch (domEventName) {
                case "focusin":
                  if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                    activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                  break;
                case "focusout":
                  lastSelection = activeElementInst = activeElement = null;
                  break;
                case "mousedown":
                  mouseDown = true;
                  break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                  mouseDown = false;
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
                  break;
                case "selectionchange":
                  if (skipSelectionChangeEvent) break;
                case "keydown":
                case "keyup":
                  constructSelectEvent(
                    dispatchQueue,
                    nativeEvent,
                    nativeEventTarget
                  );
              }
              var fallbackData;
              if (canUseCompositionEvent)
                b: {
                  switch (domEventName) {
                    case "compositionstart":
                      var eventType = "onCompositionStart";
                      break b;
                    case "compositionend":
                      eventType = "onCompositionEnd";
                      break b;
                    case "compositionupdate":
                      eventType = "onCompositionUpdate";
                      break b;
                  }
                  eventType = void 0;
                }
              else
                isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
              eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
                targetInst,
                eventType
              ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
                eventType,
                domEventName,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: eventType,
                listeners: handleEventFunc
              }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
              if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
                eventType = accumulateTwoPhaseListeners(
                  targetInst,
                  "onBeforeInput"
                ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
                  "onBeforeInput",
                  "beforeinput",
                  null,
                  nativeEvent,
                  nativeEventTarget
                ), dispatchQueue.push({
                  event: handleEventFunc,
                  listeners: eventType
                }), handleEventFunc.data = fallbackData);
              extractEvents$1(
                dispatchQueue,
                domEventName,
                targetInst,
                nativeEvent,
                nativeEventTarget
              );
            }
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          });
        }
        function createDispatchListener(instance, listener3, currentTarget) {
          return {
            instance,
            listener: listener3,
            currentTarget
          };
        }
        function accumulateTwoPhaseListeners(targetFiber, reactName) {
          for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
            var _instance3 = targetFiber, stateNode = _instance3.stateNode;
            _instance3 = _instance3.tag;
            5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
              createDispatchListener(targetFiber, _instance3, stateNode)
            ));
            targetFiber = targetFiber.return;
          }
          return listeners;
        }
        function getParent(inst) {
          if (null === inst) return null;
          do
            inst = inst.return;
          while (inst && 5 !== inst.tag && 27 !== inst.tag);
          return inst ? inst : null;
        }
        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
          for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
            var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
            _instance4 = _instance4.tag;
            if (null !== alternate && alternate === common) break;
            5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
            target = target.return;
          }
          0 !== listeners.length && dispatchQueue.push({ event, listeners });
        }
        function validatePropertiesInDevelopment(type, props) {
          validateProperties$2(type, props);
          "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
            "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
            type
          ) : console.error(
            "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
            type
          ));
          var eventRegistry = {
            registrationNameDependencies,
            possibleRegistrationNames
          };
          isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
          props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
            "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
          );
        }
        function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
          serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
        }
        function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
          attributeNames.forEach(function(attributeName) {
            serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
          });
        }
        function warnForInvalidEventListener(registrationName, listener3) {
          false === listener3 ? console.error(
            "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
            registrationName,
            registrationName,
            registrationName
          ) : console.error(
            "Expected `%s` listener to be a function, instead got a value of `%s` type.",
            registrationName,
            typeof listener3
          );
        }
        function normalizeHTML(parent, html) {
          parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
            parent.namespaceURI,
            parent.tagName
          ) : parent.ownerDocument.createElement(parent.tagName);
          parent.innerHTML = html;
          return parent.innerHTML;
        }
        function normalizeMarkupForTextOrAttribute(markup) {
          willCoercionThrow(markup) && (console.error(
            "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
            typeName(markup)
          ), testStringCoercion(markup));
          return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
        }
        function checkForUnmatchedText(serverText, clientText) {
          clientText = normalizeMarkupForTextOrAttribute(clientText);
          return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
        }
        function noop$12() {
        }
        function setProp(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "children":
              if ("string" === typeof value)
                validateTextNesting(value, tag), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
              else if ("number" === typeof value || "bigint" === typeof value)
                validateTextNesting("" + value, tag), "body" !== tag && setTextContent(domElement, "" + value);
              break;
            case "className":
              setValueForKnownAttribute(domElement, "class", value);
              break;
            case "tabIndex":
              setValueForKnownAttribute(domElement, "tabindex", value);
              break;
            case "dir":
            case "role":
            case "viewBox":
            case "width":
            case "height":
              setValueForKnownAttribute(domElement, key, value);
              break;
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "data":
              if ("object" !== tag) {
                setValueForKnownAttribute(domElement, "data", value);
                break;
              }
            case "src":
            case "href":
              if ("" === value && ("a" !== tag || "href" !== key)) {
                "src" === key ? console.error(
                  'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                ) : console.error(
                  'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                  key,
                  key
                );
                domElement.removeAttribute(key);
                break;
              }
              if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "action":
            case "formAction":
              null != value && ("form" === tag ? "formAction" === key ? console.error(
                "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
              ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
              )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
              ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
                "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
              ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
                'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
              )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
                "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
              )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
                "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
              ))) : (didWarnFormActionType = true, console.error(
                'A button can only specify a formAction along with type="submit" or no type.'
              )) : (didWarnFormActionType = true, console.error(
                'An input can only specify a formAction along with type="submit" or type="image".'
              )) : "action" === key ? console.error(
                "You can only pass the action prop to <form>."
              ) : console.error(
                "You can only pass the formAction prop to <input> or <button>."
              ));
              if ("function" === typeof value) {
                domElement.setAttribute(
                  key,
                  "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
                );
                break;
              } else
                "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                  domElement,
                  tag,
                  "formEncType",
                  props.formEncType,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formMethod",
                  props.formMethod,
                  props,
                  null
                ), setProp(
                  domElement,
                  tag,
                  "formTarget",
                  props.formTarget,
                  props,
                  null
                )) : (setProp(
                  domElement,
                  tag,
                  "encType",
                  props.encType,
                  props,
                  null
                ), setProp(domElement, tag, "method", props.method, props, null), setProp(
                  domElement,
                  tag,
                  "target",
                  props.target,
                  props,
                  null
                )));
              if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
                domElement.removeAttribute(key);
                break;
              }
              checkAttributeStringCoercion(value, key);
              value = sanitizeURL("" + value);
              domElement.setAttribute(key, value);
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$12);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "multiple":
              domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "muted":
              domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "defaultValue":
            case "defaultChecked":
            case "innerHTML":
            case "ref":
              break;
            case "autoFocus":
              break;
            case "xlinkHref":
              if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
                domElement.removeAttribute("xlink:href");
                break;
              }
              checkAttributeStringCoercion(value, key);
              key = sanitizeURL("" + value);
              domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
              break;
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
              null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
              break;
            case "inert":
              "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
                "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                key
              ));
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
              value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
              break;
            case "capture":
            case "download":
              true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "cols":
            case "rows":
            case "size":
            case "span":
              null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
              break;
            case "rowSpan":
            case "start":
              null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
              break;
            case "popover":
              listenToNonDelegatedEvent("beforetoggle", domElement);
              listenToNonDelegatedEvent("toggle", domElement);
              setValueForAttribute(domElement, "popover", value);
              break;
            case "xlinkActuate":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:actuate",
                value
              );
              break;
            case "xlinkArcrole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:arcrole",
                value
              );
              break;
            case "xlinkRole":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:role",
                value
              );
              break;
            case "xlinkShow":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:show",
                value
              );
              break;
            case "xlinkTitle":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:title",
                value
              );
              break;
            case "xlinkType":
              setValueForNamespacedAttribute(
                domElement,
                xlinkNamespace,
                "xlink:type",
                value
              );
              break;
            case "xmlBase":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:base",
                value
              );
              break;
            case "xmlLang":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:lang",
                value
              );
              break;
            case "xmlSpace":
              setValueForNamespacedAttribute(
                domElement,
                xmlNamespace,
                "xml:space",
                value
              );
              break;
            case "is":
              null != prevValue && console.error(
                'Cannot update the "is" prop after it has been initialized.'
              );
              setValueForAttribute(domElement, "is", value);
              break;
            case "innerText":
            case "textContent":
              break;
            case "popoverTarget":
              didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
                "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
                value
              ));
            default:
              !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
          }
        }
        function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
          switch (key) {
            case "style":
              setValueForStyles(domElement, value, prevValue);
              break;
            case "dangerouslySetInnerHTML":
              if (null != value) {
                if ("object" !== typeof value || !("__html" in value))
                  throw Error(
                    "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
                  );
                key = value.__html;
                if (null != key) {
                  if (null != props.children)
                    throw Error(
                      "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
                    );
                  domElement.innerHTML = key;
                }
              }
              break;
            case "children":
              "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
              break;
            case "onScroll":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
              break;
            case "onScrollEnd":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
              break;
            case "onClick":
              null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$12);
              break;
            case "suppressContentEditableWarning":
            case "suppressHydrationWarning":
            case "innerHTML":
            case "ref":
              break;
            case "innerText":
            case "textContent":
              break;
            default:
              if (registrationNameDependencies.hasOwnProperty(key))
                null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
              else
                a: {
                  if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                    "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                    domElement.addEventListener(tag, value, props);
                    break a;
                  }
                  key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
                }
          }
        }
        function setInitialProperties(domElement, tag, props) {
          validatePropertiesInDevelopment(tag, props);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "img":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              var hasSrc = false, hasSrcSet = false, propKey;
              for (propKey in props)
                if (props.hasOwnProperty(propKey)) {
                  var propValue = props[propKey];
                  if (null != propValue)
                    switch (propKey) {
                      case "src":
                        hasSrc = true;
                        break;
                      case "srcSet":
                        hasSrcSet = true;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      default:
                        setProp(domElement, tag, propKey, propValue, props, null);
                    }
                }
              hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
              hasSrc && setProp(domElement, tag, "src", props.src, props, null);
              return;
            case "input":
              checkControlledValueProps("input", props);
              listenToNonDelegatedEvent("invalid", domElement);
              var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
              for (hasSrc in props)
                if (props.hasOwnProperty(hasSrc)) {
                  var _propValue = props[hasSrc];
                  if (null != _propValue)
                    switch (hasSrc) {
                      case "name":
                        hasSrcSet = _propValue;
                        break;
                      case "type":
                        propValue = _propValue;
                        break;
                      case "checked":
                        checked = _propValue;
                        break;
                      case "defaultChecked":
                        defaultChecked = _propValue;
                        break;
                      case "value":
                        propKey = _propValue;
                        break;
                      case "defaultValue":
                        defaultValue = _propValue;
                        break;
                      case "children":
                      case "dangerouslySetInnerHTML":
                        if (null != _propValue)
                          throw Error(
                            tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                          );
                        break;
                      default:
                        setProp(domElement, tag, hasSrc, _propValue, props, null);
                    }
                }
              validateInputProps(domElement, props);
              initInput(
                domElement,
                propKey,
                defaultValue,
                checked,
                defaultChecked,
                propValue,
                hasSrcSet,
                false
              );
              track(domElement);
              return;
            case "select":
              checkControlledValueProps("select", props);
              listenToNonDelegatedEvent("invalid", domElement);
              hasSrc = propValue = propKey = null;
              for (hasSrcSet in props)
                if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                  switch (hasSrcSet) {
                    case "value":
                      propKey = defaultValue;
                      break;
                    case "defaultValue":
                      propValue = defaultValue;
                      break;
                    case "multiple":
                      hasSrc = defaultValue;
                    default:
                      setProp(
                        domElement,
                        tag,
                        hasSrcSet,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateSelectProps(domElement, props);
              tag = propKey;
              props = propValue;
              domElement.multiple = !!hasSrc;
              null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
              return;
            case "textarea":
              checkControlledValueProps("textarea", props);
              listenToNonDelegatedEvent("invalid", domElement);
              propKey = hasSrcSet = hasSrc = null;
              for (propValue in props)
                if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                  switch (propValue) {
                    case "value":
                      hasSrc = defaultValue;
                      break;
                    case "defaultValue":
                      hasSrcSet = defaultValue;
                      break;
                    case "children":
                      propKey = defaultValue;
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != defaultValue)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        propValue,
                        defaultValue,
                        props,
                        null
                      );
                  }
              validateTextareaProps(domElement, props);
              initTextarea(domElement, hasSrc, hasSrcSet, propKey);
              track(domElement);
              return;
            case "option":
              validateOptionProps(domElement, props);
              for (checked in props)
                if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                  switch (checked) {
                    case "selected":
                      domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                      break;
                    default:
                      setProp(domElement, tag, checked, hasSrc, props, null);
                  }
              return;
            case "dialog":
              listenToNonDelegatedEvent("cancel", domElement);
              listenToNonDelegatedEvent("close", domElement);
              break;
            case "iframe":
            case "object":
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "video":
            case "audio":
              for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
                listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
              break;
            case "image":
              listenToNonDelegatedEvent("error", domElement);
              listenToNonDelegatedEvent("load", domElement);
              break;
            case "details":
              listenToNonDelegatedEvent("toggle", domElement);
              break;
            case "embed":
            case "source":
            case "link":
              listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
            case "area":
            case "base":
            case "br":
            case "col":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "track":
            case "wbr":
            case "menuitem":
              for (defaultChecked in props)
                if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                  switch (defaultChecked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(
                        tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                      );
                    default:
                      setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (_propValue in props)
                  props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propValue,
                    hasSrc,
                    props,
                    void 0
                  ));
                return;
              }
          }
          for (defaultValue in props)
            props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
        }
        function updateProperties(domElement, tag, lastProps, nextProps) {
          validatePropertiesInDevelopment(tag, nextProps);
          switch (tag) {
            case "div":
            case "span":
            case "svg":
            case "path":
            case "a":
            case "g":
            case "p":
            case "li":
              break;
            case "input":
              var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
              for (propKey in lastProps) {
                var lastProp = lastProps[propKey];
                if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                  switch (propKey) {
                    case "checked":
                      break;
                    case "value":
                      break;
                    case "defaultValue":
                      lastDefaultValue = lastProp;
                    default:
                      nextProps.hasOwnProperty(propKey) || setProp(
                        domElement,
                        tag,
                        propKey,
                        null,
                        nextProps,
                        lastProp
                      );
                  }
              }
              for (var _propKey8 in nextProps) {
                var propKey = nextProps[_propKey8];
                lastProp = lastProps[_propKey8];
                if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
                  switch (_propKey8) {
                    case "type":
                      type = propKey;
                      break;
                    case "name":
                      name = propKey;
                      break;
                    case "checked":
                      checked = propKey;
                      break;
                    case "defaultChecked":
                      defaultChecked = propKey;
                      break;
                    case "value":
                      value = propKey;
                      break;
                    case "defaultValue":
                      defaultValue = propKey;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propKey)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      propKey !== lastProp && setProp(
                        domElement,
                        tag,
                        _propKey8,
                        propKey,
                        nextProps,
                        lastProp
                      );
                  }
              }
              tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
              nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
              tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
                "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnUncontrolledToControlled = true);
              !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
                "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
              ), didWarnControlledToUncontrolled = true);
              updateInput(
                domElement,
                value,
                defaultValue,
                lastDefaultValue,
                checked,
                defaultChecked,
                type,
                name
              );
              return;
            case "select":
              propKey = value = defaultValue = _propKey8 = null;
              for (type in lastProps)
                if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                  switch (type) {
                    case "value":
                      break;
                    case "multiple":
                      propKey = lastDefaultValue;
                    default:
                      nextProps.hasOwnProperty(type) || setProp(
                        domElement,
                        tag,
                        type,
                        null,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              for (name in nextProps)
                if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                  switch (name) {
                    case "value":
                      _propKey8 = type;
                      break;
                    case "defaultValue":
                      defaultValue = type;
                      break;
                    case "multiple":
                      value = type;
                    default:
                      type !== lastDefaultValue && setProp(
                        domElement,
                        tag,
                        name,
                        type,
                        nextProps,
                        lastDefaultValue
                      );
                  }
              nextProps = defaultValue;
              tag = value;
              lastProps = propKey;
              null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
              return;
            case "textarea":
              propKey = _propKey8 = null;
              for (defaultValue in lastProps)
                if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                  switch (defaultValue) {
                    case "value":
                      break;
                    case "children":
                      break;
                    default:
                      setProp(domElement, tag, defaultValue, null, nextProps, name);
                  }
              for (value in nextProps)
                if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                  switch (value) {
                    case "value":
                      _propKey8 = name;
                      break;
                    case "defaultValue":
                      propKey = name;
                      break;
                    case "children":
                      break;
                    case "dangerouslySetInnerHTML":
                      if (null != name)
                        throw Error(
                          "`dangerouslySetInnerHTML` does not make sense on <textarea>."
                        );
                      break;
                    default:
                      name !== type && setProp(domElement, tag, value, name, nextProps, type);
                  }
              updateTextarea(domElement, _propKey8, propKey);
              return;
            case "option":
              for (var _propKey13 in lastProps)
                if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
                  switch (_propKey13) {
                    case "selected":
                      domElement.selected = false;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        _propKey13,
                        null,
                        nextProps,
                        _propKey8
                      );
                  }
              for (lastDefaultValue in nextProps)
                if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (lastDefaultValue) {
                    case "selected":
                      domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        lastDefaultValue,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            case "img":
            case "link":
            case "area":
            case "base":
            case "br":
            case "col":
            case "embed":
            case "hr":
            case "keygen":
            case "meta":
            case "param":
            case "source":
            case "track":
            case "wbr":
            case "menuitem":
              for (var _propKey15 in lastProps)
                _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
                  domElement,
                  tag,
                  _propKey15,
                  null,
                  nextProps,
                  _propKey8
                );
              for (checked in nextProps)
                if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
                  switch (checked) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != _propKey8)
                        throw Error(
                          tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
                        );
                      break;
                    default:
                      setProp(
                        domElement,
                        tag,
                        checked,
                        _propKey8,
                        nextProps,
                        propKey
                      );
                  }
              return;
            default:
              if (isCustomElement(tag)) {
                for (var _propKey17 in lastProps)
                  _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
                    domElement,
                    tag,
                    _propKey17,
                    void 0,
                    nextProps,
                    _propKey8
                  );
                for (defaultChecked in nextProps)
                  _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
                    domElement,
                    tag,
                    defaultChecked,
                    _propKey8,
                    nextProps,
                    propKey
                  );
                return;
              }
          }
          for (var _propKey19 in lastProps)
            _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
          for (lastProp in nextProps)
            _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
        }
        function getPropNameFromAttributeName(attrName) {
          switch (attrName) {
            case "class":
              return "className";
            case "for":
              return "htmlFor";
            default:
              return attrName;
          }
        }
        function getStylesObjectFromElement(domElement) {
          var serverValueInObjectForm = {};
          domElement = domElement.style;
          for (var i = 0; i < domElement.length; i++) {
            var styleName = domElement[i];
            serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
          }
          return serverValueInObjectForm;
        }
        function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
          if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
            console.error(
              "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
            );
          else if (canDiffStyleForHydrationWarning) {
            var clientValue;
            var delimiter2 = clientValue = "", styleName;
            for (styleName in value$jscomp$0)
              if (value$jscomp$0.hasOwnProperty(styleName)) {
                var value = value$jscomp$0[styleName];
                null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter2 + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter2 + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter2 + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter2 = ";");
              }
            clientValue = clientValue || null;
            value$jscomp$0 = domElement.getAttribute("style");
            value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
          }
        }
        function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement) {
            switch (typeof value) {
              case "function":
              case "symbol":
                return;
            }
            if (!value) return;
          } else
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (value) return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
                break;
              default:
                if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
              default:
                if (isNaN(value)) return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
          extraAttributes.delete(attributeName);
          domElement = domElement.getAttribute(attributeName);
          if (null === domElement)
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
              case "boolean":
                return;
            }
          else if (null != value)
            switch (typeof value) {
              case "function":
              case "symbol":
              case "boolean":
                break;
              default:
                if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
                  return;
            }
          warnForPropDifference(propKey, domElement, value, serverDifferences);
        }
        function diffHydratedProperties(domElement, tag, props, hostContext) {
          for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)
            switch (attributes[i].name.toLowerCase()) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributes.add(attributes[i].name);
            }
          if (isCustomElement(tag))
            for (var propKey in props) {
              if (props.hasOwnProperty(propKey)) {
                var value = props[propKey];
                if (null != value) {
                  if (registrationNameDependencies.hasOwnProperty(propKey))
                    "function" !== typeof value && warnForInvalidEventListener(propKey, value);
                  else if (true !== props.suppressHydrationWarning)
                    switch (propKey) {
                      case "children":
                        "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
                          "children",
                          domElement.textContent,
                          value,
                          serverDifferences
                        );
                        continue;
                      case "suppressContentEditableWarning":
                      case "suppressHydrationWarning":
                      case "defaultValue":
                      case "defaultChecked":
                      case "innerHTML":
                      case "ref":
                        continue;
                      case "dangerouslySetInnerHTML":
                        attributes = domElement.innerHTML;
                        value = value ? value.__html : void 0;
                        null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        ));
                        continue;
                      case "style":
                        extraAttributes.delete(propKey);
                        diffHydratedStyles(domElement, value, serverDifferences);
                        continue;
                      case "offsetParent":
                      case "offsetTop":
                      case "offsetLeft":
                      case "offsetWidth":
                      case "offsetHeight":
                      case "isContentEditable":
                      case "outerText":
                      case "outerHTML":
                        extraAttributes.delete(propKey.toLowerCase());
                        console.error(
                          "Assignment to read-only property will result in a no-op: `%s`",
                          propKey
                        );
                        continue;
                      case "className":
                        extraAttributes.delete("class");
                        attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          "class",
                          value
                        );
                        warnForPropDifference(
                          "className",
                          attributes,
                          value,
                          serverDifferences
                        );
                        continue;
                      default:
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
                          domElement,
                          propKey,
                          value
                        ), warnForPropDifference(
                          propKey,
                          attributes,
                          value,
                          serverDifferences
                        );
                    }
                }
              }
            }
          else
            for (value in props)
              if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
                if (registrationNameDependencies.hasOwnProperty(value))
                  "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
                else if (true !== props.suppressHydrationWarning)
                  switch (value) {
                    case "children":
                      "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
                        "children",
                        domElement.textContent,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "value":
                    case "checked":
                    case "selected":
                    case "defaultValue":
                    case "defaultChecked":
                    case "innerHTML":
                    case "ref":
                      continue;
                    case "dangerouslySetInnerHTML":
                      attributes = domElement.innerHTML;
                      propKey = propKey ? propKey.__html : void 0;
                      null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
                      continue;
                    case "className":
                      hydrateAttribute(
                        domElement,
                        value,
                        "class",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "tabIndex":
                      hydrateAttribute(
                        domElement,
                        value,
                        "tabindex",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "style":
                      extraAttributes.delete(value);
                      diffHydratedStyles(domElement, propKey, serverDifferences);
                      continue;
                    case "multiple":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.multiple,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "muted":
                      extraAttributes.delete(value);
                      warnForPropDifference(
                        value,
                        domElement.muted,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "autoFocus":
                      extraAttributes.delete("autofocus");
                      warnForPropDifference(
                        value,
                        domElement.autofocus,
                        propKey,
                        serverDifferences
                      );
                      continue;
                    case "data":
                      if ("object" !== tag) {
                        extraAttributes.delete(value);
                        attributes = domElement.getAttribute("data");
                        warnForPropDifference(
                          value,
                          attributes,
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                    case "src":
                    case "href":
                      if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
                        "src" === value ? console.error(
                          'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        ) : console.error(
                          'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
                          value,
                          value
                        );
                        hydrateSanitizedAttribute(
                          domElement,
                          value,
                          value,
                          null,
                          extraAttributes,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "action":
                    case "formAction":
                      attributes = domElement.getAttribute(value);
                      if ("function" === typeof propKey) {
                        extraAttributes.delete(value.toLowerCase());
                        "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
                        continue;
                      } else if (attributes === EXPECTED_FORM_ACTION_URL) {
                        extraAttributes.delete(value.toLowerCase());
                        warnForPropDifference(
                          value,
                          "function",
                          propKey,
                          serverDifferences
                        );
                        continue;
                      }
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkHref":
                      hydrateSanitizedAttribute(
                        domElement,
                        value,
                        "xlink:href",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "contentEditable":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "contenteditable",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "spellCheck":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        "spellcheck",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "draggable":
                    case "autoReverse":
                    case "externalResourcesRequired":
                    case "focusable":
                    case "preserveAlpha":
                      hydrateBooleanishAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "allowFullScreen":
                    case "async":
                    case "autoPlay":
                    case "controls":
                    case "default":
                    case "defer":
                    case "disabled":
                    case "disablePictureInPicture":
                    case "disableRemotePlayback":
                    case "formNoValidate":
                    case "hidden":
                    case "loop":
                    case "noModule":
                    case "noValidate":
                    case "open":
                    case "playsInline":
                    case "readOnly":
                    case "required":
                    case "reversed":
                    case "scoped":
                    case "seamless":
                    case "itemScope":
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value.toLowerCase(),
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "capture":
                    case "download":
                      a: {
                        i = domElement;
                        var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                              break a;
                            default:
                              if (false === propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                              break;
                            case "boolean":
                              if (true === propKey && "" === i) break a;
                              break;
                            default:
                              if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "cols":
                    case "rows":
                    case "size":
                    case "span":
                      a: {
                        i = domElement;
                        attributeName = attributes = value;
                        serverDifferences$jscomp$0 = serverDifferences;
                        extraAttributes.delete(attributeName);
                        i = i.getAttribute(attributeName);
                        if (null === i)
                          switch (typeof propKey) {
                            case "undefined":
                            case "function":
                            case "symbol":
                            case "boolean":
                              break a;
                            default:
                              if (isNaN(propKey) || 1 > propKey) break a;
                          }
                        else if (null != propKey)
                          switch (typeof propKey) {
                            case "function":
                            case "symbol":
                            case "boolean":
                              break;
                            default:
                              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey))
                                break a;
                          }
                        warnForPropDifference(
                          attributes,
                          i,
                          propKey,
                          serverDifferences$jscomp$0
                        );
                      }
                      continue;
                    case "rowSpan":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        "rowspan",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "start":
                      hydrateNumericAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xHeight":
                      hydrateAttribute(
                        domElement,
                        value,
                        "x-height",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkActuate":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:actuate",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkArcrole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:arcrole",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkRole":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:role",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkShow":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:show",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkTitle":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:title",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xlinkType":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xlink:type",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlBase":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:base",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlLang":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:lang",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "xmlSpace":
                      hydrateAttribute(
                        domElement,
                        value,
                        "xml:space",
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    case "inert":
                      "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
                        "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
                        value
                      ));
                      hydrateBooleanAttribute(
                        domElement,
                        value,
                        value,
                        propKey,
                        extraAttributes,
                        serverDifferences
                      );
                      continue;
                    default:
                      if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
                        i = getAttributeAlias(value);
                        attributes = false;
                        hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
                          attributeName
                        ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
                        a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
                          if (attributeName.hasAttribute(serverDifferences$jscomp$0))
                            attributeName = attributeName.getAttribute(
                              serverDifferences$jscomp$0
                            ), checkAttributeStringCoercion(
                              i,
                              serverDifferences$jscomp$0
                            ), i = attributeName === "" + i ? i : attributeName;
                          else {
                            switch (typeof i) {
                              case "function":
                              case "symbol":
                                break a;
                              case "boolean":
                                if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
                                  break a;
                            }
                            i = void 0 === i ? void 0 : null;
                          }
                        else i = void 0;
                        attributes || warnForPropDifference(
                          value,
                          i,
                          propKey,
                          serverDifferences
                        );
                      }
                  }
              }
          0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
          return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
        }
        function propNamesListJoin(list, combinator) {
          switch (list.length) {
            case 0:
              return "";
            case 1:
              return list[0];
            case 2:
              return list[0] + " " + combinator + " " + list[1];
            default:
              return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
          }
        }
        function getOwnerDocumentFromRootContainer(rootContainerElement) {
          return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        }
        function getOwnHostContext(namespaceURI) {
          switch (namespaceURI) {
            case SVG_NAMESPACE:
              return HostContextNamespaceSvg;
            case MATH_NAMESPACE:
              return HostContextNamespaceMath;
            default:
              return HostContextNamespaceNone;
          }
        }
        function getChildHostContextProd(parentNamespace, type) {
          if (parentNamespace === HostContextNamespaceNone)
            switch (type) {
              case "svg":
                return HostContextNamespaceSvg;
              case "math":
                return HostContextNamespaceMath;
              default:
                return HostContextNamespaceNone;
            }
          return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
        }
        function shouldSetTextContent(type, props) {
          return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
        }
        function shouldAttemptEagerTransition() {
          var event = window.event;
          if (event && "popstate" === event.type) {
            if (event === currentPopstateTransitionEvent) return false;
            currentPopstateTransitionEvent = event;
            return true;
          }
          currentPopstateTransitionEvent = null;
          return false;
        }
        function handleErrorInNextTick(error) {
          setTimeout(function() {
            throw error;
          });
        }
        function commitMount(domElement, type, newProps) {
          switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps.autoFocus && domElement.focus();
              break;
            case "img":
              newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
          }
        }
        function commitUpdate(domElement, type, oldProps, newProps) {
          updateProperties(domElement, type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        }
        function resetTextContent(domElement) {
          setTextContent(domElement, "");
        }
        function commitTextUpdate(textInstance, oldText, newText) {
          textInstance.nodeValue = newText;
        }
        function removeChild(parentInstance, child) {
          parentInstance.removeChild(child);
        }
        function removeChildFromContainer(container, child) {
          8 === container.nodeType ? container.parentNode.removeChild(child) : container.removeChild(child);
        }
        function clearSuspenseBoundary(parentInstance, suspenseInstance) {
          var node2 = suspenseInstance, depth = 0;
          do {
            var nextNode = node2.nextSibling;
            parentInstance.removeChild(node2);
            if (nextNode && 8 === nextNode.nodeType)
              if (node2 = nextNode.data, node2 === SUSPENSE_END_DATA) {
                if (0 === depth) {
                  parentInstance.removeChild(nextNode);
                  retryIfBlockedOn(suspenseInstance);
                  return;
                }
                depth--;
              } else
                node2 !== SUSPENSE_START_DATA && node2 !== SUSPENSE_PENDING_START_DATA && node2 !== SUSPENSE_FALLBACK_START_DATA || depth++;
            node2 = nextNode;
          } while (node2);
          retryIfBlockedOn(suspenseInstance);
        }
        function hideInstance(instance) {
          instance = instance.style;
          "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
        }
        function hideTextInstance(textInstance) {
          textInstance.nodeValue = "";
        }
        function unhideInstance(instance, props) {
          props = props[STYLE];
          props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
          instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
        }
        function unhideTextInstance(textInstance, text2) {
          textInstance.nodeValue = text2;
        }
        function clearContainerSparingly(container) {
          var nextNode = container.firstChild;
          nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
          for (; nextNode; ) {
            var node2 = nextNode;
            nextNode = nextNode.nextSibling;
            switch (node2.nodeName) {
              case "HTML":
              case "HEAD":
              case "BODY":
                clearContainerSparingly(node2);
                detachDeletedInstance(node2);
                continue;
              case "SCRIPT":
              case "STYLE":
                continue;
              case "LINK":
                if ("stylesheet" === node2.rel.toLowerCase()) continue;
            }
            container.removeChild(node2);
          }
        }
        function canHydrateInstance(instance, type, props, inRootOrSingleton) {
          for (; 1 === instance.nodeType; ) {
            var anyProps = props;
            if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
              if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
                break;
            } else if (!inRootOrSingleton)
              if ("input" === type && "hidden" === instance.type) {
                checkAttributeStringCoercion(anyProps.name, "name");
                var name = null == anyProps.name ? null : "" + anyProps.name;
                if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
                  return instance;
              } else return instance;
            else if (!instance[internalHoistableMarker])
              switch (type) {
                case "meta":
                  if (!instance.hasAttribute("itemprop")) break;
                  return instance;
                case "link":
                  name = instance.getAttribute("rel");
                  if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                    break;
                  else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                    break;
                  return instance;
                case "style":
                  if (instance.hasAttribute("data-precedence")) break;
                  return instance;
                case "script":
                  name = instance.getAttribute("src");
                  if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                    break;
                  return instance;
                default:
                  return instance;
              }
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) break;
          }
          return null;
        }
        function canHydrateTextInstance(instance, text2, inRootOrSingleton) {
          if ("" === text2) return null;
          for (; 3 !== instance.nodeType; ) {
            if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
              return null;
            instance = getNextHydratable(instance.nextSibling);
            if (null === instance) return null;
          }
          return instance;
        }
        function getNextHydratable(node2) {
          for (; null != node2; node2 = node2.nextSibling) {
            var nodeType = node2.nodeType;
            if (1 === nodeType || 3 === nodeType) break;
            if (8 === nodeType) {
              nodeType = node2.data;
              if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
                break;
              if (nodeType === SUSPENSE_END_DATA) return null;
            }
          }
          return node2;
        }
        function describeHydratableInstanceForDevWarnings(instance) {
          if (1 === instance.nodeType) {
            for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
              var attr = attributes[i];
              serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
            }
            return { type: JSCompiler_temp_const, props: serverDifferences };
          }
          return 8 === instance.nodeType ? { type: "Suspense", props: {} } : instance.nodeValue;
        }
        function diffHydratedTextForDevWarnings(textInstance, text2, parentProps) {
          return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text2 ? textInstance = null : (text2 = normalizeMarkupForTextOrAttribute(text2), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text2 ? null : textInstance.nodeValue), textInstance) : null;
        }
        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
          suspenseInstance = suspenseInstance.nextSibling;
          for (var depth = 0; suspenseInstance; ) {
            if (8 === suspenseInstance.nodeType) {
              var data2 = suspenseInstance.data;
              if (data2 === SUSPENSE_END_DATA) {
                if (0 === depth)
                  return getNextHydratable(suspenseInstance.nextSibling);
                depth--;
              } else
                data2 !== SUSPENSE_START_DATA && data2 !== SUSPENSE_FALLBACK_START_DATA && data2 !== SUSPENSE_PENDING_START_DATA || depth++;
            }
            suspenseInstance = suspenseInstance.nextSibling;
          }
          return null;
        }
        function getParentSuspenseInstance(targetInstance) {
          targetInstance = targetInstance.previousSibling;
          for (var depth = 0; targetInstance; ) {
            if (8 === targetInstance.nodeType) {
              var data2 = targetInstance.data;
              if (data2 === SUSPENSE_START_DATA || data2 === SUSPENSE_FALLBACK_START_DATA || data2 === SUSPENSE_PENDING_START_DATA) {
                if (0 === depth) return targetInstance;
                depth--;
              } else data2 === SUSPENSE_END_DATA && depth++;
            }
            targetInstance = targetInstance.previousSibling;
          }
          return null;
        }
        function commitHydratedContainer(container) {
          retryIfBlockedOn(container);
        }
        function commitHydratedSuspenseInstance(suspenseInstance) {
          retryIfBlockedOn(suspenseInstance);
        }
        function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
          validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
          props = getOwnerDocumentFromRootContainer(rootContainerInstance);
          switch (type) {
            case "html":
              type = props.documentElement;
              if (!type)
                throw Error(
                  "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "head":
              type = props.head;
              if (!type)
                throw Error(
                  "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            case "body":
              type = props.body;
              if (!type)
                throw Error(
                  "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
                );
              return type;
            default:
              throw Error(
                "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
        }
        function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
          if (getInstanceFromNode(instance)) {
            var tagName = instance.tagName.toLowerCase();
            console.error(
              "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
              tagName,
              tagName,
              tagName
            );
          }
          switch (type) {
            case "html":
            case "head":
            case "body":
              break;
            default:
              console.error(
                "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
              );
          }
          for (tagName = instance.attributes; tagName.length; )
            instance.removeAttributeNode(tagName[0]);
          setInitialProperties(instance, type, props);
          instance[internalInstanceKey] = internalInstanceHandle;
          instance[internalPropsKey] = props;
        }
        function getHoistableRoot(container) {
          return "function" === typeof container.getRootNode ? container.getRootNode() : container.ownerDocument;
        }
        function preconnectAs(rel, href2, crossOrigin) {
          var ownerDocument = globalDocument;
          if (ownerDocument && "string" === typeof href2 && href2) {
            var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href2);
            limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
            "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
            preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href: href2 }, null === ownerDocument.querySelector(limitedEscapedHref) && (href2 = ownerDocument.createElement("link"), setInitialProperties(href2, "link", rel), markNodeAsHoistable(href2), ownerDocument.head.appendChild(href2)));
          }
        }
        function getResource(type, currentProps, pendingProps, currentResource) {
          var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
          if (!resourceRoot)
            throw Error(
              '"resourceRoot" was expected to exist. This is a bug in React.'
            );
          switch (type) {
            case "meta":
            case "title":
              return null;
            case "style":
              return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "style",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            case "link":
              if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
                type = getStyleKey(pendingProps.href);
                var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
                if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: NotLoaded, preload: null }
                }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
                  getStylesheetSelectorFromKey(type)
                )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
                  var preloadProps = {
                    rel: "preload",
                    as: "style",
                    href: pendingProps.href,
                    crossOrigin: pendingProps.crossOrigin,
                    integrity: pendingProps.integrity,
                    media: pendingProps.media,
                    hrefLang: pendingProps.hrefLang,
                    referrerPolicy: pendingProps.referrerPolicy
                  };
                  preloadPropsMap.set(type, preloadProps);
                  _styles || preloadStylesheet(
                    resourceRoot,
                    type,
                    preloadProps,
                    _resource.state
                  );
                }
                if (currentProps && null === currentResource)
                  throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                    "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                  );
                return _resource;
              }
              if (currentProps && null !== currentResource)
                throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
                  "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
                );
              return null;
            case "script":
              return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
            default:
              throw Error(
                'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
              );
          }
        }
        function describeLinkForResourceErrorDEV(props) {
          var describedProps = 0, description = "<link";
          "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
          "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
          "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
          Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
          return description + " />";
        }
        function getStyleKey(href2) {
          return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href2) + '"';
        }
        function getStylesheetSelectorFromKey(key) {
          return 'link[rel="stylesheet"][' + key + "]";
        }
        function stylesheetPropsFromRawProps(rawProps) {
          return assign3({}, rawProps, {
            "data-precedence": rawProps.precedence,
            precedence: null
          });
        }
        function preloadStylesheet(ownerDocument, key, preloadProps, state) {
          ownerDocument.querySelector(
            'link[rel="preload"][as="style"][' + key + "]"
          ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
            return state.loading |= Loaded;
          }), key.addEventListener("error", function() {
            return state.loading |= Errored;
          }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
        }
        function getScriptKey(src) {
          return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
        }
        function getScriptSelectorFromKey(key) {
          return "script[async]" + key;
        }
        function acquireResource(hoistableRoot, resource, props) {
          resource.count++;
          if (null === resource.instance)
            switch (resource.type) {
              case "style":
                var instance = hoistableRoot.querySelector(
                  'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
                );
                if (instance)
                  return resource.instance = instance, markNodeAsHoistable(instance), instance;
                var styleProps = assign3({}, props, {
                  "data-href": props.href,
                  "data-precedence": props.precedence,
                  href: null,
                  precedence: null
                });
                instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
                markNodeAsHoistable(instance);
                setInitialProperties(instance, "style", styleProps);
                insertStylesheet(instance, props.precedence, hoistableRoot);
                return resource.instance = instance;
              case "stylesheet":
                styleProps = getStyleKey(props.href);
                var _instance = hoistableRoot.querySelector(
                  getStylesheetSelectorFromKey(styleProps)
                );
                if (_instance)
                  return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
                instance = stylesheetPropsFromRawProps(props);
                (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
                _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
                markNodeAsHoistable(_instance);
                var linkInstance = _instance;
                linkInstance._p = new Promise(function(resolve2, reject) {
                  linkInstance.onload = resolve2;
                  linkInstance.onerror = reject;
                });
                setInitialProperties(_instance, "link", instance);
                resource.state.loading |= Inserted;
                insertStylesheet(_instance, props.precedence, hoistableRoot);
                return resource.instance = _instance;
              case "script":
                _instance = getScriptKey(props.src);
                if (styleProps = hoistableRoot.querySelector(
                  getScriptSelectorFromKey(_instance)
                ))
                  return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
                instance = props;
                if (styleProps = preloadPropsMap.get(_instance))
                  instance = assign3({}, props), adoptPreloadPropsForScript(instance, styleProps);
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                styleProps = hoistableRoot.createElement("script");
                markNodeAsHoistable(styleProps);
                setInitialProperties(styleProps, "link", instance);
                hoistableRoot.head.appendChild(styleProps);
                return resource.instance = styleProps;
              case "void":
                return null;
              default:
                throw Error(
                  'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
                );
            }
          else
            "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
          return resource.instance;
        }
        function insertStylesheet(instance, precedence, root2) {
          for (var nodes = root2.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
            var node2 = nodes[i];
            if (node2.dataset.precedence === precedence) prior = node2;
            else if (prior !== last) break;
          }
          prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
        }
        function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
          null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
          null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
          null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
        }
        function adoptPreloadPropsForScript(scriptProps, preloadProps) {
          null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
          null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
          null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
        }
        function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
          if (null === tagCaches) {
            var cache4 = /* @__PURE__ */ new Map();
            var caches = tagCaches = /* @__PURE__ */ new Map();
            caches.set(ownerDocument, cache4);
          } else
            caches = tagCaches, cache4 = caches.get(ownerDocument), cache4 || (cache4 = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache4));
          if (cache4.has(type)) return cache4;
          cache4.set(type, null);
          ownerDocument = ownerDocument.getElementsByTagName(type);
          for (caches = 0; caches < ownerDocument.length; caches++) {
            var node2 = ownerDocument[caches];
            if (!(node2[internalHoistableMarker] || node2[internalInstanceKey] || "link" === type && "stylesheet" === node2.getAttribute("rel")) && node2.namespaceURI !== SVG_NAMESPACE) {
              var nodeKey = node2.getAttribute(keyAttribute) || "";
              nodeKey = type + nodeKey;
              var existing = cache4.get(nodeKey);
              existing ? existing.push(node2) : cache4.set(nodeKey, [node2]);
            }
          }
          return cache4;
        }
        function mountHoistable(hoistableRoot, type, instance) {
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          hoistableRoot.head.insertBefore(
            instance,
            "title" === type ? hoistableRoot.querySelector("head > title") : null
          );
        }
        function isHostHoistableType(type, props, hostContext) {
          var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
          if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
            return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
              "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
              type,
              type
            ), false;
          switch (type) {
            case "meta":
            case "title":
              return true;
            case "style":
              if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
                outsideHostContainerContext && console.error(
                  'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflic with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`, or move the <style> to the <style> tag.'
                );
                break;
              }
              return true;
            case "link":
              if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
                if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
                  type = props.href;
                  var onError = props.onError, disabled2 = props.disabled;
                  hostContext = [];
                  props.onLoad && hostContext.push("`onLoad`");
                  onError && hostContext.push("`onError`");
                  null != disabled2 && hostContext.push("`disabled`");
                  onError = propNamesListJoin(hostContext, "and");
                  onError += 1 === hostContext.length ? " prop" : " props";
                  disabled2 = 1 === hostContext.length ? "an " + onError : "the " + onError;
                  hostContext.length && console.error(
                    'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
                    type,
                    disabled2,
                    onError
                  );
                }
                outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
                  "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
                ) : (props.onError || props.onLoad) && console.error(
                  "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ));
                break;
              }
              switch (props.rel) {
                case "stylesheet":
                  return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
                    'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
                  ), "string" === typeof type && null == props;
                default:
                  return true;
              }
            case "script":
              type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
              if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
                outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
                  "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
                ) : console.error(
                  'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
                ));
                break;
              }
              return true;
            case "noscript":
            case "template":
              outsideHostContainerContext && console.error(
                "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
                type
              );
          }
          return false;
        }
        function preloadResource(resource) {
          return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
        }
        function noop5() {
        }
        function suspendResource(hoistableRoot, resource, props) {
          if (null === suspendedState)
            throw Error(
              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
            );
          var state = suspendedState;
          if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
            if (null === resource.instance) {
              var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(key)
              );
              if (instance) {
                hoistableRoot = instance._p;
                null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
                resource.state.loading |= Inserted;
                resource.instance = instance;
                markNodeAsHoistable(instance);
                return;
              }
              instance = hoistableRoot.ownerDocument || hoistableRoot;
              props = stylesheetPropsFromRawProps(props);
              (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
              instance = instance.createElement("link");
              markNodeAsHoistable(instance);
              var linkInstance = instance;
              linkInstance._p = new Promise(function(resolve2, reject) {
                linkInstance.onload = resolve2;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance, "link", props);
              resource.instance = instance;
            }
            null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
            state.stylesheets.set(resource, hoistableRoot);
            (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
          }
        }
        function waitForCommitToBeReady() {
          if (null === suspendedState)
            throw Error(
              "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
            );
          var state = suspendedState;
          state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
          return 0 < state.count ? function(commit) {
            var stylesheetTimer = setTimeout(function() {
              state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
              if (state.unsuspend) {
                var unsuspend = state.unsuspend;
                state.unsuspend = null;
                unsuspend();
              }
            }, 6e4);
            state.unsuspend = commit;
            return function() {
              state.unsuspend = null;
              clearTimeout(stylesheetTimer);
            };
          } : null;
        }
        function onUnsuspend() {
          this.count--;
          if (0 === this.count) {
            if (this.stylesheets)
              insertSuspendedStylesheets(this, this.stylesheets);
            else if (this.unsuspend) {
              var unsuspend = this.unsuspend;
              this.unsuspend = null;
              unsuspend();
            }
          }
        }
        function insertSuspendedStylesheets(state, resources) {
          state.stylesheets = null;
          null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
        }
        function insertStylesheetIntoRoot(root2, resource) {
          if (!(resource.state.loading & Inserted)) {
            var precedences = precedencesByRoot.get(root2);
            if (precedences) var last = precedences.get(LAST_PRECEDENCE);
            else {
              precedences = /* @__PURE__ */ new Map();
              precedencesByRoot.set(root2, precedences);
              for (var nodes = root2.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ), i = 0; i < nodes.length; i++) {
                var node2 = nodes[i];
                if ("LINK" === node2.nodeName || "not all" !== node2.getAttribute("media"))
                  precedences.set(node2.dataset.precedence, node2), last = node2;
              }
              last && precedences.set(LAST_PRECEDENCE, last);
            }
            nodes = resource.instance;
            node2 = nodes.getAttribute("data-precedence");
            i = precedences.get(node2) || last;
            i === last && precedences.set(LAST_PRECEDENCE, nodes);
            precedences.set(node2, nodes);
            this.count++;
            last = onUnsuspend.bind(this);
            nodes.addEventListener("load", last);
            nodes.addEventListener("error", last);
            i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
            resource.state.loading |= Inserted;
          }
        }
        function bindToConsole(methodName, args, badgeName) {
          var offset = 0;
          switch (methodName) {
            case "dir":
            case "dirxml":
            case "groupEnd":
            case "table":
              return bind.apply(console[methodName], [console].concat(args));
            case "assert":
              offset = 1;
          }
          args = args.slice(0);
          "string" === typeof args[offset] ? args.splice(
            offset,
            1,
            badgeFormat + args[offset],
            badgeStyle,
            pad + badgeName + pad,
            resetStyle
          ) : args.splice(
            offset,
            0,
            badgeFormat,
            badgeStyle,
            pad + badgeName + pad,
            resetStyle
          );
          args.unshift(console);
          return bind.apply(console[methodName], args);
        }
        function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
          this.tag = 1;
          this.containerInfo = containerInfo;
          this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
          this.timeoutHandle = noTimeout;
          this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
          this.callbackPriority = 0;
          this.expirationTimes = createLaneMap(-1);
          this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
          this.entanglements = createLaneMap(0);
          this.hiddenUpdates = createLaneMap(null);
          this.identifierPrefix = identifierPrefix;
          this.onUncaughtError = onUncaughtError;
          this.onCaughtError = onCaughtError;
          this.onRecoverableError = onRecoverableError;
          this.pooledCache = null;
          this.pooledCacheLanes = 0;
          this.formState = formState;
          this.incompleteTransitions = /* @__PURE__ */ new Map();
          this.passiveEffectDuration = this.effectDuration = -0;
          this.memoizedUpdaters = /* @__PURE__ */ new Set();
          containerInfo = this.pendingUpdatersLaneMap = [];
          for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
          this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
        }
        function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
          containerInfo = new FiberRootNode(
            containerInfo,
            tag,
            hydrate2,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            formState
          );
          tag = ConcurrentMode;
          true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
          isDevToolsPresent && (tag |= ProfileMode);
          isStrictMode = createFiber(3, null, null, tag);
          containerInfo.current = isStrictMode;
          isStrictMode.stateNode = containerInfo;
          tag = createCache3();
          retainCache(tag);
          containerInfo.pooledCache = tag;
          retainCache(tag);
          isStrictMode.memoizedState = {
            element: initialChildren,
            isDehydrated: hydrate2,
            cache: tag
          };
          initializeUpdateQueue(isStrictMode);
          return containerInfo;
        }
        function getContextForSubtree(parentComponent) {
          if (!parentComponent) return emptyContextObject;
          parentComponent = emptyContextObject;
          return parentComponent;
        }
        function updateContainerSync(element, container, parentComponent, callback2) {
          0 === container.tag && flushPassiveEffects();
          updateContainerImpl(
            container.current,
            2,
            element,
            container,
            parentComponent,
            callback2
          );
          return 2;
        }
        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback2) {
          if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
            try {
              injectedHook.onScheduleFiberRoot(rendererID, container, element);
            } catch (err) {
              hasLoggedError || (hasLoggedError = true, console.error(
                "React instrumentation encountered an error: %s",
                err
              ));
            }
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
          parentComponent = getContextForSubtree(parentComponent);
          null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
          isRendering && null !== current2 && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
            "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
            getComponentNameFromFiber(current2) || "Unknown"
          ));
          container = createUpdate(lane);
          container.payload = { element };
          callback2 = void 0 === callback2 ? null : callback2;
          null !== callback2 && ("function" !== typeof callback2 && console.error(
            "Expected the last optional `callback` argument to be a function. Instead received: %s.",
            callback2
          ), container.callback = callback2);
          element = enqueueUpdate(rootFiber, container, lane);
          null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
        }
        function markRetryLaneImpl(fiber, retryLane) {
          fiber = fiber.memoizedState;
          if (null !== fiber && null !== fiber.dehydrated) {
            var a = fiber.retryLane;
            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
          }
        }
        function markRetryLaneIfNotHydrated(fiber, retryLane) {
          markRetryLaneImpl(fiber, retryLane);
          (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
        }
        function attemptContinuousHydration(fiber) {
          if (13 === fiber.tag) {
            var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
            null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
            markRetryLaneIfNotHydrated(fiber, 67108864);
          }
        }
        function getCurrentFiberForDevTools() {
          return current2;
        }
        function getLaneLabelMap() {
          for (var map2 = /* @__PURE__ */ new Map(), lane = 1, index = 0; 31 > index; index++) {
            var label = getLabelForLane(lane);
            map2.set(lane, label);
            lane *= 2;
          }
          return map2;
        }
        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
          var prevTransition = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          try {
            ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
          } finally {
            ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
          }
        }
        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (_enabled) {
            var blockedOn = findInstanceBlockingEvent(nativeEvent);
            if (null === blockedOn)
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              ), clearIfContinuousEvent(domEventName, nativeEvent);
            else if (queueIfContinuousEvent(
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ))
              nativeEvent.stopPropagation();
            else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
              for (; null !== blockedOn; ) {
                var fiber = getInstanceFromNode(blockedOn);
                if (null !== fiber)
                  switch (fiber.tag) {
                    case 3:
                      fiber = fiber.stateNode;
                      if (fiber.current.memoizedState.isDehydrated) {
                        var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                        if (0 !== lanes) {
                          var root2 = fiber;
                          root2.pendingLanes |= 2;
                          for (root2.entangledLanes |= 2; lanes; ) {
                            var lane = 1 << 31 - clz32(lanes);
                            root2.entanglements[1] |= lane;
                            lanes &= ~lane;
                          }
                          ensureRootIsScheduled(fiber);
                          (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, false));
                        }
                      }
                      break;
                    case 13:
                      root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                  }
                fiber = findInstanceBlockingEvent(nativeEvent);
                null === fiber && dispatchEventForPluginEventSystem(
                  domEventName,
                  eventSystemFlags,
                  nativeEvent,
                  return_targetInst,
                  targetContainer
                );
                if (fiber === blockedOn) break;
                blockedOn = fiber;
              }
              null !== blockedOn && nativeEvent.stopPropagation();
            } else
              dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                null,
                targetContainer
              );
          }
        }
        function findInstanceBlockingEvent(nativeEvent) {
          nativeEvent = getEventTarget(nativeEvent);
          return findInstanceBlockingTarget(nativeEvent);
        }
        function findInstanceBlockingTarget(targetNode) {
          return_targetInst = null;
          targetNode = getClosestInstanceFromNode(targetNode);
          if (null !== targetNode) {
            var nearestMounted = getNearestMountedFiber(targetNode);
            if (null === nearestMounted) targetNode = null;
            else {
              var tag = nearestMounted.tag;
              if (13 === tag) {
                targetNode = getSuspenseInstanceFromFiber(nearestMounted);
                if (null !== targetNode) return targetNode;
                targetNode = null;
              } else if (3 === tag) {
                if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                  return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                targetNode = null;
              } else nearestMounted !== targetNode && (targetNode = null);
            }
          }
          return_targetInst = targetNode;
          return null;
        }
        function getEventPriority(domEventName) {
          switch (domEventName) {
            case "beforetoggle":
            case "cancel":
            case "click":
            case "close":
            case "contextmenu":
            case "copy":
            case "cut":
            case "auxclick":
            case "dblclick":
            case "dragend":
            case "dragstart":
            case "drop":
            case "focusin":
            case "focusout":
            case "input":
            case "invalid":
            case "keydown":
            case "keypress":
            case "keyup":
            case "mousedown":
            case "mouseup":
            case "paste":
            case "pause":
            case "play":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
            case "ratechange":
            case "reset":
            case "resize":
            case "seeked":
            case "submit":
            case "toggle":
            case "touchcancel":
            case "touchend":
            case "touchstart":
            case "volumechange":
            case "change":
            case "selectionchange":
            case "textInput":
            case "compositionstart":
            case "compositionend":
            case "compositionupdate":
            case "beforeblur":
            case "afterblur":
            case "beforeinput":
            case "blur":
            case "fullscreenchange":
            case "focus":
            case "hashchange":
            case "popstate":
            case "select":
            case "selectstart":
              return DiscreteEventPriority;
            case "drag":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "mousemove":
            case "mouseout":
            case "mouseover":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "scroll":
            case "touchmove":
            case "wheel":
            case "mouseenter":
            case "mouseleave":
            case "pointerenter":
            case "pointerleave":
              return ContinuousEventPriority;
            case "message":
              switch (getCurrentPriorityLevel()) {
                case ImmediatePriority:
                  return DiscreteEventPriority;
                case UserBlockingPriority:
                  return ContinuousEventPriority;
                case NormalPriority$1:
                case LowPriority:
                  return DefaultEventPriority;
                case IdlePriority:
                  return IdleEventPriority;
                default:
                  return DefaultEventPriority;
              }
            default:
              return DefaultEventPriority;
          }
        }
        function clearIfContinuousEvent(domEventName, nativeEvent) {
          switch (domEventName) {
            case "focusin":
            case "focusout":
              queuedFocus = null;
              break;
            case "dragenter":
            case "dragleave":
              queuedDrag = null;
              break;
            case "mouseover":
            case "mouseout":
              queuedMouse = null;
              break;
            case "pointerover":
            case "pointerout":
              queuedPointers.delete(nativeEvent.pointerId);
              break;
            case "gotpointercapture":
            case "lostpointercapture":
              queuedPointerCaptures.delete(nativeEvent.pointerId);
          }
        }
        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
            return existingQueuedEvent = {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
          blockedOn = existingQueuedEvent.targetContainers;
          null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
          return existingQueuedEvent;
        }
        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
          switch (domEventName) {
            case "focusin":
              return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedFocus,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "dragenter":
              return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedDrag,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "mouseover":
              return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedMouse,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              ), true;
            case "pointerover":
              var pointerId = nativeEvent.pointerId;
              queuedPointers.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointers.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              );
              return true;
            case "gotpointercapture":
              return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
                pointerId,
                accumulateOrCreateContinuousQueuedReplayableEvent(
                  queuedPointerCaptures.get(pointerId) || null,
                  blockedOn,
                  domEventName,
                  eventSystemFlags,
                  targetContainer,
                  nativeEvent
                )
              ), true;
          }
          return false;
        }
        function attemptExplicitHydrationTarget(queuedTarget) {
          var targetInst = getClosestInstanceFromNode(queuedTarget.target);
          if (null !== targetInst) {
            var nearestMounted = getNearestMountedFiber(targetInst);
            if (null !== nearestMounted) {
              if (targetInst = nearestMounted.tag, 13 === targetInst) {
                if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                  queuedTarget.blockedOn = targetInst;
                  runWithPriority(queuedTarget.priority, function() {
                    if (13 === nearestMounted.tag) {
                      var lane = requestUpdateLane(nearestMounted), root2 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                      null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
                      markRetryLaneIfNotHydrated(nearestMounted, lane);
                    }
                  });
                  return;
                }
              } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
                queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
                return;
              }
            }
          }
          queuedTarget.blockedOn = null;
        }
        function attemptReplayContinuousQueuedEvent(queuedEvent) {
          if (null !== queuedEvent.blockedOn) return false;
          for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
            if (null === nextBlockedOn) {
              nextBlockedOn = queuedEvent.nativeEvent;
              var nativeEventClone = new nextBlockedOn.constructor(
                nextBlockedOn.type,
                nextBlockedOn
              ), event = nativeEventClone;
              null !== currentReplayingEvent && console.error(
                "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = event;
              nextBlockedOn.target.dispatchEvent(nativeEventClone);
              null === currentReplayingEvent && console.error(
                "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
              );
              currentReplayingEvent = null;
            } else
              return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
            targetContainers.shift();
          }
          return true;
        }
        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
          attemptReplayContinuousQueuedEvent(queuedEvent) && map2.delete(key);
        }
        function replayUnblockedEvents() {
          hasScheduledReplayAttempt = false;
          null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
          null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
          null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
        }
        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            replayUnblockedEvents
          )));
        }
        function scheduleReplayQueueIfNeeded(formReplayingQueue) {
          lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
            Scheduler.unstable_NormalPriority,
            function() {
              lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
              for (var i = 0; i < formReplayingQueue.length; i += 3) {
                var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
                if ("function" !== typeof submitterOrAction)
                  if (null === findInstanceBlockingTarget(submitterOrAction || form))
                    continue;
                  else break;
                var formInst = getInstanceFromNode(form);
                null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                }, Object.freeze(form), startHostTransition(
                  formInst,
                  form,
                  submitterOrAction,
                  formData
                ));
              }
            }
          ));
        }
        function retryIfBlockedOn(unblocked) {
          function unblock(queuedEvent) {
            return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
          }
          null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
          null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
          null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
          queuedPointers.forEach(unblock);
          queuedPointerCaptures.forEach(unblock);
          for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
            var queuedTarget = queuedExplicitHydrationTargets[i];
            queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
          }
          for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
            attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
          i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
          if (null != i)
            for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
              var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
              if ("function" === typeof submitterOrAction)
                formProps || scheduleReplayQueueIfNeeded(i);
              else if (formProps) {
                var action = null;
                if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                  if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                    action = formProps.formAction;
                  else {
                    if (null !== findInstanceBlockingTarget(form)) continue;
                  }
                else action = formProps.action;
                "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
                scheduleReplayQueueIfNeeded(i);
              }
            }
        }
        function ReactDOMRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function ReactDOMHydrationRoot(internalRoot) {
          this._internalRoot = internalRoot;
        }
        function warnIfReactDOMContainerInDEV(container) {
          container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
            "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
          ) : console.error(
            "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
          ));
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var Scheduler = require_scheduler(), React53 = require_react(), ReactDOM2 = require_react_dom(), REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE2 = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
        Symbol.for("react.scope");
        Symbol.for("react.debug_trace_mode");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        Symbol.for("react.legacy_hidden");
        Symbol.for("react.tracing_marker");
        var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React53.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, assign3 = Object.assign, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix2, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var current2 = null, isRendering = false, isArrayImpl = Array.isArray, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
          pending: false,
          data: null,
          method: null,
          action: null
        }), valueStack = [];
        var fiberStack = [];
        var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log2 = Math.log, LN2 = Math.LN2, nextTransitionLane = 128, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, canUseDOM3 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
          "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
        var didWarnValueDefaultValue = false;
        var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
          " "
        ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
          " "
        ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null,
          containerTagInScope: null
        }, didWarn = {}, MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", shorthandToLonghand = {
          animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
            " "
          ),
          background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
            " "
          ),
          backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
          border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
            " "
          ),
          borderBlockEnd: [
            "borderBlockEndColor",
            "borderBlockEndStyle",
            "borderBlockEndWidth"
          ],
          borderBlockStart: [
            "borderBlockStartColor",
            "borderBlockStartStyle",
            "borderBlockStartWidth"
          ],
          borderBottom: [
            "borderBottomColor",
            "borderBottomStyle",
            "borderBottomWidth"
          ],
          borderColor: [
            "borderBottomColor",
            "borderLeftColor",
            "borderRightColor",
            "borderTopColor"
          ],
          borderImage: [
            "borderImageOutset",
            "borderImageRepeat",
            "borderImageSlice",
            "borderImageSource",
            "borderImageWidth"
          ],
          borderInlineEnd: [
            "borderInlineEndColor",
            "borderInlineEndStyle",
            "borderInlineEndWidth"
          ],
          borderInlineStart: [
            "borderInlineStartColor",
            "borderInlineStartStyle",
            "borderInlineStartWidth"
          ],
          borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
          borderRadius: [
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
            "borderTopLeftRadius",
            "borderTopRightRadius"
          ],
          borderRight: [
            "borderRightColor",
            "borderRightStyle",
            "borderRightWidth"
          ],
          borderStyle: [
            "borderBottomStyle",
            "borderLeftStyle",
            "borderRightStyle",
            "borderTopStyle"
          ],
          borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
          borderWidth: [
            "borderBottomWidth",
            "borderLeftWidth",
            "borderRightWidth",
            "borderTopWidth"
          ],
          columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
          columns: ["columnCount", "columnWidth"],
          flex: ["flexBasis", "flexGrow", "flexShrink"],
          flexFlow: ["flexDirection", "flexWrap"],
          font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
            " "
          ),
          fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
            " "
          ),
          gap: ["columnGap", "rowGap"],
          grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
            " "
          ),
          gridArea: [
            "gridColumnEnd",
            "gridColumnStart",
            "gridRowEnd",
            "gridRowStart"
          ],
          gridColumn: ["gridColumnEnd", "gridColumnStart"],
          gridColumnGap: ["columnGap"],
          gridGap: ["columnGap", "rowGap"],
          gridRow: ["gridRowEnd", "gridRowStart"],
          gridRowGap: ["rowGap"],
          gridTemplate: [
            "gridTemplateAreas",
            "gridTemplateColumns",
            "gridTemplateRows"
          ],
          listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
          margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
          marker: ["markerEnd", "markerMid", "markerStart"],
          mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
            " "
          ),
          maskPosition: ["maskPositionX", "maskPositionY"],
          outline: ["outlineColor", "outlineStyle", "outlineWidth"],
          overflow: ["overflowX", "overflowY"],
          padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
          placeContent: ["alignContent", "justifyContent"],
          placeItems: ["alignItems", "justifyItems"],
          placeSelf: ["alignSelf", "justifySelf"],
          textDecoration: [
            "textDecorationColor",
            "textDecorationLine",
            "textDecorationStyle"
          ],
          textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
          transition: [
            "transitionDelay",
            "transitionDuration",
            "transitionProperty",
            "transitionTimingFunction"
          ],
          wordWrap: ["overflowWrap"]
        }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
          "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
            " "
          )
        ), aliases = /* @__PURE__ */ new Map([
          ["acceptCharset", "accept-charset"],
          ["htmlFor", "for"],
          ["httpEquiv", "http-equiv"],
          ["crossOrigin", "crossorigin"],
          ["accentHeight", "accent-height"],
          ["alignmentBaseline", "alignment-baseline"],
          ["arabicForm", "arabic-form"],
          ["baselineShift", "baseline-shift"],
          ["capHeight", "cap-height"],
          ["clipPath", "clip-path"],
          ["clipRule", "clip-rule"],
          ["colorInterpolation", "color-interpolation"],
          ["colorInterpolationFilters", "color-interpolation-filters"],
          ["colorProfile", "color-profile"],
          ["colorRendering", "color-rendering"],
          ["dominantBaseline", "dominant-baseline"],
          ["enableBackground", "enable-background"],
          ["fillOpacity", "fill-opacity"],
          ["fillRule", "fill-rule"],
          ["floodColor", "flood-color"],
          ["floodOpacity", "flood-opacity"],
          ["fontFamily", "font-family"],
          ["fontSize", "font-size"],
          ["fontSizeAdjust", "font-size-adjust"],
          ["fontStretch", "font-stretch"],
          ["fontStyle", "font-style"],
          ["fontVariant", "font-variant"],
          ["fontWeight", "font-weight"],
          ["glyphName", "glyph-name"],
          ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
          ["glyphOrientationVertical", "glyph-orientation-vertical"],
          ["horizAdvX", "horiz-adv-x"],
          ["horizOriginX", "horiz-origin-x"],
          ["imageRendering", "image-rendering"],
          ["letterSpacing", "letter-spacing"],
          ["lightingColor", "lighting-color"],
          ["markerEnd", "marker-end"],
          ["markerMid", "marker-mid"],
          ["markerStart", "marker-start"],
          ["overlinePosition", "overline-position"],
          ["overlineThickness", "overline-thickness"],
          ["paintOrder", "paint-order"],
          ["panose-1", "panose-1"],
          ["pointerEvents", "pointer-events"],
          ["renderingIntent", "rendering-intent"],
          ["shapeRendering", "shape-rendering"],
          ["stopColor", "stop-color"],
          ["stopOpacity", "stop-opacity"],
          ["strikethroughPosition", "strikethrough-position"],
          ["strikethroughThickness", "strikethrough-thickness"],
          ["strokeDasharray", "stroke-dasharray"],
          ["strokeDashoffset", "stroke-dashoffset"],
          ["strokeLinecap", "stroke-linecap"],
          ["strokeLinejoin", "stroke-linejoin"],
          ["strokeMiterlimit", "stroke-miterlimit"],
          ["strokeOpacity", "stroke-opacity"],
          ["strokeWidth", "stroke-width"],
          ["textAnchor", "text-anchor"],
          ["textDecoration", "text-decoration"],
          ["textRendering", "text-rendering"],
          ["transformOrigin", "transform-origin"],
          ["underlinePosition", "underline-position"],
          ["underlineThickness", "underline-thickness"],
          ["unicodeBidi", "unicode-bidi"],
          ["unicodeRange", "unicode-range"],
          ["unitsPerEm", "units-per-em"],
          ["vAlphabetic", "v-alphabetic"],
          ["vHanging", "v-hanging"],
          ["vIdeographic", "v-ideographic"],
          ["vMathematical", "v-mathematical"],
          ["vectorEffect", "vector-effect"],
          ["vertAdvY", "vert-adv-y"],
          ["vertOriginX", "vert-origin-x"],
          ["vertOriginY", "vert-origin-y"],
          ["wordSpacing", "word-spacing"],
          ["writingMode", "writing-mode"],
          ["xmlnsXlink", "xmlns:xlink"],
          ["xHeight", "x-height"]
        ]), possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          fetchpriority: "fetchPriority",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          imagesizes: "imageSizes",
          imagesrcset: "imageSrcSet",
          inert: "inert",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          popover: "popover",
          popovertarget: "popoverTarget",
          popovertargetaction: "popoverTargetAction",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          transformorigin: "transformOrigin",
          "transform-origin": "transformOrigin",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        }, ariaProperties = {
          "aria-current": 0,
          "aria-description": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        }, warnedProperties$1 = {}, rARIA$1 = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel$1 = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
          "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), rARIACamel = RegExp(
          "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
        ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, passiveBrowserEventsSupported = false;
        if (canUseDOM3)
          try {
            var options$jscomp$0 = {};
            Object.defineProperty(options$jscomp$0, "passive", {
              get: function() {
                passiveBrowserEventsSupported = true;
              }
            });
            window.addEventListener("test", options$jscomp$0, options$jscomp$0);
            window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
          } catch (e) {
            passiveBrowserEventsSupported = false;
          }
        var root = null, startText = null, fallbackText = null, EventInterface = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0
        }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign3({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign3({}, UIEventInterface, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: getEventModifierState,
          button: 0,
          buttons: 0,
          relatedTarget: function(event) {
            return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
          },
          movementX: function(event) {
            if ("movementX" in event) return event.movementX;
            event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
            return lastMovementX;
          },
          movementY: function(event) {
            return "movementY" in event ? event.movementY : lastMovementY;
          }
        }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign3({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign3({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign3({}, EventInterface, {
          animationName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign3({}, EventInterface, {
          clipboardData: function(event) {
            return "clipboardData" in event ? event.clipboardData : window.clipboardData;
          }
        }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign3({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
          CompositionEventInterface
        ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified"
        }, translateToKey = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta"
        }, modifierKeyToProp = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey"
        }, KeyboardEventInterface = assign3({}, UIEventInterface, {
          key: function(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if ("Unidentified" !== key) return key;
            }
            return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: getEventModifierState,
          charCode: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : 0;
          },
          keyCode: function(event) {
            return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          },
          which: function(event) {
            return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
          }
        }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign3({}, MouseEventInterface, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0
        }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign3({}, UIEventInterface, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: getEventModifierState
        }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign3({}, EventInterface, {
          propertyName: 0,
          elapsedTime: 0,
          pseudoElement: 0
        }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign3({}, MouseEventInterface, {
          deltaX: function(event) {
            return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
          },
          deltaY: function(event) {
            return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
          },
          deltaZ: 0,
          deltaMode: 0
        }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign3({}, EventInterface, {
          newState: 0,
          oldState: 0
        }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM3 && "CompositionEvent" in window, documentMode = null;
        canUseDOM3 && "documentMode" in document && (documentMode = document.documentMode);
        var canUseTextInputEvent = canUseDOM3 && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM3 && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
          color: true,
          date: true,
          datetime: true,
          "datetime-local": true,
          email: true,
          month: true,
          number: true,
          password: true,
          range: true,
          search: true,
          tel: true,
          text: true,
          time: true,
          url: true,
          week: true
        }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
        canUseDOM3 && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
        var objectIs = "function" === typeof Object.is ? Object.is : is3, skipSelectionChangeEvent = canUseDOM3 && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionrun: makePrefixMap("Transition", "TransitionRun"),
          transitionstart: makePrefixMap("Transition", "TransitionStart"),
          transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        }, prefixedEventNames = {}, style = {};
        canUseDOM3 && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
        var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(
          " "
        ), OffscreenVisible = 1, OffscreenDetached = 2, OffscreenPassiveEffectsConnected = 4, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
        Object.freeze(emptyContextObject);
        var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, NoStrictPassiveEffectsMode = 64, now = Scheduler.unstable_now, renderStartTime = -0, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = false, nestedUpdateScheduled = false, ReactStrictModeWarnings = {
          recordUnsafeLifecycleWarnings: function() {
          },
          flushPendingUnsafeLifecycleWarnings: function() {
          },
          recordLegacyContextWarning: function() {
          },
          flushLegacyContextWarning: function() {
          },
          discardPendingWarnings: function() {
          }
        }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
            componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillMountWarnings = []);
          var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
            UNSAFE_componentWillMountUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillMountWarnings = []);
          var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
            componentWillReceivePropsUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillReceivePropsWarnings = []);
          var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
            function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(
                getComponentNameFromFiber(fiber) || "Component"
              );
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            }
          ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
          var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
            componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingComponentWillUpdateWarnings = []);
          var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
          0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
            UNSAFE_componentWillUpdateUniqueNames.add(
              getComponentNameFromFiber(fiber) || "Component"
            );
            didWarnAboutUnsafeLifecycles.add(fiber.type);
          }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
          if (0 < UNSAFE_componentWillMountUniqueNames.size) {
            var sortedNames = setToSortedString(
              UNSAFE_componentWillMountUniqueNames
            );
            console.error(
              "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
              sortedNames
            );
          }
          0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillReceivePropsUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
            UNSAFE_componentWillUpdateUniqueNames
          ), console.error(
            "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
            "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
            componentWillReceivePropsUniqueNames
          ), console.warn(
            "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
          0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
            "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
            sortedNames
          ));
        };
        var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = null;
          for (var node2 = fiber; null !== node2; )
            node2.mode & StrictLegacyMode && (strictRoot = node2), node2 = node2.return;
          null === strictRoot ? console.error(
            "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
          ) : !didWarnAboutLegacyContext.has(fiber.type) && (node2 = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node2 && (node2 = [], pendingLegacyContextWarning.set(strictRoot, node2)), node2.push(fiber));
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray) {
            if (0 !== fiberArray.length) {
              var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
              fiberArray.forEach(function(fiber) {
                uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                didWarnAboutLegacyContext.add(fiber.type);
              });
              var sortedNames = setToSortedString(uniqueNames);
              runWithFiberInDEV(firstFiber, function() {
                console.error(
                  "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
                  sortedNames
                );
              });
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = /* @__PURE__ */ new Map();
        };
        var CapturedStacks = /* @__PURE__ */ new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
          "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), SuspenseException = Error(
          "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"
        ), SuspenseyCommitException = Error(
          "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
        ), noopSuspenseyCommitThenable = {
          then: function() {
            console.error(
              'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
            );
          }
        }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, callComponent = {
          "react-stack-bottom-frame": function(Component4, props, secondArg) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return Component4(props, secondArg);
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent), callRender = {
          "react-stack-bottom-frame": function(instance) {
            var wasRendering = isRendering;
            isRendering = true;
            try {
              return instance.render();
            } finally {
              isRendering = wasRendering;
            }
          }
        }, callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender), callComponentDidMount = {
          "react-stack-bottom-frame": function(finishedWork, instance) {
            try {
              instance.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount), callComponentDidUpdate = {
          "react-stack-bottom-frame": function(finishedWork, instance, prevProps, prevState, snapshot) {
            try {
              instance.componentDidUpdate(prevProps, prevState, snapshot);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
        }, callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate), callComponentDidCatch = {
          "react-stack-bottom-frame": function(instance, errorInfo) {
            var stack = errorInfo.stack;
            instance.componentDidCatch(errorInfo.value, {
              componentStack: null !== stack ? stack : ""
            });
          }
        }, callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch), callComponentWillUnmount = {
          "react-stack-bottom-frame": function(current3, nearestMountedAncestor, instance) {
            try {
              instance.componentWillUnmount();
            } catch (error) {
              captureCommitPhaseError(current3, nearestMountedAncestor, error);
            }
          }
        }, callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount), callCreate = {
          "react-stack-bottom-frame": function(effect) {
            var create = effect.create;
            effect = effect.inst;
            create = create();
            return effect.destroy = create;
          }
        }, callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate), callDestroy = {
          "react-stack-bottom-frame": function(current3, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error) {
              captureCommitPhaseError(current3, nearestMountedAncestor, error);
            }
          }
        }, callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy), callLazyInit = {
          "react-stack-bottom-frame": function(lazy) {
            var init = lazy._init;
            return init(lazy._payload);
          }
        }, callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit), thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;
        var didWarnAboutGenerators = didWarnAboutMaps = false;
        var ownerHasKeyUseWarning = {};
        var ownerHasFunctionTypeWarning = {};
        var ownerHasSymbolTypeWarning = {};
        warnForMissingKey = function(returnFiber, workInProgress2, child) {
          if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
            if ("object" !== typeof child._store)
              throw Error(
                "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
              );
            child._store.validated = 1;
            var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
            if (!ownerHasKeyUseWarning[componentKey]) {
              ownerHasKeyUseWarning[componentKey] = true;
              child = child._owner;
              returnFiber = returnFiber._debugOwner;
              var currentComponentErrorInfo = "";
              returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
              currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
              var childOwnerAppendix = "";
              null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
              runWithFiberInDEV(workInProgress2, function() {
                console.error(
                  'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
                  currentComponentErrorInfo,
                  childOwnerAppendix
                );
              });
            }
          }
        };
        var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
          var listeners = [], signal = this.signal = {
            aborted: false,
            addEventListener: function(type, listener3) {
              listeners.push(listener3);
            }
          };
          this.abort = function() {
            signal.aborted = true;
            listeners.forEach(function(listener3) {
              return listener3();
            });
          };
        }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Consumer: null,
          Provider: null,
          _currentValue: null,
          _currentValue2: null,
          _threadCount: 0,
          _currentRenderer: null,
          _currentRenderer2: null
        }, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
        ReactSharedInternals.S = function(transition, returnValue) {
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
          null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
        };
        var resumedCache = createCursor(null), didWarnUncachedGetSnapshot;
        var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
        var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
        var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false;
        var createFunctionComponentUpdateQueue = function() {
          return { lastEffect: null, events: null, stores: null, memoCache: null };
        };
        var ContextOnlyDispatcher = {
          readContext,
          use,
          useCallback: throwInvalidHookError,
          useContext: throwInvalidHookError,
          useEffect: throwInvalidHookError,
          useImperativeHandle: throwInvalidHookError,
          useLayoutEffect: throwInvalidHookError,
          useInsertionEffect: throwInvalidHookError,
          useMemo: throwInvalidHookError,
          useReducer: throwInvalidHookError,
          useRef: throwInvalidHookError,
          useState: throwInvalidHookError,
          useDebugValue: throwInvalidHookError,
          useDeferredValue: throwInvalidHookError,
          useTransition: throwInvalidHookError,
          useSyncExternalStore: throwInvalidHookError,
          useId: throwInvalidHookError
        };
        ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
        ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
        ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
        ContextOnlyDispatcher.useFormState = throwInvalidHookError;
        ContextOnlyDispatcher.useActionState = throwInvalidHookError;
        ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
        var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback2, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback2, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState6) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState6);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          }
        };
        HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;
        HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
        HooksDispatcherOnMountInDEV.useFormState = function(action, initialState6) {
          currentHookNameInDev = "useFormState";
          mountHookTypesDev();
          warnOnUseFormStateInDev();
          return mountActionState(action, initialState6);
        };
        HooksDispatcherOnMountInDEV.useActionState = function(action, initialState6) {
          currentHookNameInDev = "useActionState";
          mountHookTypesDev();
          return mountActionState(action, initialState6);
        };
        HooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {
          currentHookNameInDev = "useOptimistic";
          mountHookTypesDev();
          return mountOptimistic(passthrough);
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback2, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback2, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState6) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState6);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return mountRefresh();
          }
        };
        HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;
        HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;
        HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function(action, initialState6) {
          currentHookNameInDev = "useFormState";
          updateHookTypesDev();
          warnOnUseFormStateInDev();
          return mountActionState(action, initialState6);
        };
        HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function(action, initialState6) {
          currentHookNameInDev = "useActionState";
          updateHookTypesDev();
          return mountActionState(action, initialState6);
        };
        HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function(passthrough) {
          currentHookNameInDev = "useOptimistic";
          updateHookTypesDev();
          return mountOptimistic(passthrough);
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback2, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback2, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;
        HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
        HooksDispatcherOnUpdateInDEV.useFormState = function(action) {
          currentHookNameInDev = "useFormState";
          updateHookTypesDev();
          warnOnUseFormStateInDev();
          return updateActionState(action);
        };
        HooksDispatcherOnUpdateInDEV.useActionState = function(action) {
          currentHookNameInDev = "useActionState";
          updateHookTypesDev();
          return updateActionState(action);
        };
        HooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          updateHookTypesDev();
          return updateOptimistic(passthrough, reducer);
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          use,
          useCallback: function(callback2, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback2, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          }
        };
        HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;
        HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
        HooksDispatcherOnRerenderInDEV.useFormState = function(action) {
          currentHookNameInDev = "useFormState";
          updateHookTypesDev();
          warnOnUseFormStateInDev();
          return rerenderActionState(action);
        };
        HooksDispatcherOnRerenderInDEV.useActionState = function(action) {
          currentHookNameInDev = "useActionState";
          updateHookTypesDev();
          return rerenderActionState(action);
        };
        HooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          updateHookTypesDev();
          return rerenderOptimistic(passthrough, reducer);
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback2, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback2, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            mountEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState6) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState6);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            mountHookTypesDev();
            return mountRefresh();
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          }
        };
        InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
        InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function(action, initialState6) {
          currentHookNameInDev = "useFormState";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountActionState(action, initialState6);
        };
        InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function(action, initialState6) {
          currentHookNameInDev = "useActionState";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountActionState(action, initialState6);
        };
        InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {
          currentHookNameInDev = "useOptimistic";
          warnInvalidHookAccess();
          mountHookTypesDev();
          return mountOptimistic(passthrough);
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback2, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback2, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          }
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
        InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function(action) {
          currentHookNameInDev = "useFormState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateActionState(action);
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function(action) {
          currentHookNameInDev = "useActionState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateActionState(action);
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return updateOptimistic(passthrough, reducer);
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          use: function(usable) {
            warnInvalidHookAccess();
            return use(usable);
          },
          useCallback: function(callback2, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback2, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            updateEffectImpl(2048, Passive, create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Insertion, create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffectImpl(4, Layout, create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useRef: function() {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useState: function() {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(basicStateReducer);
            } finally {
              ReactSharedInternals.H = prevDispatcher;
            }
          },
          useDebugValue: function() {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
          },
          useDeferredValue: function(value, initialValue) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value, initialValue);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(
              subscribe,
              getSnapshot,
              getServerSnapshot
            );
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useCacheRefresh: function() {
            currentHookNameInDev = "useCacheRefresh";
            updateHookTypesDev();
            return updateWorkInProgressHook().memoizedState;
          },
          useMemoCache: function(size) {
            warnInvalidHookAccess();
            return useMemoCache(size);
          }
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
        InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function(action) {
          currentHookNameInDev = "useFormState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderActionState(action);
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function(action) {
          currentHookNameInDev = "useActionState";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderActionState(action);
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {
          currentHookNameInDev = "useOptimistic";
          warnInvalidHookAccess();
          updateHookTypesDev();
          return rerenderOptimistic(passthrough, reducer);
        };
        var fakeInternalInstance = {};
        var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
        var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
        var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
        var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
        var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
        var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
        var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
        Object.freeze(fakeInternalInstance);
        var classComponentUpdater = {
          isMounted: function(component) {
            var owner = current2;
            if (null !== owner && isRendering && 1 === owner.tag) {
              var instance = owner.stateNode;
              instance._warnedAboutRefsInRender || console.error(
                "%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",
                getComponentNameFromFiber(owner) || "A component"
              );
              instance._warnedAboutRefsInRender = true;
            }
            return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : false;
          },
          enqueueSetState: function(inst, payload, callback2) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.payload = payload;
            void 0 !== callback2 && null !== callback2 && (warnOnInvalidCallback(callback2), update.callback = callback2);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
          },
          enqueueReplaceState: function(inst, payload, callback2) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ReplaceState;
            update.payload = payload;
            void 0 !== callback2 && null !== callback2 && (warnOnInvalidCallback(callback2), update.callback = callback2);
            payload = enqueueUpdate(inst, update, lane);
            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
            markStateUpdateScheduled(inst, lane);
          },
          enqueueForceUpdate: function(inst, callback2) {
            inst = inst._reactInternals;
            var lane = requestUpdateLane(inst), update = createUpdate(lane);
            update.tag = ForceUpdate;
            void 0 !== callback2 && null !== callback2 && (warnOnInvalidCallback(callback2), update.callback = callback2);
            callback2 = enqueueUpdate(inst, update, lane);
            null !== callback2 && (scheduleUpdateOnFiber(callback2, inst, lane), entangleTransitions(callback2, inst, lane));
            null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
          }
        }, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
          if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
            var event = new window.ErrorEvent("error", {
              bubbles: true,
              cancelable: true,
              message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
              error
            });
            if (!window.dispatchEvent(event)) return;
          } else if ("object" === typeof process && "function" === typeof process.emit) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
          "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
        ), didReceiveUpdate = false;
        var didWarnAboutBadClass = {};
        var didWarnAboutContextTypeOnFunctionComponent = {};
        var didWarnAboutContextTypes = {};
        var didWarnAboutGetDerivedStateOnFunctionComponent = {};
        var didWarnAboutReassigningProps = false;
        var didWarnAboutRevealOrder = {};
        var didWarnAboutTailOptions = {};
        var SUSPENDED_MARKER = {
          dehydrated: null,
          treeContext: null,
          retryLane: 0
        }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, valueCursor = createCursor(null);
        var rendererCursorDEV = createCursor(null);
        var rendererSigil = {};
        var currentlyRenderingFiber = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
        var didWarnUpdateInsideUpdate = false;
        var currentlyProcessingQueue = null;
        var didReadFromEntangledAsyncAction = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
        didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
        var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, shouldFireAfterActiveInstanceBlur = false, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192;
        var hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
          /* @__PURE__ */ new Set([nonExtensibleObject]);
        } catch (e$7) {
          hasBadMapPolyfill = true;
        }
        var DefaultAsyncDispatcher = {
          getCacheForType: function(resourceType) {
            var cache4 = readContext(CacheContext), cacheForType = cache4.data.get(resourceType);
            void 0 === cacheForType && (cacheForType = resourceType(), cache4.data.set(resourceType, cacheForType));
            return cacheForType;
          },
          getOwner: function() {
            return current2;
          }
        };
        if ("function" === typeof Symbol && Symbol.for) {
          var symbolFor = Symbol.for;
          symbolFor("selector.component");
          symbolFor("selector.has_pseudo_class");
          symbolFor("selector.role");
          symbolFor("selector.test_id");
          symbolFor("selector.text");
        }
        var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = false, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
        var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
        var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
        (function() {
          for (var i = 0; i < simpleEventPluginEvents.length; i++) {
            var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
            eventName = eventName[0].toUpperCase() + eventName.slice(1);
            registerSimpleEvent(domEventName, "on" + eventName);
          }
          registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
          registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
          registerSimpleEvent(ANIMATION_START, "onAnimationStart");
          registerSimpleEvent("dblclick", "onDoubleClick");
          registerSimpleEvent("focusin", "onFocus");
          registerSimpleEvent("focusout", "onBlur");
          registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
          registerSimpleEvent(TRANSITION_START, "onTransitionStart");
          registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
          registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
        })();
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
        registerTwoPhaseEvent(
          "onChange",
          "change click focusin focusout input keydown keyup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent(
          "onSelect",
          "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
            " "
          )
        );
        registerTwoPhaseEvent("onBeforeInput", [
          "compositionend",
          "keypress",
          "textInput",
          "paste"
        ]);
        registerTwoPhaseEvent(
          "onCompositionEnd",
          "compositionend focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionStart",
          "compositionstart focusout keydown keypress keyup mousedown".split(" ")
        );
        registerTwoPhaseEvent(
          "onCompositionUpdate",
          "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
        );
        var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ), nonDelegatedEvents = new Set(
          "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
        ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
        var didWarnForNewBooleanPropsWithEmptyValue = {};
        var canDiffStyleForHydrationWarning = true;
        var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback2) {
          return localPromise.resolve(null).then(callback2).catch(handleErrorInNextTick);
        } : scheduleTimeout, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
        ReactDOMSharedInternals.d = {
          f: function() {
            var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
            return previousWasRendering || wasRendering;
          },
          r: function(form) {
            var formInst = getInstanceFromNode(form);
            null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
          },
          D: function(href2) {
            previousDispatcher.D(href2);
            preconnectAs("dns-prefetch", href2, null);
          },
          C: function(href2, crossOrigin) {
            previousDispatcher.C(href2, crossOrigin);
            preconnectAs("preconnect", href2, crossOrigin);
          },
          L: function(href2, as, options2) {
            previousDispatcher.L(href2, as, options2);
            var ownerDocument = globalDocument;
            if (ownerDocument && href2 && as) {
              var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
              "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options2.imageSrcSet
              ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                options2.imageSizes
              ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href2) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href2) + '"]';
              var key = preloadSelector;
              switch (as) {
                case "style":
                  key = getStyleKey(href2);
                  break;
                case "script":
                  key = getScriptKey(href2);
              }
              preloadPropsMap.has(key) || (href2 = assign3(
                {
                  rel: "preload",
                  href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href2,
                  as
                },
                options2
              ), preloadPropsMap.set(key, href2), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
                getStylesheetSelectorFromKey(key)
              ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href2), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
            }
          },
          m: function(href2, options2) {
            previousDispatcher.m(href2, options2);
            var ownerDocument = globalDocument;
            if (ownerDocument && href2) {
              var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href2) + '"]', key = preloadSelector;
              switch (as) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                  key = getScriptKey(href2);
              }
              if (!preloadPropsMap.has(key) && (href2 = assign3({ rel: "modulepreload", href: href2 }, options2), preloadPropsMap.set(key, href2), null === ownerDocument.querySelector(preloadSelector))) {
                switch (as) {
                  case "audioworklet":
                  case "paintworklet":
                  case "serviceworker":
                  case "sharedworker":
                  case "worker":
                  case "script":
                    if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                      return;
                }
                as = ownerDocument.createElement("link");
                setInitialProperties(as, "link", href2);
                markNodeAsHoistable(as);
                ownerDocument.head.appendChild(as);
              }
            }
          },
          X: function(src, options2) {
            previousDispatcher.X(src, options2);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign3({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          },
          S: function(href2, precedence, options2) {
            previousDispatcher.S(href2, precedence, options2);
            var ownerDocument = globalDocument;
            if (ownerDocument && href2) {
              var styles2 = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href2);
              precedence = precedence || "default";
              var resource = styles2.get(key);
              if (!resource) {
                var state = { loading: NotLoaded, preload: null };
                if (resource = ownerDocument.querySelector(
                  getStylesheetSelectorFromKey(key)
                ))
                  state.loading = Loaded | Inserted;
                else {
                  href2 = assign3(
                    {
                      rel: "stylesheet",
                      href: href2,
                      "data-precedence": precedence
                    },
                    options2
                  );
                  (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href2, options2);
                  var link = resource = ownerDocument.createElement("link");
                  markNodeAsHoistable(link);
                  setInitialProperties(link, "link", href2);
                  link._p = new Promise(function(resolve2, reject) {
                    link.onload = resolve2;
                    link.onerror = reject;
                  });
                  link.addEventListener("load", function() {
                    state.loading |= Loaded;
                  });
                  link.addEventListener("error", function() {
                    state.loading |= Errored;
                  });
                  state.loading |= Inserted;
                  insertStylesheet(resource, precedence, ownerDocument);
                }
                resource = {
                  type: "stylesheet",
                  instance: resource,
                  count: 1,
                  state
                };
                styles2.set(key, resource);
              }
            }
          },
          M: function(src, options2) {
            previousDispatcher.M(src, options2);
            var ownerDocument = globalDocument;
            if (ownerDocument && src) {
              var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
              resource || (resource = ownerDocument.querySelector(
                getScriptSelectorFromKey(key)
              ), resource || (src = assign3({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
                type: "script",
                instance: resource,
                count: 1,
                state: null
              }, scripts.set(key, resource));
            }
          }
        };
        var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, suspendedState = null, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
          $$typeof: REACT_CONTEXT_TYPE,
          Provider: null,
          Consumer: null,
          _currentValue: NotPendingTransition,
          _currentValue2: NotPendingTransition,
          _threadCount: 0
        }, badgeFormat = "%c%s%c ", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
        var didWarnAboutNestedUpdates = false;
        var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
        overrideHookState = function(fiber, id, path, value) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign3({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          id = findHook(fiber, id);
          null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign3({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          id = findHook(fiber, id);
          null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign3({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          path = enqueueConcurrentRenderForLane(fiber, 2);
          null !== path && scheduleUpdateOnFiber(path, fiber, 2);
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(
            fiber.memoizedProps,
            oldPath,
            newPath
          );
          fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
          oldPath = enqueueConcurrentRenderForLane(fiber, 2);
          null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
        };
        scheduleUpdate = function(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
        var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        ), lastScheduledReplayQueue = null;
        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children, JSCompiler_OptimizeArgumentsArray_p2) {
          var root2 = this._internalRoot;
          if (null === root2) throw Error("Cannot update an unmounted root.");
          "function" === typeof JSCompiler_OptimizeArgumentsArray_p2 ? console.error(
            "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          ) : isValidContainer(JSCompiler_OptimizeArgumentsArray_p2) ? console.error(
            "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
          ) : "undefined" !== typeof JSCompiler_OptimizeArgumentsArray_p2 && console.error(
            "You passed a second argument to root.render(...) but it only accepts one argument."
          );
          JSCompiler_OptimizeArgumentsArray_p2 = root2.current;
          var lane = requestUpdateLane(JSCompiler_OptimizeArgumentsArray_p2);
          updateContainerImpl(
            JSCompiler_OptimizeArgumentsArray_p2,
            lane,
            children,
            root2,
            null,
            null
          );
        };
        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function(JSCompiler_OptimizeArgumentsArray_p3) {
          "function" === typeof JSCompiler_OptimizeArgumentsArray_p3 && console.error(
            "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
          );
          JSCompiler_OptimizeArgumentsArray_p3 = this._internalRoot;
          if (null !== JSCompiler_OptimizeArgumentsArray_p3) {
            this._internalRoot = null;
            var container = JSCompiler_OptimizeArgumentsArray_p3.containerInfo;
            (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
              "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
            );
            updateContainerSync(
              null,
              JSCompiler_OptimizeArgumentsArray_p3,
              null,
              null
            );
            flushSyncWork$1();
            container[internalContainerInstanceKey] = null;
          }
        };
        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
          if (target) {
            var updatePriority = resolveUpdatePriority();
            target = { blockedOn: null, target, priority: updatePriority };
            for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
            queuedExplicitHydrationTargets.splice(i, 0, target);
            0 === i && attemptExplicitHydrationTarget(target);
          }
        };
        (function() {
          var isomorphicReactPackageVersion = React53.version;
          if ("19.0.0" !== isomorphicReactPackageVersion)
            throw Error(
              'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.0.0\nLearn more: https://react.dev/warnings/version-mismatch")
            );
        })();
        "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
          "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
        );
        ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
          var fiber = componentOrElement._reactInternals;
          if (void 0 === fiber) {
            if ("function" === typeof componentOrElement.render)
              throw Error("Unable to find node on an unmounted component.");
            componentOrElement = Object.keys(componentOrElement).join(",");
            throw Error(
              "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
            );
          }
          componentOrElement = findCurrentFiberUsingSlowPath(fiber);
          componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
          componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
          return componentOrElement;
        };
        if (!function() {
          var internals = {
            bundleType: 1,
            version: "19.0.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: ReactSharedInternals,
            findFiberByHostInstance: getClosestInstanceFromNode,
            reconcilerVersion: "19.0.0"
          };
          internals.overrideHookState = overrideHookState;
          internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
          internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
          internals.overrideProps = overrideProps;
          internals.overridePropsDeletePath = overridePropsDeletePath;
          internals.overridePropsRenamePath = overridePropsRenamePath;
          internals.scheduleUpdate = scheduleUpdate;
          internals.setErrorHandler = setErrorHandler;
          internals.setSuspenseHandler = setSuspenseHandler;
          internals.scheduleRefresh = scheduleRefresh;
          internals.scheduleRoot = scheduleRoot;
          internals.setRefreshHandler = setRefreshHandler;
          internals.getCurrentFiber = getCurrentFiberForDevTools;
          internals.getLaneLabelMap = getLaneLabelMap;
          internals.injectProfilingHooks = injectProfilingHooks;
          return injectInternals(internals);
        }() && canUseDOM3 && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
          var protocol = window.location.protocol;
          /^(https?|file):$/.test(protocol) && console.info(
            "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
            "font-weight:bold"
          );
        }
        exports.createRoot = function(container, options2) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
          null !== options2 && void 0 !== options2 && (options2.hydrate ? console.warn(
            "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
          ) : "object" === typeof options2 && null !== options2 && options2.$$typeof === REACT_ELEMENT_TYPE && console.error(
            "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
          ), true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
          options2 = createFiberRoot(
            container,
            1,
            false,
            null,
            null,
            isStrictMode,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            transitionCallbacks,
            null
          );
          container[internalContainerInstanceKey] = options2.current;
          listenToAllSupportedEvents(
            8 === container.nodeType ? container.parentNode : container
          );
          return new ReactDOMRoot(options2);
        };
        exports.hydrateRoot = function(container, initialChildren, options2) {
          if (!isValidContainer(container))
            throw Error("Target container is not a DOM element.");
          warnIfReactDOMContainerInDEV(container);
          void 0 === initialChildren && console.error(
            "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
          );
          var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
          null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
          initialChildren = createFiberRoot(
            container,
            1,
            true,
            initialChildren,
            null != options2 ? options2 : null,
            isStrictMode,
            identifierPrefix,
            onUncaughtError,
            onCaughtError,
            onRecoverableError,
            transitionCallbacks,
            formState
          );
          initialChildren.context = getContextForSubtree(null);
          options2 = initialChildren.current;
          isStrictMode = requestUpdateLane(options2);
          identifierPrefix = createUpdate(isStrictMode);
          identifierPrefix.callback = null;
          enqueueUpdate(options2, identifierPrefix, isStrictMode);
          initialChildren.current.lanes = isStrictMode;
          markRootUpdated$1(initialChildren, isStrictMode);
          ensureRootIsScheduled(initialChildren);
          container[internalContainerInstanceKey] = initialChildren.current;
          listenToAllSupportedEvents(container);
          return new ReactDOMHydrationRoot(initialChildren);
        };
        exports.version = "19.0.0";
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_client_development();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
  var require_use_sync_external_store_with_selector_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js"(exports) {
      "use strict";
      (function() {
        function is3(x2, y) {
          return x2 === y && (0 !== x2 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React53 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is3, useSyncExternalStore2 = React53.useSyncExternalStore, useRef20 = React53.useRef, useEffect34 = React53.useEffect, useMemo7 = React53.useMemo, useDebugValue3 = React53.useDebugValue;
        exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
          var instRef = useRef20(null);
          if (null === instRef.current) {
            var inst = { hasValue: false, value: null };
            instRef.current = inst;
          } else inst = instRef.current;
          instRef = useMemo7(
            function() {
              function memoizedSelector(nextSnapshot) {
                if (!hasMemo) {
                  hasMemo = true;
                  memoizedSnapshot = nextSnapshot;
                  nextSnapshot = selector(nextSnapshot);
                  if (void 0 !== isEqual2 && inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual2(currentSelection, nextSnapshot))
                      return memoizedSelection = currentSelection;
                  }
                  return memoizedSelection = nextSnapshot;
                }
                currentSelection = memoizedSelection;
                if (objectIs(memoizedSnapshot, nextSnapshot))
                  return currentSelection;
                var nextSelection = selector(nextSnapshot);
                if (void 0 !== isEqual2 && isEqual2(currentSelection, nextSelection))
                  return memoizedSnapshot = nextSnapshot, currentSelection;
                memoizedSnapshot = nextSnapshot;
                return memoizedSelection = nextSelection;
              }
              var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
              return [
                function() {
                  return memoizedSelector(getSnapshot());
                },
                null === maybeGetServerSnapshot ? void 0 : function() {
                  return memoizedSelector(maybeGetServerSnapshot());
                }
              ];
            },
            [getSnapshot, getServerSnapshot, selector, isEqual2]
          );
          var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
          useEffect34(
            function() {
              inst.hasValue = true;
              inst.value = value;
            },
            [value]
          );
          useDebugValue3(value);
          return value;
        };
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/use-sync-external-store/with-selector.js
  var require_with_selector = __commonJS({
    "node_modules/use-sync-external-store/with-selector.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_use_sync_external_store_with_selector_development();
      }
    }
  });

  // node_modules/react-router/node_modules/cookie/dist/index.js
  var require_dist = __commonJS({
    "node_modules/react-router/node_modules/cookie/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = parse5;
      exports.serialize = serialize3;
      var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
      var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
      var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
      var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
      var __toString = Object.prototype.toString;
      var NullObject = /* @__PURE__ */ (() => {
        const C = function() {
        };
        C.prototype = /* @__PURE__ */ Object.create(null);
        return C;
      })();
      function parse5(str, options2) {
        const obj = new NullObject();
        const len = str.length;
        if (len < 2)
          return obj;
        const dec = options2?.decode || decode;
        let index = 0;
        do {
          const eqIdx = str.indexOf("=", index);
          if (eqIdx === -1)
            break;
          const colonIdx = str.indexOf(";", index);
          const endIdx = colonIdx === -1 ? len : colonIdx;
          if (eqIdx > endIdx) {
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
          }
          const keyStartIdx = startIndex(str, index, eqIdx);
          const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
          const key = str.slice(keyStartIdx, keyEndIdx);
          if (obj[key] === void 0) {
            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
            let valEndIdx = endIndex(str, endIdx, valStartIdx);
            const value = dec(str.slice(valStartIdx, valEndIdx));
            obj[key] = value;
          }
          index = endIdx + 1;
        } while (index < len);
        return obj;
      }
      function startIndex(str, index, max) {
        do {
          const code = str.charCodeAt(index);
          if (code !== 32 && code !== 9)
            return index;
        } while (++index < max);
        return max;
      }
      function endIndex(str, index, min) {
        while (index > min) {
          const code = str.charCodeAt(--index);
          if (code !== 32 && code !== 9)
            return index + 1;
        }
        return min;
      }
      function serialize3(name, val, options2) {
        const enc = options2?.encode || encodeURIComponent;
        if (!cookieNameRegExp.test(name)) {
          throw new TypeError(`argument name is invalid: ${name}`);
        }
        const value = enc(val);
        if (!cookieValueRegExp.test(value)) {
          throw new TypeError(`argument val is invalid: ${val}`);
        }
        let str = name + "=" + value;
        if (!options2)
          return str;
        if (options2.maxAge !== void 0) {
          if (!Number.isInteger(options2.maxAge)) {
            throw new TypeError(`option maxAge is invalid: ${options2.maxAge}`);
          }
          str += "; Max-Age=" + options2.maxAge;
        }
        if (options2.domain) {
          if (!domainValueRegExp.test(options2.domain)) {
            throw new TypeError(`option domain is invalid: ${options2.domain}`);
          }
          str += "; Domain=" + options2.domain;
        }
        if (options2.path) {
          if (!pathValueRegExp.test(options2.path)) {
            throw new TypeError(`option path is invalid: ${options2.path}`);
          }
          str += "; Path=" + options2.path;
        }
        if (options2.expires) {
          if (!isDate2(options2.expires) || !Number.isFinite(options2.expires.valueOf())) {
            throw new TypeError(`option expires is invalid: ${options2.expires}`);
          }
          str += "; Expires=" + options2.expires.toUTCString();
        }
        if (options2.httpOnly) {
          str += "; HttpOnly";
        }
        if (options2.secure) {
          str += "; Secure";
        }
        if (options2.partitioned) {
          str += "; Partitioned";
        }
        if (options2.priority) {
          const priority = typeof options2.priority === "string" ? options2.priority.toLowerCase() : void 0;
          switch (priority) {
            case "low":
              str += "; Priority=Low";
              break;
            case "medium":
              str += "; Priority=Medium";
              break;
            case "high":
              str += "; Priority=High";
              break;
            default:
              throw new TypeError(`option priority is invalid: ${options2.priority}`);
          }
        }
        if (options2.sameSite) {
          const sameSite = typeof options2.sameSite === "string" ? options2.sameSite.toLowerCase() : options2.sameSite;
          switch (sameSite) {
            case true:
            case "strict":
              str += "; SameSite=Strict";
              break;
            case "lax":
              str += "; SameSite=Lax";
              break;
            case "none":
              str += "; SameSite=None";
              break;
            default:
              throw new TypeError(`option sameSite is invalid: ${options2.sameSite}`);
          }
        }
        return str;
      }
      function decode(str) {
        if (str.indexOf("%") === -1)
          return str;
        try {
          return decodeURIComponent(str);
        } catch (e) {
          return str;
        }
      }
      function isDate2(val) {
        return __toString.call(val) === "[object Date]";
      }
    }
  });

  // node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE2 = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE2 = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE2 || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE2 || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE2:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE2:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element3 = REACT_ELEMENT_TYPE;
          var ForwardRef2 = REACT_FORWARD_REF_TYPE2;
          var Fragment26 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo2 = REACT_MEMO_TYPE2;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense3 = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE2;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE2;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element3;
          exports.ForwardRef = ForwardRef2;
          exports.Fragment = Fragment26;
          exports.Lazy = Lazy;
          exports.Memo = Memo2;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense3;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/prop-types/node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from3;
        var to2 = toObject(target);
        var symbols;
        for (var s2 = 1; s2 < arguments.length; s2++) {
          from3 = Object(arguments[s2]);
          for (var key in from3) {
            if (hasOwnProperty.call(from3, key)) {
              to2[key] = from3[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from3);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from3, symbols[i])) {
                to2[symbols[i]] = from3[symbols[i]];
              }
            }
          }
        }
        return to2;
      };
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/lib/has.js
  var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js"(exports, module) {
      module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js"(exports, module) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has3 = require_has();
        printWarning = function(text2) {
          var message = "Warning: " + text2;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x2) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has3;
      function checkPropTypes(typeSpecs, values, location2, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has3(typeSpecs, typeSpecName)) {
              var error;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error(
                    (componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                  );
                  err.name = "Invariant Violation";
                  throw err;
                }
                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
              } catch (ex) {
                error = ex;
              }
              if (error && !(error instanceof Error)) {
                printWarning(
                  (componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                );
              }
              if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                loggedTypeFailures[error.message] = true;
                var stack = getStack ? getStack() : "";
                printWarning(
                  "Failed " + location2 + " type: " + error.message + (stack != null ? stack : "")
                );
              }
            }
          }
        }
      }
      checkPropTypes.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module.exports = checkPropTypes;
    }
  });

  // node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
      "use strict";
      var ReactIs = require_react_is();
      var assign3 = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var has3 = require_has();
      var checkPropTypes = require_checkPropTypes();
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text2) {
          var message = "Warning: " + text2;
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x2) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module.exports = function(isValidElement2, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bigint: createPrimitiveTypeChecker("bigint"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is3(x2, y) {
          if (x2 === y) {
            return x2 !== 0 || 1 / x2 === 1 / y;
          } else {
            return x2 !== x2 && y !== y;
          }
        }
        function PropTypeError(message, data2) {
          this.message = message;
          this.data = data2 && typeof data2 === "object" ? data2 : {};
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                manualPropTypeWarningCount < 3) {
                  printWarning(
                    "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location2, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location2, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError(
                "Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
                { expectedType }
              );
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location2, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i = 0; i < propValue.length; i++) {
              var error = typeChecker(propValue, i, componentName, location2, propFullName + "[" + i + "]", ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeChecker() {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            if (!isValidElement2(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location2, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                );
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
              if (is3(propValue, expectedValues[i])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
              var type = getPreciseType(value);
              if (type === "symbol") {
                return String(value);
              }
              return value;
            });
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location2, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has3(propValue, key)) {
                var error = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
                if (error instanceof Error) {
                  return error;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
              printWarning(
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
              );
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate(props, propName, componentName, location2, propFullName) {
            var expectedTypes = [];
            for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
              var checker2 = arrayOfTypeCheckers[i2];
              var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has3(checkerResult.data, "expectedType")) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createNodeChecker() {
          function validate(props, propName, componentName, location2, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function invalidValidatorError(componentName, location2, propFullName, key, type) {
          return new PropTypeError(
            (componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
          );
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (typeof checker !== "function") {
                return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
              }
              var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign3({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (has3(shapeTypes, key) && typeof checker !== "function") {
                return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement2(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes;
        ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module) {
      if (true) {
        ReactIs = require_react_is();
        throwOnDirectAccess = true;
        module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
      "use strict";
      (function() {
        function getComponentNameFromType(type) {
          if (null == type) return null;
          if ("function" === typeof type)
            return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
          if ("string" === typeof type) return type;
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if ("object" === typeof type)
            switch ("number" === typeof type.tag && console.error(
              "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
            ), type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
              case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
              case REACT_FORWARD_REF_TYPE2:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
              case REACT_MEMO_TYPE2:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                  return getComponentNameFromType(type(innerType));
                } catch (x2) {
                }
            }
          return null;
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          try {
            testStringCoercion(value);
            var JSCompiler_inline_result = false;
          } catch (e) {
            JSCompiler_inline_result = true;
          }
          if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(
              JSCompiler_inline_result,
              "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
              JSCompiler_inline_result$jscomp$0
            );
            return testStringCoercion(value);
          }
        }
        function disabledLog() {
        }
        function disableLogs() {
          if (0 === disabledDepth) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
        function reenableLogs() {
          disabledDepth--;
          if (0 === disabledDepth) {
            var props = { configurable: true, enumerable: true, writable: true };
            Object.defineProperties(console, {
              log: assign3({}, props, { value: prevLog }),
              info: assign3({}, props, { value: prevInfo }),
              warn: assign3({}, props, { value: prevWarn }),
              error: assign3({}, props, { value: prevError }),
              group: assign3({}, props, { value: prevGroup }),
              groupCollapsed: assign3({}, props, { value: prevGroupCollapsed }),
              groupEnd: assign3({}, props, { value: prevGroupEnd })
            });
          }
          0 > disabledDepth && console.error(
            "disabledDepth fell below zero. This is a bug in React. Please file an issue."
          );
        }
        function describeBuiltInComponentFrame(name) {
          if (void 0 === prefix2)
            try {
              throw Error();
            } catch (x2) {
              var match2 = x2.stack.trim().match(/\n( *(at )?)/);
              prefix2 = match2 && match2[1] || "";
              suffix = -1 < x2.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
          return "\n" + prefix2 + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) return "";
          var frame = componentFrameCache.get(fn);
          if (void 0 !== frame) return frame;
          reentry = true;
          frame = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher = null;
          previousDispatcher = ReactSharedInternals.H;
          ReactSharedInternals.H = null;
          disableLogs();
          try {
            var RunInRootFrame = {
              DetermineComponentFrameRoot: function() {
                try {
                  if (construct) {
                    var Fake = function() {
                      throw Error();
                    };
                    Object.defineProperty(Fake.prototype, "props", {
                      set: function() {
                        throw Error();
                      }
                    });
                    if ("object" === typeof Reflect && Reflect.construct) {
                      try {
                        Reflect.construct(Fake, []);
                      } catch (x2) {
                        var control = x2;
                      }
                      Reflect.construct(fn, [], Fake);
                    } else {
                      try {
                        Fake.call();
                      } catch (x$0) {
                        control = x$0;
                      }
                      fn.call(Fake.prototype);
                    }
                  } else {
                    try {
                      throw Error();
                    } catch (x$1) {
                      control = x$1;
                    }
                    (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                    });
                  }
                } catch (sample2) {
                  if (sample2 && control && "string" === typeof sample2.stack)
                    return [sample2.stack, control.stack];
                }
                return [null, null];
              }
            };
            RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var namePropDescriptor = Object.getOwnPropertyDescriptor(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name"
            );
            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
              RunInRootFrame.DetermineComponentFrameRoot,
              "name",
              { value: "DetermineComponentFrameRoot" }
            );
            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
            if (sampleStack && controlStack) {
              var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
              for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
                "DetermineComponentFrameRoot"
              ); )
                namePropDescriptor++;
              for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
                "DetermineComponentFrameRoot"
              ); )
                _RunInRootFrame$Deter++;
              if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
                for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
                  _RunInRootFrame$Deter--;
              for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
                if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                  if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                    do
                      if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        var _frame = "\n" + sampleLines[namePropDescriptor].replace(
                          " at new ",
                          " at "
                        );
                        fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                        "function" === typeof fn && componentFrameCache.set(fn, _frame);
                        return _frame;
                      }
                    while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
                  }
                  break;
                }
            }
          } finally {
            reentry = false, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
          }
          sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
          "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
          return sampleLines;
        }
        function describeUnknownElementTypeFrameInDEV(type) {
          if (null == type) return "";
          if ("function" === typeof type) {
            var prototype = type.prototype;
            return describeNativeComponentFrame(
              type,
              !(!prototype || !prototype.isReactComponent)
            );
          }
          if ("string" === typeof type) return describeBuiltInComponentFrame(type);
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if ("object" === typeof type)
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE2:
                return type = describeNativeComponentFrame(type.render, false), type;
              case REACT_MEMO_TYPE2:
                return describeUnknownElementTypeFrameInDEV(type.type);
              case REACT_LAZY_TYPE:
                prototype = type._payload;
                type = type._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(type(prototype));
                } catch (x2) {
                }
            }
          return "";
        }
        function getOwner() {
          var dispatcher = ReactSharedInternals.A;
          return null === dispatcher ? null : dispatcher.getOwner();
        }
        function hasValidKey(config2) {
          if (hasOwnProperty.call(config2, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
            if (getter && getter.isReactWarning) return false;
          }
          return void 0 !== config2.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
              "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
              displayName
            ));
          }
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function elementRefGetterWithDeprecationWarning() {
          var componentName = getComponentNameFromType(this.type);
          didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
            "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
          ));
          componentName = this.props.ref;
          return void 0 !== componentName ? componentName : null;
        }
        function ReactElement2(type, key, self, source, owner, props) {
          self = props.ref;
          type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            props,
            _owner: owner
          };
          null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: false,
            get: elementRefGetterWithDeprecationWarning
          }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
          type._store = {};
          Object.defineProperty(type._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: 0
          });
          Object.defineProperty(type, "_debugInfo", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: null
          });
          Object.freeze && (Object.freeze(type.props), Object.freeze(type));
          return type;
        }
        function jsxDEVImpl(type, config2, maybeKey, isStaticChildren, source, self) {
          if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE2 || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE2 || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
            var children = config2.children;
            if (void 0 !== children)
              if (isStaticChildren)
                if (isArrayImpl(children)) {
                  for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                    validateChildKeys(children[isStaticChildren], type);
                  Object.freeze && Object.freeze(children);
                } else
                  console.error(
                    "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
                  );
              else validateChildKeys(children, type);
          } else {
            children = "";
            if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
              children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
            console.error(
              "React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",
              isStaticChildren,
              children
            );
          }
          if (hasOwnProperty.call(config2, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config2).filter(function(k) {
              return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
              'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
              isStaticChildren,
              children,
              keys,
              children
            ), didWarnAboutKeySpread[children + isStaticChildren] = true);
          }
          children = null;
          void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
          hasValidKey(config2) && (checkKeyStringCoercion(config2.key), children = "" + config2.key);
          if ("key" in config2) {
            maybeKey = {};
            for (var propName in config2)
              "key" !== propName && (maybeKey[propName] = config2[propName]);
          } else maybeKey = config2;
          children && defineKeyPropWarningGetter(
            maybeKey,
            "function" === typeof type ? type.displayName || type.name || "Unknown" : type
          );
          return ReactElement2(type, children, self, source, getOwner(), maybeKey);
        }
        function validateChildKeys(node2, parentType) {
          if ("object" === typeof node2 && node2 && node2.$$typeof !== REACT_CLIENT_REFERENCE) {
            if (isArrayImpl(node2))
              for (var i = 0; i < node2.length; i++) {
                var child = node2[i];
                isValidElement2(child) && validateExplicitKey(child, parentType);
              }
            else if (isValidElement2(node2))
              node2._store && (node2._store.validated = 1);
            else if (null === node2 || "object" !== typeof node2 ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node2[MAYBE_ITERATOR_SYMBOL] || node2["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node2.entries && (i = i.call(node2), i !== node2))
              for (; !(node2 = i.next()).done; )
                isValidElement2(node2.value) && validateExplicitKey(node2.value, parentType);
          }
        }
        function isValidElement2(object) {
          return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function validateExplicitKey(element, parentType) {
          if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
            ownerHasKeyUseWarning[parentType] = true;
            var childOwner = "";
            element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
            var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
            ReactSharedInternals.getCurrentStack = function() {
              var stack = describeUnknownElementTypeFrameInDEV(element.type);
              prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
              return stack;
            };
            console.error(
              'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
              parentType,
              childOwner
            );
            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
          }
        }
        function getCurrentComponentErrorInfo(parentType) {
          var info = "", owner = getOwner();
          owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
          info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
          return info;
        }
        var React53 = require_react(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        Symbol.for("react.provider");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE2 = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = React53.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, assign3 = Object.assign, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix2, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var didWarnAboutKeySpread = {}, ownerHasKeyUseWarning = {};
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.jsx = function(type, config2, maybeKey, source, self) {
          return jsxDEVImpl(type, config2, maybeKey, false, source, self);
        };
        exports.jsxs = function(type, config2, maybeKey, source, self) {
          return jsxDEVImpl(type, config2, maybeKey, true, source, self);
        };
      })();
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // node_modules/react-side-effect/lib/index.js
  var require_lib = __commonJS({
    "node_modules/react-side-effect/lib/index.js"(exports, module) {
      "use strict";
      function _interopDefault(ex) {
        return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
      }
      var React53 = require_react();
      var React__default = _interopDefault(React53);
      function _defineProperty3(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _inheritsLoose2(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var canUseDOM3 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
      function withSideEffect2(reducePropsToState3, handleStateChangeOnClient, mapStateOnServer3) {
        if (typeof reducePropsToState3 !== "function") {
          throw new Error("Expected reducePropsToState to be a function.");
        }
        if (typeof handleStateChangeOnClient !== "function") {
          throw new Error("Expected handleStateChangeOnClient to be a function.");
        }
        if (typeof mapStateOnServer3 !== "undefined" && typeof mapStateOnServer3 !== "function") {
          throw new Error("Expected mapStateOnServer to either be undefined or a function.");
        }
        function getDisplayName(WrappedComponent) {
          return WrappedComponent.displayName || WrappedComponent.name || "Component";
        }
        return function wrap(WrappedComponent) {
          if (typeof WrappedComponent !== "function") {
            throw new Error("Expected WrappedComponent to be a React component.");
          }
          var mountedInstances = [];
          var state;
          function emitChange() {
            state = reducePropsToState3(mountedInstances.map(function(instance) {
              return instance.props;
            }));
            if (SideEffect.canUseDOM) {
              handleStateChangeOnClient(state);
            } else if (mapStateOnServer3) {
              state = mapStateOnServer3(state);
            }
          }
          var SideEffect = /* @__PURE__ */ function(_PureComponent) {
            _inheritsLoose2(SideEffect2, _PureComponent);
            function SideEffect2() {
              return _PureComponent.apply(this, arguments) || this;
            }
            SideEffect2.peek = function peek3() {
              return state;
            };
            SideEffect2.rewind = function rewind() {
              if (SideEffect2.canUseDOM) {
                throw new Error("You may only call rewind() on the server. Call peek() to read the current state.");
              }
              var recordedState = state;
              state = void 0;
              mountedInstances = [];
              return recordedState;
            };
            var _proto = SideEffect2.prototype;
            _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {
              mountedInstances.push(this);
              emitChange();
            };
            _proto.componentDidUpdate = function componentDidUpdate() {
              emitChange();
            };
            _proto.componentWillUnmount = function componentWillUnmount() {
              var index = mountedInstances.indexOf(this);
              mountedInstances.splice(index, 1);
              emitChange();
            };
            _proto.render = function render2() {
              return React__default.createElement(WrappedComponent, this.props);
            };
            return SideEffect2;
          }(React53.PureComponent);
          _defineProperty3(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
          _defineProperty3(SideEffect, "canUseDOM", canUseDOM3);
          return SideEffect;
        };
      }
      module.exports = withSideEffect2;
    }
  });

  // node_modules/react-fast-compare/index.js
  var require_react_fast_compare = __commonJS({
    "node_modules/react-fast-compare/index.js"(exports, module) {
      var hasElementType = typeof Element !== "undefined";
      var hasMap = typeof Map === "function";
      var hasSet = typeof Set === "function";
      var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
      function equal(a, b) {
        if (a === b) return true;
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor) return false;
          var length2, i, keys;
          if (Array.isArray(a)) {
            length2 = a.length;
            if (length2 != b.length) return false;
            for (i = length2; i-- !== 0; )
              if (!equal(a[i], b[i])) return false;
            return true;
          }
          var it;
          if (hasMap && a instanceof Map && b instanceof Map) {
            if (a.size !== b.size) return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!b.has(i.value[0])) return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!equal(i.value[1], b.get(i.value[0]))) return false;
            return true;
          }
          if (hasSet && a instanceof Set && b instanceof Set) {
            if (a.size !== b.size) return false;
            it = a.entries();
            while (!(i = it.next()).done)
              if (!b.has(i.value[0])) return false;
            return true;
          }
          if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
            length2 = a.length;
            if (length2 != b.length) return false;
            for (i = length2; i-- !== 0; )
              if (a[i] !== b[i]) return false;
            return true;
          }
          if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
          if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b.valueOf === "function") return a.valueOf() === b.valueOf();
          if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b.toString === "function") return a.toString() === b.toString();
          keys = Object.keys(a);
          length2 = keys.length;
          if (length2 !== Object.keys(b).length) return false;
          for (i = length2; i-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
          if (hasElementType && a instanceof Element) return false;
          for (i = length2; i-- !== 0; ) {
            if ((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) {
              continue;
            }
            if (!equal(a[keys[i]], b[keys[i]])) return false;
          }
          return true;
        }
        return a !== a && b !== b;
      }
      module.exports = function isEqual2(a, b) {
        try {
          return equal(a, b);
        } catch (error) {
          if ((error.message || "").match(/stack|recursion/i)) {
            console.warn("react-fast-compare cannot handle circular refs");
            return false;
          }
          throw error;
        }
      };
    }
  });

  // node_modules/debounce/index.js
  var require_debounce = __commonJS({
    "node_modules/debounce/index.js"(exports, module) {
      function debounce3(function_, wait = 100, options2 = {}) {
        if (typeof function_ !== "function") {
          throw new TypeError(`Expected the first parameter to be a function, got \`${typeof function_}\`.`);
        }
        if (wait < 0) {
          throw new RangeError("`wait` must not be negative.");
        }
        const { immediate } = typeof options2 === "boolean" ? { immediate: options2 } : options2;
        let storedContext;
        let storedArguments;
        let timeoutId;
        let timestamp;
        let result;
        function run() {
          const callContext = storedContext;
          const callArguments = storedArguments;
          storedContext = void 0;
          storedArguments = void 0;
          result = function_.apply(callContext, callArguments);
          return result;
        }
        function later() {
          const last = Date.now() - timestamp;
          if (last < wait && last >= 0) {
            timeoutId = setTimeout(later, wait - last);
          } else {
            timeoutId = void 0;
            if (!immediate) {
              result = run();
            }
          }
        }
        const debounced = function(...arguments_) {
          if (storedContext && this !== storedContext && Object.getPrototypeOf(this) === Object.getPrototypeOf(storedContext)) {
            throw new Error("Debounced method called with different contexts of the same prototype.");
          }
          storedContext = this;
          storedArguments = arguments_;
          timestamp = Date.now();
          const callNow = immediate && !timeoutId;
          if (!timeoutId) {
            timeoutId = setTimeout(later, wait);
          }
          if (callNow) {
            result = run();
          }
          return result;
        };
        Object.defineProperty(debounced, "isPending", {
          get() {
            return timeoutId !== void 0;
          }
        });
        debounced.clear = () => {
          if (!timeoutId) {
            return;
          }
          clearTimeout(timeoutId);
          timeoutId = void 0;
        };
        debounced.flush = () => {
          if (!timeoutId) {
            return;
          }
          debounced.trigger();
        };
        debounced.trigger = () => {
          result = run();
          debounced.clear();
        };
        return debounced;
      }
      module.exports.debounce = debounce3;
      module.exports = debounce3;
    }
  });

  // assets/scripts/index.tsx
  var import_client = __toESM(require_client());

  // node_modules/react-redux/dist/react-redux.mjs
  var React = __toESM(require_react(), 1);
  var import_with_selector = __toESM(require_with_selector(), 1);
  var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
  var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
  var ForwardRef = REACT_FORWARD_REF_TYPE;
  var Memo = REACT_MEMO_TYPE;
  function defaultNoopBatch(callback2) {
    callback2();
  }
  function createListenerCollection() {
    let first = null;
    let last = null;
    return {
      clear() {
        first = null;
        last = null;
      },
      notify() {
        defaultNoopBatch(() => {
          let listener3 = first;
          while (listener3) {
            listener3.callback();
            listener3 = listener3.next;
          }
        });
      },
      get() {
        const listeners = [];
        let listener3 = first;
        while (listener3) {
          listeners.push(listener3);
          listener3 = listener3.next;
        }
        return listeners;
      },
      subscribe(callback2) {
        let isSubscribed = true;
        const listener3 = last = {
          callback: callback2,
          next: null,
          prev: last
        };
        if (listener3.prev) {
          listener3.prev.next = listener3;
        } else {
          first = listener3;
        }
        return function unsubscribe() {
          if (!isSubscribed || first === null) return;
          isSubscribed = false;
          if (listener3.next) {
            listener3.next.prev = listener3.prev;
          } else {
            last = listener3.prev;
          }
          if (listener3.prev) {
            listener3.prev.next = listener3.next;
          } else {
            first = listener3.next;
          }
        };
      }
    };
  }
  var nullListeners = {
    notify() {
    },
    get: () => []
  };
  function createSubscription(store2, parentSub) {
    let unsubscribe;
    let listeners = nullListeners;
    let subscriptionsAmount = 0;
    let selfSubscribed = false;
    function addNestedSub(listener3) {
      trySubscribe();
      const cleanupListener = listeners.subscribe(listener3);
      let removed = false;
      return () => {
        if (!removed) {
          removed = true;
          cleanupListener();
          tryUnsubscribe();
        }
      };
    }
    function notifyNestedSubs() {
      listeners.notify();
    }
    function handleChangeWrapper() {
      if (subscription.onStateChange) {
        subscription.onStateChange();
      }
    }
    function isSubscribed() {
      return selfSubscribed;
    }
    function trySubscribe() {
      subscriptionsAmount++;
      if (!unsubscribe) {
        unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store2.subscribe(handleChangeWrapper);
        listeners = createListenerCollection();
      }
    }
    function tryUnsubscribe() {
      subscriptionsAmount--;
      if (unsubscribe && subscriptionsAmount === 0) {
        unsubscribe();
        unsubscribe = void 0;
        listeners.clear();
        listeners = nullListeners;
      }
    }
    function trySubscribeSelf() {
      if (!selfSubscribed) {
        selfSubscribed = true;
        trySubscribe();
      }
    }
    function tryUnsubscribeSelf() {
      if (selfSubscribed) {
        selfSubscribed = false;
        tryUnsubscribe();
      }
    }
    const subscription = {
      addNestedSub,
      notifyNestedSubs,
      handleChangeWrapper,
      isSubscribed,
      trySubscribe: trySubscribeSelf,
      tryUnsubscribe: tryUnsubscribeSelf,
      getListeners: () => listeners
    };
    return subscription;
  }
  var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
  var isDOM = /* @__PURE__ */ canUseDOM();
  var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
  var isReactNative = /* @__PURE__ */ isRunningInReactNative();
  var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? React.useLayoutEffect : React.useEffect;
  var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
  function is(x2, y) {
    if (x2 === y) {
      return x2 !== 0 || y !== 0 || 1 / x2 === 1 / y;
    } else {
      return x2 !== x2 && y !== y;
    }
  }
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return true;
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for (let i = 0; i < keysA.length; i++) {
      if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }
    return true;
  }
  var FORWARD_REF_STATICS = {
    $$typeof: true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    $$typeof: true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {
    [ForwardRef]: FORWARD_REF_STATICS,
    [Memo]: MEMO_STATICS
  };
  var objectPrototype = Object.prototype;
  var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
  var gT = typeof globalThis !== "undefined" ? globalThis : (
    /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
    {}
  );
  function getContext() {
    if (!React.createContext) return {};
    const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();
    let realContext = contextMap.get(React.createContext);
    if (!realContext) {
      realContext = React.createContext(
        null
      );
      if (true) {
        realContext.displayName = "ReactRedux";
      }
      contextMap.set(React.createContext, realContext);
    }
    return realContext;
  }
  var ReactReduxContext = /* @__PURE__ */ getContext();
  function Provider(providerProps) {
    const { children, context, serverState, store: store2 } = providerProps;
    const contextValue = React.useMemo(() => {
      const subscription = createSubscription(store2);
      const baseContextValue = {
        store: store2,
        subscription,
        getServerState: serverState ? () => serverState : void 0
      };
      if (false) {
        return baseContextValue;
      } else {
        const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
        return /* @__PURE__ */ Object.assign(baseContextValue, {
          stabilityCheck,
          identityFunctionCheck
        });
      }
    }, [store2, serverState]);
    const previousState = React.useMemo(() => store2.getState(), [store2]);
    useIsomorphicLayoutEffect(() => {
      const { subscription } = contextValue;
      subscription.onStateChange = subscription.notifyNestedSubs;
      subscription.trySubscribe();
      if (previousState !== store2.getState()) {
        subscription.notifyNestedSubs();
      }
      return () => {
        subscription.tryUnsubscribe();
        subscription.onStateChange = void 0;
      };
    }, [contextValue, previousState]);
    const Context = context || ReactReduxContext;
    return /* @__PURE__ */ React.createElement(Context.Provider, { value: contextValue }, children);
  }
  var Provider_default = Provider;
  function createReduxContextHook(context = ReactReduxContext) {
    return function useReduxContext2() {
      const contextValue = React.useContext(context);
      if (!contextValue) {
        throw new Error(
          "could not find react-redux context value; please ensure the component is wrapped in a <Provider>"
        );
      }
      return contextValue;
    };
  }
  var useReduxContext = /* @__PURE__ */ createReduxContextHook();
  function createStoreHook(context = ReactReduxContext) {
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : (
      // @ts-ignore
      createReduxContextHook(context)
    );
    const useStore2 = () => {
      const { store: store2 } = useReduxContext2();
      return store2;
    };
    Object.assign(useStore2, {
      withTypes: () => useStore2
    });
    return useStore2;
  }
  var useStore = /* @__PURE__ */ createStoreHook();
  function createDispatchHook(context = ReactReduxContext) {
    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
    const useDispatch2 = () => {
      const store2 = useStore2();
      return store2.dispatch;
    };
    Object.assign(useDispatch2, {
      withTypes: () => useDispatch2
    });
    return useDispatch2;
  }
  var useDispatch = /* @__PURE__ */ createDispatchHook();
  var refEquality = (a, b) => a === b;
  function createSelectorHook(context = ReactReduxContext) {
    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
    const useSelector2 = (selector, equalityFnOrOptions = {}) => {
      const { equalityFn = refEquality } = typeof equalityFnOrOptions === "function" ? { equalityFn: equalityFnOrOptions } : equalityFnOrOptions;
      if (true) {
        if (!selector) {
          throw new Error(`You must pass a selector to useSelector`);
        }
        if (typeof selector !== "function") {
          throw new Error(`You must pass a function as a selector to useSelector`);
        }
        if (typeof equalityFn !== "function") {
          throw new Error(
            `You must pass a function as an equality function to useSelector`
          );
        }
      }
      const reduxContext = useReduxContext2();
      const { store: store2, subscription, getServerState } = reduxContext;
      const firstRun = React.useRef(true);
      const wrappedSelector = React.useCallback(
        {
          [selector.name](state) {
            const selected = selector(state);
            if (true) {
              const { devModeChecks = {} } = typeof equalityFnOrOptions === "function" ? {} : equalityFnOrOptions;
              const { identityFunctionCheck, stabilityCheck } = reduxContext;
              const {
                identityFunctionCheck: finalIdentityFunctionCheck,
                stabilityCheck: finalStabilityCheck
              } = {
                stabilityCheck,
                identityFunctionCheck,
                ...devModeChecks
              };
              if (finalStabilityCheck === "always" || finalStabilityCheck === "once" && firstRun.current) {
                const toCompare = selector(state);
                if (!equalityFn(selected, toCompare)) {
                  let stack = void 0;
                  try {
                    throw new Error();
                  } catch (e) {
                    ;
                    ({ stack } = e);
                  }
                  console.warn(
                    "Selector " + (selector.name || "unknown") + " returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization",
                    {
                      state,
                      selected,
                      selected2: toCompare,
                      stack
                    }
                  );
                }
              }
              if (finalIdentityFunctionCheck === "always" || finalIdentityFunctionCheck === "once" && firstRun.current) {
                if (selected === state) {
                  let stack = void 0;
                  try {
                    throw new Error();
                  } catch (e) {
                    ;
                    ({ stack } = e);
                  }
                  console.warn(
                    "Selector " + (selector.name || "unknown") + " returned the root state when called. This can lead to unnecessary rerenders.\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.",
                    { stack }
                  );
                }
              }
              if (firstRun.current) firstRun.current = false;
            }
            return selected;
          }
        }[selector.name],
        [selector]
      );
      const selectedState = (0, import_with_selector.useSyncExternalStoreWithSelector)(
        subscription.addNestedSub,
        store2.getState,
        getServerState || store2.getState,
        wrappedSelector,
        equalityFn
      );
      React.useDebugValue(selectedState);
      return selectedState;
    };
    Object.assign(useSelector2, {
      withTypes: () => useSelector2
    });
    return useSelector2;
  }
  var useSelector = /* @__PURE__ */ createSelectorHook();
  var batch = defaultNoopBatch;

  // node_modules/react-router/dist/development/chunk-GNGMS2XR.mjs
  var React3 = __toESM(require_react(), 1);
  var React2 = __toESM(require_react(), 1);
  var React22 = __toESM(require_react(), 1);
  var React10 = __toESM(require_react(), 1);
  var React9 = __toESM(require_react(), 1);
  var React4 = __toESM(require_react(), 1);
  var React8 = __toESM(require_react(), 1);
  var React7 = __toESM(require_react(), 1);
  var React5 = __toESM(require_react(), 1);
  var React6 = __toESM(require_react(), 1);
  var React11 = __toESM(require_react(), 1);
  var React12 = __toESM(require_react(), 1);
  var React13 = __toESM(require_react(), 1);
  var import_cookie = __toESM(require_dist(), 1);
  var import_meta = {};
  var __typeError = (msg) => {
    throw TypeError(msg);
  };
  var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
  var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
  var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  var PopStateEventType = "popstate";
  function createBrowserHistory(options2 = {}) {
    function createBrowserLocation(window2, globalHistory) {
      let { pathname, search, hash: hash2 } = window2.location;
      return createLocation(
        "",
        { pathname, search, hash: hash2 },
        // state defaults to `null` because `window.history.state` does
        globalHistory.state && globalHistory.state.usr || null,
        globalHistory.state && globalHistory.state.key || "default"
      );
    }
    function createBrowserHref(window2, to2) {
      return typeof to2 === "string" ? to2 : createPath(to2);
    }
    return getUrlBasedHistory(
      createBrowserLocation,
      createBrowserHref,
      null,
      options2
    );
  }
  function invariant(value, message) {
    if (value === false || value === null || typeof value === "undefined") {
      throw new Error(message);
    }
  }
  function warning(cond, message) {
    if (!cond) {
      if (typeof console !== "undefined") console.warn(message);
      try {
        throw new Error(message);
      } catch (e) {
      }
    }
  }
  function createKey() {
    return Math.random().toString(36).substring(2, 10);
  }
  function getHistoryState(location2, index) {
    return {
      usr: location2.state,
      key: location2.key,
      idx: index
    };
  }
  function createLocation(current2, to2, state = null, key) {
    let location2 = {
      pathname: typeof current2 === "string" ? current2 : current2.pathname,
      search: "",
      hash: "",
      ...typeof to2 === "string" ? parsePath(to2) : to2,
      state,
      // TODO: This could be cleaned up.  push/replace should probably just take
      // full Locations now and avoid the need to run through this flow at all
      // But that's a pretty big refactor to the current test suite so going to
      // keep as is for the time being and just let any incoming keys take precedence
      key: to2 && to2.key || key || createKey()
    };
    return location2;
  }
  function createPath({
    pathname = "/",
    search = "",
    hash: hash2 = ""
  }) {
    if (search && search !== "?")
      pathname += search.charAt(0) === "?" ? search : "?" + search;
    if (hash2 && hash2 !== "#")
      pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
    return pathname;
  }
  function parsePath(path) {
    let parsedPath = {};
    if (path) {
      let hashIndex = path.indexOf("#");
      if (hashIndex >= 0) {
        parsedPath.hash = path.substring(hashIndex);
        path = path.substring(0, hashIndex);
      }
      let searchIndex = path.indexOf("?");
      if (searchIndex >= 0) {
        parsedPath.search = path.substring(searchIndex);
        path = path.substring(0, searchIndex);
      }
      if (path) {
        parsedPath.pathname = path;
      }
    }
    return parsedPath;
  }
  function getUrlBasedHistory(getLocation, createHref2, validateLocation, options2 = {}) {
    let { window: window2 = document.defaultView, v5Compat = false } = options2;
    let globalHistory = window2.history;
    let action = "POP";
    let listener3 = null;
    let index = getIndex();
    if (index == null) {
      index = 0;
      globalHistory.replaceState({ ...globalHistory.state, idx: index }, "");
    }
    function getIndex() {
      let state = globalHistory.state || { idx: null };
      return state.idx;
    }
    function handlePop() {
      action = "POP";
      let nextIndex = getIndex();
      let delta = nextIndex == null ? null : nextIndex - index;
      index = nextIndex;
      if (listener3) {
        listener3({ action, location: history.location, delta });
      }
    }
    function push(to2, state) {
      action = "PUSH";
      let location2 = createLocation(history.location, to2, state);
      if (validateLocation) validateLocation(location2, to2);
      index = getIndex() + 1;
      let historyState = getHistoryState(location2, index);
      let url2 = history.createHref(location2);
      try {
        globalHistory.pushState(historyState, "", url2);
      } catch (error) {
        if (error instanceof DOMException && error.name === "DataCloneError") {
          throw error;
        }
        window2.location.assign(url2);
      }
      if (v5Compat && listener3) {
        listener3({ action, location: history.location, delta: 1 });
      }
    }
    function replace22(to2, state) {
      action = "REPLACE";
      let location2 = createLocation(history.location, to2, state);
      if (validateLocation) validateLocation(location2, to2);
      index = getIndex();
      let historyState = getHistoryState(location2, index);
      let url2 = history.createHref(location2);
      globalHistory.replaceState(historyState, "", url2);
      if (v5Compat && listener3) {
        listener3({ action, location: history.location, delta: 0 });
      }
    }
    function createURL(to2) {
      let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
      let href2 = typeof to2 === "string" ? to2 : createPath(to2);
      href2 = href2.replace(/ $/, "%20");
      invariant(
        base,
        `No window.location.(origin|href) available to create URL for href: ${href2}`
      );
      return new URL(href2, base);
    }
    let history = {
      get action() {
        return action;
      },
      get location() {
        return getLocation(window2, globalHistory);
      },
      listen(fn) {
        if (listener3) {
          throw new Error("A history only accepts one active listener");
        }
        window2.addEventListener(PopStateEventType, handlePop);
        listener3 = fn;
        return () => {
          window2.removeEventListener(PopStateEventType, handlePop);
          listener3 = null;
        };
      },
      createHref(to2) {
        return createHref2(window2, to2);
      },
      createURL,
      encodeLocation(to2) {
        let url2 = createURL(to2);
        return {
          pathname: url2.pathname,
          search: url2.search,
          hash: url2.hash
        };
      },
      push,
      replace: replace22,
      go(n) {
        return globalHistory.go(n);
      }
    };
    return history;
  }
  var _map;
  var unstable_RouterContextProvider = class {
    constructor(init) {
      __privateAdd(this, _map, /* @__PURE__ */ new Map());
      if (init) {
        for (let [context, value] of init) {
          this.set(context, value);
        }
      }
    }
    get(context) {
      if (__privateGet(this, _map).has(context)) {
        return __privateGet(this, _map).get(context);
      }
      if (context.defaultValue !== void 0) {
        return context.defaultValue;
      }
      throw new Error("No value found for context");
    }
    set(context, value) {
      __privateGet(this, _map).set(context, value);
    }
  };
  _map = /* @__PURE__ */ new WeakMap();
  var immutableRouteKeys = /* @__PURE__ */ new Set([
    "lazy",
    "caseSensitive",
    "path",
    "id",
    "index",
    "children"
  ]);
  function isIndexRoute(route) {
    return route.index === true;
  }
  function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {
    return routes.map((route, index) => {
      let treePath = [...parentPath, String(index)];
      let id = typeof route.id === "string" ? route.id : treePath.join("-");
      invariant(
        route.index !== true || !route.children,
        `Cannot specify children on an index route`
      );
      invariant(
        !manifest[id],
        `Found a route id collision on id "${id}".  Route id's must be globally unique within Data Router usages`
      );
      if (isIndexRoute(route)) {
        let indexRoute = {
          ...route,
          ...mapRouteProperties2(route),
          id
        };
        manifest[id] = indexRoute;
        return indexRoute;
      } else {
        let pathOrLayoutRoute = {
          ...route,
          ...mapRouteProperties2(route),
          id,
          children: void 0
        };
        manifest[id] = pathOrLayoutRoute;
        if (route.children) {
          pathOrLayoutRoute.children = convertRoutesToDataRoutes(
            route.children,
            mapRouteProperties2,
            treePath,
            manifest
          );
        }
        return pathOrLayoutRoute;
      }
    });
  }
  function matchRoutes(routes, locationArg, basename = "/") {
    return matchRoutesImpl(routes, locationArg, basename, false);
  }
  function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
    let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    let pathname = stripBasename(location2.pathname || "/", basename);
    if (pathname == null) {
      return null;
    }
    let branches = flattenRoutes(routes);
    rankRouteBranches(branches);
    let matches2 = null;
    for (let i = 0; matches2 == null && i < branches.length; ++i) {
      let decoded = decodePath(pathname);
      matches2 = matchRouteBranch(
        branches[i],
        decoded,
        allowPartial
      );
    }
    return matches2;
  }
  function convertRouteMatchToUiMatch(match2, loaderData) {
    let { route, pathname, params } = match2;
    return {
      id: route.id,
      pathname,
      params,
      data: loaderData[route.id],
      handle: route.handle
    };
  }
  function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
    let flattenRoute = (route, index, relativePath) => {
      let meta = {
        relativePath: relativePath === void 0 ? route.path || "" : relativePath,
        caseSensitive: route.caseSensitive === true,
        childrenIndex: index,
        route
      };
      if (meta.relativePath.startsWith("/")) {
        invariant(
          meta.relativePath.startsWith(parentPath),
          `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
        );
        meta.relativePath = meta.relativePath.slice(parentPath.length);
      }
      let path = joinPaths([parentPath, meta.relativePath]);
      let routesMeta = parentsMeta.concat(meta);
      if (route.children && route.children.length > 0) {
        invariant(
          // Our types know better, but runtime JS may not!
          // @ts-expect-error
          route.index !== true,
          `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
        );
        flattenRoutes(route.children, branches, routesMeta, path);
      }
      if (route.path == null && !route.index) {
        return;
      }
      branches.push({
        path,
        score: computeScore(path, route.index),
        routesMeta
      });
    };
    routes.forEach((route, index) => {
      if (route.path === "" || !route.path?.includes("?")) {
        flattenRoute(route, index);
      } else {
        for (let exploded of explodeOptionalSegments(route.path)) {
          flattenRoute(route, index, exploded);
        }
      }
    });
    return branches;
  }
  function explodeOptionalSegments(path) {
    let segments = path.split("/");
    if (segments.length === 0) return [];
    let [first, ...rest] = segments;
    let isOptional = first.endsWith("?");
    let required = first.replace(/\?$/, "");
    if (rest.length === 0) {
      return isOptional ? [required, ""] : [required];
    }
    let restExploded = explodeOptionalSegments(rest.join("/"));
    let result = [];
    result.push(
      ...restExploded.map(
        (subpath) => subpath === "" ? required : [required, subpath].join("/")
      )
    );
    if (isOptional) {
      result.push(...restExploded);
    }
    return result.map(
      (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
    );
  }
  function rankRouteBranches(branches) {
    branches.sort(
      (a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(
        a.routesMeta.map((meta) => meta.childrenIndex),
        b.routesMeta.map((meta) => meta.childrenIndex)
      )
    );
  }
  var paramRe = /^:[\w-]+$/;
  var dynamicSegmentValue = 3;
  var indexRouteValue = 2;
  var emptySegmentValue = 1;
  var staticSegmentValue = 10;
  var splatPenalty = -2;
  var isSplat = (s2) => s2 === "*";
  function computeScore(path, index) {
    let segments = path.split("/");
    let initialScore = segments.length;
    if (segments.some(isSplat)) {
      initialScore += splatPenalty;
    }
    if (index) {
      initialScore += indexRouteValue;
    }
    return segments.filter((s2) => !isSplat(s2)).reduce(
      (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
      initialScore
    );
  }
  function compareIndexes(a, b) {
    let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
    return siblings ? (
      // If two routes are siblings, we should try to match the earlier sibling
      // first. This allows people to have fine-grained control over the matching
      // behavior by simply putting routes with identical paths in the order they
      // want them tried.
      a[a.length - 1] - b[b.length - 1]
    ) : (
      // Otherwise, it doesn't really make sense to rank non-siblings by index,
      // so they sort equally.
      0
    );
  }
  function matchRouteBranch(branch, pathname, allowPartial = false) {
    let { routesMeta } = branch;
    let matchedParams = {};
    let matchedPathname = "/";
    let matches2 = [];
    for (let i = 0; i < routesMeta.length; ++i) {
      let meta = routesMeta[i];
      let end2 = i === routesMeta.length - 1;
      let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
      let match2 = matchPath(
        { path: meta.relativePath, caseSensitive: meta.caseSensitive, end: end2 },
        remainingPathname
      );
      let route = meta.route;
      if (!match2 && end2 && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
        match2 = matchPath(
          {
            path: meta.relativePath,
            caseSensitive: meta.caseSensitive,
            end: false
          },
          remainingPathname
        );
      }
      if (!match2) {
        return null;
      }
      Object.assign(matchedParams, match2.params);
      matches2.push({
        // TODO: Can this as be avoided?
        params: matchedParams,
        pathname: joinPaths([matchedPathname, match2.pathname]),
        pathnameBase: normalizePathname(
          joinPaths([matchedPathname, match2.pathnameBase])
        ),
        route
      });
      if (match2.pathnameBase !== "/") {
        matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
      }
    }
    return matches2;
  }
  function matchPath(pattern, pathname) {
    if (typeof pattern === "string") {
      pattern = { path: pattern, caseSensitive: false, end: true };
    }
    let [matcher, compiledParams] = compilePath(
      pattern.path,
      pattern.caseSensitive,
      pattern.end
    );
    let match2 = pathname.match(matcher);
    if (!match2) return null;
    let matchedPathname = match2[0];
    let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
    let captureGroups = match2.slice(1);
    let params = compiledParams.reduce(
      (memo22, { paramName, isOptional }, index) => {
        if (paramName === "*") {
          let splatValue = captureGroups[index] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        const value = captureGroups[index];
        if (isOptional && !value) {
          memo22[paramName] = void 0;
        } else {
          memo22[paramName] = (value || "").replace(/%2F/g, "/");
        }
        return memo22;
      },
      {}
    );
    return {
      params,
      pathname: matchedPathname,
      pathnameBase,
      pattern
    };
  }
  function compilePath(path, caseSensitive = false, end2 = true) {
    warning(
      path === "*" || !path.endsWith("*") || path.endsWith("/*"),
      `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
    );
    let params = [];
    let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
      /\/:([\w-]+)(\?)?/g,
      (_, paramName, isOptional) => {
        params.push({ paramName, isOptional: isOptional != null });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      }
    );
    if (path.endsWith("*")) {
      params.push({ paramName: "*" });
      regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
    } else if (end2) {
      regexpSource += "\\/*$";
    } else if (path !== "" && path !== "/") {
      regexpSource += "(?:(?=\\/|$))";
    } else {
    }
    let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
    return [matcher, params];
  }
  function decodePath(value) {
    try {
      return value.split("/").map((v) => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
    } catch (error) {
      warning(
        false,
        `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`
      );
      return value;
    }
  }
  function stripBasename(pathname, basename) {
    if (basename === "/") return pathname;
    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
      return null;
    }
    let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
    let nextChar = pathname.charAt(startIndex);
    if (nextChar && nextChar !== "/") {
      return null;
    }
    return pathname.slice(startIndex) || "/";
  }
  function resolvePath(to2, fromPathname = "/") {
    let {
      pathname: toPathname,
      search = "",
      hash: hash2 = ""
    } = typeof to2 === "string" ? parsePath(to2) : to2;
    let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
    return {
      pathname,
      search: normalizeSearch(search),
      hash: normalizeHash(hash2)
    };
  }
  function resolvePathname(relativePath, fromPathname) {
    let segments = fromPathname.replace(/\/+$/, "").split("/");
    let relativeSegments = relativePath.split("/");
    relativeSegments.forEach((segment) => {
      if (segment === "..") {
        if (segments.length > 1) segments.pop();
      } else if (segment !== ".") {
        segments.push(segment);
      }
    });
    return segments.length > 1 ? segments.join("/") : "/";
  }
  function getInvalidPathError(char2, field, dest, path) {
    return `Cannot include a '${char2}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
      path
    )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
  }
  function getPathContributingMatches(matches2) {
    return matches2.filter(
      (match2, index) => index === 0 || match2.route.path && match2.route.path.length > 0
    );
  }
  function getResolveToMatches(matches2) {
    let pathMatches = getPathContributingMatches(matches2);
    return pathMatches.map(
      (match2, idx) => idx === pathMatches.length - 1 ? match2.pathname : match2.pathnameBase
    );
  }
  function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
    let to2;
    if (typeof toArg === "string") {
      to2 = parsePath(toArg);
    } else {
      to2 = { ...toArg };
      invariant(
        !to2.pathname || !to2.pathname.includes("?"),
        getInvalidPathError("?", "pathname", "search", to2)
      );
      invariant(
        !to2.pathname || !to2.pathname.includes("#"),
        getInvalidPathError("#", "pathname", "hash", to2)
      );
      invariant(
        !to2.search || !to2.search.includes("#"),
        getInvalidPathError("#", "search", "hash", to2)
      );
    }
    let isEmptyPath = toArg === "" || to2.pathname === "";
    let toPathname = isEmptyPath ? "/" : to2.pathname;
    let from3;
    if (toPathname == null) {
      from3 = locationPathname;
    } else {
      let routePathnameIndex = routePathnames.length - 1;
      if (!isPathRelative && toPathname.startsWith("..")) {
        let toSegments = toPathname.split("/");
        while (toSegments[0] === "..") {
          toSegments.shift();
          routePathnameIndex -= 1;
        }
        to2.pathname = toSegments.join("/");
      }
      from3 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
    }
    let path = resolvePath(to2, from3);
    let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
    if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
      path.pathname += "/";
    }
    return path;
  }
  var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
  var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
  var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
  var normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
  var ErrorResponseImpl = class {
    constructor(status, statusText, data2, internal = false) {
      this.status = status;
      this.statusText = statusText || "";
      this.internal = internal;
      if (data2 instanceof Error) {
        this.data = data2.toString();
        this.error = data2;
      } else {
        this.data = data2;
      }
    }
  };
  function isRouteErrorResponse(error) {
    return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
  }
  var validMutationMethodsArr = [
    "POST",
    "PUT",
    "PATCH",
    "DELETE"
  ];
  var validMutationMethods = new Set(
    validMutationMethodsArr
  );
  var validRequestMethodsArr = [
    "GET",
    ...validMutationMethodsArr
  ];
  var validRequestMethods = new Set(validRequestMethodsArr);
  var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
  var redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
  var IDLE_NAVIGATION = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
  var IDLE_FETCHER = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
  var IDLE_BLOCKER = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
  };
  var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
  var defaultMapRouteProperties = (route) => ({
    hasErrorBoundary: Boolean(route.hasErrorBoundary)
  });
  var TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
  var ResetLoaderDataSymbol = Symbol("ResetLoaderData");
  function createRouter(init) {
    const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
    const isBrowser22 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
    invariant(
      init.routes.length > 0,
      "You must provide a non-empty routes array to createRouter"
    );
    let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;
    let manifest = {};
    let dataRoutes = convertRoutesToDataRoutes(
      init.routes,
      mapRouteProperties2,
      void 0,
      manifest
    );
    let inFlightDataRoutes;
    let basename = init.basename || "/";
    let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;
    let future = {
      unstable_middleware: false,
      ...init.future
    };
    let unlistenHistory = null;
    let subscribers = /* @__PURE__ */ new Set();
    let savedScrollPositions2 = null;
    let getScrollRestorationKey2 = null;
    let getScrollPosition = null;
    let initialScrollRestored = init.hydrationData != null;
    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
    let initialMatchesIsFOW = false;
    let initialErrors = null;
    if (initialMatches == null && !init.patchRoutesOnNavigation) {
      let error = getInternalRouterError(404, {
        pathname: init.history.location.pathname
      });
      let { matches: matches2, route } = getShortCircuitMatches(dataRoutes);
      initialMatches = matches2;
      initialErrors = { [route.id]: error };
    }
    if (initialMatches && !init.hydrationData) {
      let fogOfWar = checkFogOfWar(
        initialMatches,
        dataRoutes,
        init.history.location.pathname
      );
      if (fogOfWar.active) {
        initialMatches = null;
      }
    }
    let initialized;
    if (!initialMatches) {
      initialized = false;
      initialMatches = [];
      let fogOfWar = checkFogOfWar(
        null,
        dataRoutes,
        init.history.location.pathname
      );
      if (fogOfWar.active && fogOfWar.matches) {
        initialMatchesIsFOW = true;
        initialMatches = fogOfWar.matches;
      }
    } else if (initialMatches.some((m) => m.route.lazy)) {
      initialized = false;
    } else if (!initialMatches.some((m) => m.route.loader)) {
      initialized = true;
    } else {
      let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
      let errors2 = init.hydrationData ? init.hydrationData.errors : null;
      if (errors2) {
        let idx = initialMatches.findIndex(
          (m) => errors2[m.route.id] !== void 0
        );
        initialized = initialMatches.slice(0, idx + 1).every((m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors2));
      } else {
        initialized = initialMatches.every(
          (m) => !shouldLoadRouteOnHydration(m.route, loaderData, errors2)
        );
      }
    }
    let router2;
    let state = {
      historyAction: init.history.action,
      location: init.history.location,
      matches: initialMatches,
      initialized,
      navigation: IDLE_NAVIGATION,
      // Don't restore on initial updateState() if we were SSR'd
      restoreScrollPosition: init.hydrationData != null ? false : null,
      preventScrollReset: false,
      revalidation: "idle",
      loaderData: init.hydrationData && init.hydrationData.loaderData || {},
      actionData: init.hydrationData && init.hydrationData.actionData || null,
      errors: init.hydrationData && init.hydrationData.errors || initialErrors,
      fetchers: /* @__PURE__ */ new Map(),
      blockers: /* @__PURE__ */ new Map()
    };
    let pendingAction = "POP";
    let pendingPreventScrollReset = false;
    let pendingNavigationController;
    let pendingViewTransitionEnabled = false;
    let appliedViewTransitions = /* @__PURE__ */ new Map();
    let removePageHideEventListener = null;
    let isUninterruptedRevalidation = false;
    let isRevalidationRequired = false;
    let cancelledFetcherLoads = /* @__PURE__ */ new Set();
    let fetchControllers = /* @__PURE__ */ new Map();
    let incrementingLoadId = 0;
    let pendingNavigationLoadId = -1;
    let fetchReloadIds = /* @__PURE__ */ new Map();
    let fetchRedirectIds = /* @__PURE__ */ new Set();
    let fetchLoadMatches = /* @__PURE__ */ new Map();
    let activeFetchers = /* @__PURE__ */ new Map();
    let fetchersQueuedForDeletion = /* @__PURE__ */ new Set();
    let blockerFunctions = /* @__PURE__ */ new Map();
    let unblockBlockerHistoryUpdate = void 0;
    let pendingRevalidationDfd = null;
    function initialize() {
      unlistenHistory = init.history.listen(
        ({ action: historyAction, location: location2, delta }) => {
          if (unblockBlockerHistoryUpdate) {
            unblockBlockerHistoryUpdate();
            unblockBlockerHistoryUpdate = void 0;
            return;
          }
          warning(
            blockerFunctions.size === 0 || delta != null,
            "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
          );
          let blockerKey = shouldBlockNavigation({
            currentLocation: state.location,
            nextLocation: location2,
            historyAction
          });
          if (blockerKey && delta != null) {
            let nextHistoryUpdatePromise = new Promise((resolve2) => {
              unblockBlockerHistoryUpdate = resolve2;
            });
            init.history.go(delta * -1);
            updateBlocker(blockerKey, {
              state: "blocked",
              location: location2,
              proceed() {
                updateBlocker(blockerKey, {
                  state: "proceeding",
                  proceed: void 0,
                  reset: void 0,
                  location: location2
                });
                nextHistoryUpdatePromise.then(() => init.history.go(delta));
              },
              reset() {
                let blockers = new Map(state.blockers);
                blockers.set(blockerKey, IDLE_BLOCKER);
                updateState({ blockers });
              }
            });
            return;
          }
          return startNavigation(historyAction, location2);
        }
      );
      if (isBrowser22) {
        restoreAppliedTransitions(routerWindow, appliedViewTransitions);
        let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
        routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
        removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
      }
      if (!state.initialized) {
        startNavigation("POP", state.location, {
          initialHydration: true
        });
      }
      return router2;
    }
    function dispose() {
      if (unlistenHistory) {
        unlistenHistory();
      }
      if (removePageHideEventListener) {
        removePageHideEventListener();
      }
      subscribers.clear();
      pendingNavigationController && pendingNavigationController.abort();
      state.fetchers.forEach((_, key) => deleteFetcher(key));
      state.blockers.forEach((_, key) => deleteBlocker(key));
    }
    function subscribe(fn) {
      subscribers.add(fn);
      return () => subscribers.delete(fn);
    }
    function updateState(newState, opts = {}) {
      state = {
        ...state,
        ...newState
      };
      let unmountedFetchers = [];
      let mountedFetchers = [];
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (fetchersQueuedForDeletion.has(key)) {
            unmountedFetchers.push(key);
          } else {
            mountedFetchers.push(key);
          }
        }
      });
      fetchersQueuedForDeletion.forEach((key) => {
        if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
          unmountedFetchers.push(key);
        }
      });
      [...subscribers].forEach(
        (subscriber) => subscriber(state, {
          deletedFetchers: unmountedFetchers,
          viewTransitionOpts: opts.viewTransitionOpts,
          flushSync: opts.flushSync === true
        })
      );
      unmountedFetchers.forEach((key) => deleteFetcher(key));
      mountedFetchers.forEach((key) => state.fetchers.delete(key));
    }
    function completeNavigation(location2, newState, { flushSync } = {}) {
      let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && location2.state?._isRedirect !== true;
      let actionData;
      if (newState.actionData) {
        if (Object.keys(newState.actionData).length > 0) {
          actionData = newState.actionData;
        } else {
          actionData = null;
        }
      } else if (isActionReload) {
        actionData = state.actionData;
      } else {
        actionData = null;
      }
      let loaderData = newState.loaderData ? mergeLoaderData(
        state.loaderData,
        newState.loaderData,
        newState.matches || [],
        newState.errors
      ) : state.loaderData;
      let blockers = state.blockers;
      if (blockers.size > 0) {
        blockers = new Map(blockers);
        blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
      }
      let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location2.state?._isRedirect !== true;
      if (inFlightDataRoutes) {
        dataRoutes = inFlightDataRoutes;
        inFlightDataRoutes = void 0;
      }
      if (isUninterruptedRevalidation) {
      } else if (pendingAction === "POP") {
      } else if (pendingAction === "PUSH") {
        init.history.push(location2, location2.state);
      } else if (pendingAction === "REPLACE") {
        init.history.replace(location2, location2.state);
      }
      let viewTransitionOpts;
      if (pendingAction === "POP") {
        let priorPaths = appliedViewTransitions.get(state.location.pathname);
        if (priorPaths && priorPaths.has(location2.pathname)) {
          viewTransitionOpts = {
            currentLocation: state.location,
            nextLocation: location2
          };
        } else if (appliedViewTransitions.has(location2.pathname)) {
          viewTransitionOpts = {
            currentLocation: location2,
            nextLocation: state.location
          };
        }
      } else if (pendingViewTransitionEnabled) {
        let toPaths = appliedViewTransitions.get(state.location.pathname);
        if (toPaths) {
          toPaths.add(location2.pathname);
        } else {
          toPaths = /* @__PURE__ */ new Set([location2.pathname]);
          appliedViewTransitions.set(state.location.pathname, toPaths);
        }
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location2
        };
      }
      updateState(
        {
          ...newState,
          // matches, errors, fetchers go through as-is
          actionData,
          loaderData,
          historyAction: pendingAction,
          location: location2,
          initialized: true,
          navigation: IDLE_NAVIGATION,
          revalidation: "idle",
          restoreScrollPosition: getSavedScrollPosition(
            location2,
            newState.matches || state.matches
          ),
          preventScrollReset,
          blockers
        },
        {
          viewTransitionOpts,
          flushSync: flushSync === true
        }
      );
      pendingAction = "POP";
      pendingPreventScrollReset = false;
      pendingViewTransitionEnabled = false;
      isUninterruptedRevalidation = false;
      isRevalidationRequired = false;
      pendingRevalidationDfd?.resolve();
      pendingRevalidationDfd = null;
    }
    async function navigate(to2, opts) {
      if (typeof to2 === "number") {
        init.history.go(to2);
        return;
      }
      let normalizedPath = normalizeTo(
        state.location,
        state.matches,
        basename,
        to2,
        opts?.fromRouteId,
        opts?.relative
      );
      let { path, submission, error } = normalizeNavigateOptions(
        false,
        normalizedPath,
        opts
      );
      let currentLocation = state.location;
      let nextLocation = createLocation(state.location, path, opts && opts.state);
      nextLocation = {
        ...nextLocation,
        ...init.history.encodeLocation(nextLocation)
      };
      let userReplace = opts && opts.replace != null ? opts.replace : void 0;
      let historyAction = "PUSH";
      if (userReplace === true) {
        historyAction = "REPLACE";
      } else if (userReplace === false) {
      } else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
        historyAction = "REPLACE";
      }
      let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
      let flushSync = (opts && opts.flushSync) === true;
      let blockerKey = shouldBlockNavigation({
        currentLocation,
        nextLocation,
        historyAction
      });
      if (blockerKey) {
        updateBlocker(blockerKey, {
          state: "blocked",
          location: nextLocation,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: nextLocation
            });
            navigate(to2, opts);
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({ blockers });
          }
        });
        return;
      }
      await startNavigation(historyAction, nextLocation, {
        submission,
        // Send through the formData serialization error if we have one so we can
        // render at the right error boundary after we match routes
        pendingError: error,
        preventScrollReset,
        replace: opts && opts.replace,
        enableViewTransition: opts && opts.viewTransition,
        flushSync
      });
    }
    function revalidate() {
      if (!pendingRevalidationDfd) {
        pendingRevalidationDfd = createDeferred();
      }
      interruptActiveLoads();
      updateState({ revalidation: "loading" });
      let promise = pendingRevalidationDfd.promise;
      if (state.navigation.state === "submitting") {
        return promise;
      }
      if (state.navigation.state === "idle") {
        startNavigation(state.historyAction, state.location, {
          startUninterruptedRevalidation: true
        });
        return promise;
      }
      startNavigation(
        pendingAction || state.historyAction,
        state.navigation.location,
        {
          overrideNavigation: state.navigation,
          // Proxy through any rending view transition
          enableViewTransition: pendingViewTransitionEnabled === true
        }
      );
      return promise;
    }
    async function startNavigation(historyAction, location2, opts) {
      pendingNavigationController && pendingNavigationController.abort();
      pendingNavigationController = null;
      pendingAction = historyAction;
      isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
      saveScrollPosition(state.location, state.matches);
      pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
      pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let loadingNavigation = opts && opts.overrideNavigation;
      let matches2 = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (
        // `matchRoutes()` has already been called if we're in here via `router.initialize()`
        state.matches
      ) : matchRoutes(routesToUse, location2, basename);
      let flushSync = (opts && opts.flushSync) === true;
      if (matches2 && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location2) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
        completeNavigation(location2, { matches: matches2 }, { flushSync });
        return;
      }
      let fogOfWar = checkFogOfWar(matches2, routesToUse, location2.pathname);
      if (fogOfWar.active && fogOfWar.matches) {
        matches2 = fogOfWar.matches;
      }
      if (!matches2) {
        let { error, notFoundMatches, route } = handleNavigational404(
          location2.pathname
        );
        completeNavigation(
          location2,
          {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          },
          { flushSync }
        );
        return;
      }
      pendingNavigationController = new AbortController();
      let request = createClientSideRequest(
        init.history,
        location2,
        pendingNavigationController.signal,
        opts && opts.submission
      );
      let scopedContext = new unstable_RouterContextProvider(
        init.unstable_getContext ? await init.unstable_getContext() : void 0
      );
      let pendingActionResult;
      if (opts && opts.pendingError) {
        pendingActionResult = [
          findNearestBoundary(matches2).route.id,
          { type: "error", error: opts.pendingError }
        ];
      } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
        let actionResult = await handleAction(
          request,
          location2,
          opts.submission,
          matches2,
          scopedContext,
          fogOfWar.active,
          { replace: opts.replace, flushSync }
        );
        if (actionResult.shortCircuited) {
          return;
        }
        if (actionResult.pendingActionResult) {
          let [routeId, result] = actionResult.pendingActionResult;
          if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
            pendingNavigationController = null;
            completeNavigation(location2, {
              matches: actionResult.matches,
              loaderData: {},
              errors: {
                [routeId]: result.error
              }
            });
            return;
          }
        }
        matches2 = actionResult.matches || matches2;
        pendingActionResult = actionResult.pendingActionResult;
        loadingNavigation = getLoadingNavigation(location2, opts.submission);
        flushSync = false;
        fogOfWar.active = false;
        request = createClientSideRequest(
          init.history,
          request.url,
          request.signal
        );
      }
      let {
        shortCircuited,
        matches: updatedMatches,
        loaderData,
        errors: errors2
      } = await handleLoaders(
        request,
        location2,
        matches2,
        scopedContext,
        fogOfWar.active,
        loadingNavigation,
        opts && opts.submission,
        opts && opts.fetcherSubmission,
        opts && opts.replace,
        opts && opts.initialHydration === true,
        flushSync,
        pendingActionResult
      );
      if (shortCircuited) {
        return;
      }
      pendingNavigationController = null;
      completeNavigation(location2, {
        matches: updatedMatches || matches2,
        ...getActionDataForCommit(pendingActionResult),
        loaderData,
        errors: errors2
      });
    }
    async function handleAction(request, location2, submission, matches2, scopedContext, isFogOfWar, opts = {}) {
      interruptActiveLoads();
      let navigation = getSubmittingNavigation(location2, submission);
      updateState({ navigation }, { flushSync: opts.flushSync === true });
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(
          matches2,
          location2.pathname,
          request.signal
        );
        if (discoverResult.type === "aborted") {
          return { shortCircuited: true };
        } else if (discoverResult.type === "error") {
          let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
          return {
            matches: discoverResult.partialMatches,
            pendingActionResult: [
              boundaryId,
              {
                type: "error",
                error: discoverResult.error
              }
            ]
          };
        } else if (!discoverResult.matches) {
          let { notFoundMatches, error, route } = handleNavigational404(
            location2.pathname
          );
          return {
            matches: notFoundMatches,
            pendingActionResult: [
              route.id,
              {
                type: "error",
                error
              }
            ]
          };
        } else {
          matches2 = discoverResult.matches;
        }
      }
      let result;
      let actionMatch = getTargetMatch(matches2, location2);
      if (!actionMatch.route.action && !actionMatch.route.lazy) {
        result = {
          type: "error",
          error: getInternalRouterError(405, {
            method: request.method,
            pathname: location2.pathname,
            routeId: actionMatch.route.id
          })
        };
      } else {
        let results = await callDataStrategy(
          "action",
          request,
          [actionMatch],
          matches2,
          scopedContext,
          null
        );
        result = results[actionMatch.route.id];
        if (!result) {
          for (let match2 of matches2) {
            if (results[match2.route.id]) {
              result = results[match2.route.id];
              break;
            }
          }
        }
        if (request.signal.aborted) {
          return { shortCircuited: true };
        }
      }
      if (isRedirectResult(result)) {
        let replace22;
        if (opts && opts.replace != null) {
          replace22 = opts.replace;
        } else {
          let location22 = normalizeRedirectLocation(
            result.response.headers.get("Location"),
            new URL(request.url),
            basename
          );
          replace22 = location22 === state.location.pathname + state.location.search;
        }
        await startRedirectNavigation(request, result, true, {
          submission,
          replace: replace22
        });
        return { shortCircuited: true };
      }
      if (isErrorResult(result)) {
        let boundaryMatch = findNearestBoundary(matches2, actionMatch.route.id);
        if ((opts && opts.replace) !== true) {
          pendingAction = "PUSH";
        }
        return {
          matches: matches2,
          pendingActionResult: [boundaryMatch.route.id, result]
        };
      }
      return {
        matches: matches2,
        pendingActionResult: [actionMatch.route.id, result]
      };
    }
    async function handleLoaders(request, location2, matches2, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace22, initialHydration, flushSync, pendingActionResult) {
      let loadingNavigation = overrideNavigation || getLoadingNavigation(location2, submission);
      let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
      let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;
      if (isFogOfWar) {
        if (shouldUpdateNavigationState) {
          let actionData = getUpdatedActionData(pendingActionResult);
          updateState(
            {
              navigation: loadingNavigation,
              ...actionData !== void 0 ? { actionData } : {}
            },
            {
              flushSync
            }
          );
        }
        let discoverResult = await discoverRoutes(
          matches2,
          location2.pathname,
          request.signal
        );
        if (discoverResult.type === "aborted") {
          return { shortCircuited: true };
        } else if (discoverResult.type === "error") {
          let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
          return {
            matches: discoverResult.partialMatches,
            loaderData: {},
            errors: {
              [boundaryId]: discoverResult.error
            }
          };
        } else if (!discoverResult.matches) {
          let { error, notFoundMatches, route } = handleNavigational404(
            location2.pathname
          );
          return {
            matches: notFoundMatches,
            loaderData: {},
            errors: {
              [route.id]: error
            }
          };
        } else {
          matches2 = discoverResult.matches;
        }
      }
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
        init.history,
        state,
        matches2,
        activeSubmission,
        location2,
        initialHydration === true,
        isRevalidationRequired,
        cancelledFetcherLoads,
        fetchersQueuedForDeletion,
        fetchLoadMatches,
        fetchRedirectIds,
        routesToUse,
        basename,
        pendingActionResult
      );
      pendingNavigationLoadId = ++incrementingLoadId;
      if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
        let updatedFetchers2 = markFetchRedirectsDone();
        completeNavigation(
          location2,
          {
            matches: matches2,
            loaderData: {},
            // Commit pending error if we're short circuiting
            errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? { [pendingActionResult[0]]: pendingActionResult[1].error } : null,
            ...getActionDataForCommit(pendingActionResult),
            ...updatedFetchers2 ? { fetchers: new Map(state.fetchers) } : {}
          },
          { flushSync }
        );
        return { shortCircuited: true };
      }
      if (shouldUpdateNavigationState) {
        let updates = {};
        if (!isFogOfWar) {
          updates.navigation = loadingNavigation;
          let actionData = getUpdatedActionData(pendingActionResult);
          if (actionData !== void 0) {
            updates.actionData = actionData;
          }
        }
        if (revalidatingFetchers.length > 0) {
          updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
        }
        updateState(updates, { flushSync });
      }
      revalidatingFetchers.forEach((rf) => {
        abortFetcher(rf.key);
        if (rf.controller) {
          fetchControllers.set(rf.key, rf.controller);
        }
      });
      let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f) => abortFetcher(f.key));
      if (pendingNavigationController) {
        pendingNavigationController.signal.addEventListener(
          "abort",
          abortPendingFetchRevalidations
        );
      }
      let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
        matches2,
        matchesToLoad,
        revalidatingFetchers,
        request,
        scopedContext
      );
      if (request.signal.aborted) {
        return { shortCircuited: true };
      }
      if (pendingNavigationController) {
        pendingNavigationController.signal.removeEventListener(
          "abort",
          abortPendingFetchRevalidations
        );
      }
      revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));
      let redirect2 = findRedirect(loaderResults);
      if (redirect2) {
        await startRedirectNavigation(request, redirect2.result, true, {
          replace: replace22
        });
        return { shortCircuited: true };
      }
      redirect2 = findRedirect(fetcherResults);
      if (redirect2) {
        fetchRedirectIds.add(redirect2.key);
        await startRedirectNavigation(request, redirect2.result, true, {
          replace: replace22
        });
        return { shortCircuited: true };
      }
      let { loaderData, errors: errors2 } = processLoaderData(
        state,
        matches2,
        loaderResults,
        pendingActionResult,
        revalidatingFetchers,
        fetcherResults
      );
      if (initialHydration && state.errors) {
        errors2 = { ...state.errors, ...errors2 };
      }
      let updatedFetchers = markFetchRedirectsDone();
      let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
      let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
      return {
        matches: matches2,
        loaderData,
        errors: errors2,
        ...shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}
      };
    }
    function getUpdatedActionData(pendingActionResult) {
      if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
        return {
          [pendingActionResult[0]]: pendingActionResult[1].data
        };
      } else if (state.actionData) {
        if (Object.keys(state.actionData).length === 0) {
          return null;
        } else {
          return state.actionData;
        }
      }
    }
    function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
      revalidatingFetchers.forEach((rf) => {
        let fetcher = state.fetchers.get(rf.key);
        let revalidatingFetcher = getLoadingFetcher(
          void 0,
          fetcher ? fetcher.data : void 0
        );
        state.fetchers.set(rf.key, revalidatingFetcher);
      });
      return new Map(state.fetchers);
    }
    async function fetch2(key, routeId, href2, opts) {
      abortFetcher(key);
      let flushSync = (opts && opts.flushSync) === true;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let normalizedPath = normalizeTo(
        state.location,
        state.matches,
        basename,
        href2,
        routeId,
        opts?.relative
      );
      let matches2 = matchRoutes(routesToUse, normalizedPath, basename);
      let fogOfWar = checkFogOfWar(matches2, routesToUse, normalizedPath);
      if (fogOfWar.active && fogOfWar.matches) {
        matches2 = fogOfWar.matches;
      }
      if (!matches2) {
        setFetcherError(
          key,
          routeId,
          getInternalRouterError(404, { pathname: normalizedPath }),
          { flushSync }
        );
        return;
      }
      let { path, submission, error } = normalizeNavigateOptions(
        true,
        normalizedPath,
        opts
      );
      if (error) {
        setFetcherError(key, routeId, error, { flushSync });
        return;
      }
      let match2 = getTargetMatch(matches2, path);
      let scopedContext = new unstable_RouterContextProvider(
        init.unstable_getContext ? await init.unstable_getContext() : void 0
      );
      let preventScrollReset = (opts && opts.preventScrollReset) === true;
      if (submission && isMutationMethod(submission.formMethod)) {
        await handleFetcherAction(
          key,
          routeId,
          path,
          match2,
          matches2,
          scopedContext,
          fogOfWar.active,
          flushSync,
          preventScrollReset,
          submission
        );
        return;
      }
      fetchLoadMatches.set(key, { routeId, path });
      await handleFetcherLoader(
        key,
        routeId,
        path,
        match2,
        matches2,
        scopedContext,
        fogOfWar.active,
        flushSync,
        preventScrollReset,
        submission
      );
    }
    async function handleFetcherAction(key, routeId, path, match2, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
      interruptActiveLoads();
      fetchLoadMatches.delete(key);
      function detectAndHandle405Error(m) {
        if (!m.route.action && !m.route.lazy) {
          let error = getInternalRouterError(405, {
            method: submission.formMethod,
            pathname: path,
            routeId
          });
          setFetcherError(key, routeId, error, { flushSync });
          return true;
        }
        return false;
      }
      if (!isFogOfWar && detectAndHandle405Error(match2)) {
        return;
      }
      let existingFetcher = state.fetchers.get(key);
      updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
        flushSync
      });
      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(
        init.history,
        path,
        abortController.signal,
        submission
      );
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(
          requestMatches,
          path,
          fetchRequest.signal,
          key
        );
        if (discoverResult.type === "aborted") {
          return;
        } else if (discoverResult.type === "error") {
          setFetcherError(key, routeId, discoverResult.error, { flushSync });
          return;
        } else if (!discoverResult.matches) {
          setFetcherError(
            key,
            routeId,
            getInternalRouterError(404, { pathname: path }),
            { flushSync }
          );
          return;
        } else {
          requestMatches = discoverResult.matches;
          match2 = getTargetMatch(requestMatches, path);
          if (detectAndHandle405Error(match2)) {
            return;
          }
        }
      }
      fetchControllers.set(key, abortController);
      let originatingLoadId = incrementingLoadId;
      let actionResults = await callDataStrategy(
        "action",
        fetchRequest,
        [match2],
        requestMatches,
        scopedContext,
        key
      );
      let actionResult = actionResults[match2.route.id];
      if (fetchRequest.signal.aborted) {
        if (fetchControllers.get(key) === abortController) {
          fetchControllers.delete(key);
        }
        return;
      }
      if (fetchersQueuedForDeletion.has(key)) {
        if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        }
      } else {
        if (isRedirectResult(actionResult)) {
          fetchControllers.delete(key);
          if (pendingNavigationLoadId > originatingLoadId) {
            updateFetcherState(key, getDoneFetcher(void 0));
            return;
          } else {
            fetchRedirectIds.add(key);
            updateFetcherState(key, getLoadingFetcher(submission));
            return startRedirectNavigation(fetchRequest, actionResult, false, {
              fetcherSubmission: submission,
              preventScrollReset
            });
          }
        }
        if (isErrorResult(actionResult)) {
          setFetcherError(key, routeId, actionResult.error);
          return;
        }
      }
      let nextLocation = state.navigation.location || state.location;
      let revalidationRequest = createClientSideRequest(
        init.history,
        nextLocation,
        abortController.signal
      );
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let matches2 = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
      invariant(matches2, "Didn't find any matches after fetcher action");
      let loadId = ++incrementingLoadId;
      fetchReloadIds.set(key, loadId);
      let loadFetcher = getLoadingFetcher(submission, actionResult.data);
      state.fetchers.set(key, loadFetcher);
      let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
        init.history,
        state,
        matches2,
        submission,
        nextLocation,
        false,
        isRevalidationRequired,
        cancelledFetcherLoads,
        fetchersQueuedForDeletion,
        fetchLoadMatches,
        fetchRedirectIds,
        routesToUse,
        basename,
        [match2.route.id, actionResult]
      );
      revalidatingFetchers.filter((rf) => rf.key !== key).forEach((rf) => {
        let staleKey = rf.key;
        let existingFetcher2 = state.fetchers.get(staleKey);
        let revalidatingFetcher = getLoadingFetcher(
          void 0,
          existingFetcher2 ? existingFetcher2.data : void 0
        );
        state.fetchers.set(staleKey, revalidatingFetcher);
        abortFetcher(staleKey);
        if (rf.controller) {
          fetchControllers.set(staleKey, rf.controller);
        }
      });
      updateState({ fetchers: new Map(state.fetchers) });
      let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));
      abortController.signal.addEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
      let { loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(
        matches2,
        matchesToLoad,
        revalidatingFetchers,
        revalidationRequest,
        scopedContext
      );
      if (abortController.signal.aborted) {
        return;
      }
      abortController.signal.removeEventListener(
        "abort",
        abortPendingFetchRevalidations
      );
      fetchReloadIds.delete(key);
      fetchControllers.delete(key);
      revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
      let redirect2 = findRedirect(loaderResults);
      if (redirect2) {
        return startRedirectNavigation(
          revalidationRequest,
          redirect2.result,
          false,
          { preventScrollReset }
        );
      }
      redirect2 = findRedirect(fetcherResults);
      if (redirect2) {
        fetchRedirectIds.add(redirect2.key);
        return startRedirectNavigation(
          revalidationRequest,
          redirect2.result,
          false,
          { preventScrollReset }
        );
      }
      let { loaderData, errors: errors2 } = processLoaderData(
        state,
        matches2,
        loaderResults,
        void 0,
        revalidatingFetchers,
        fetcherResults
      );
      if (state.fetchers.has(key)) {
        let doneFetcher = getDoneFetcher(actionResult.data);
        state.fetchers.set(key, doneFetcher);
      }
      abortStaleFetchLoads(loadId);
      if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
        invariant(pendingAction, "Expected pending action");
        pendingNavigationController && pendingNavigationController.abort();
        completeNavigation(state.navigation.location, {
          matches: matches2,
          loaderData,
          errors: errors2,
          fetchers: new Map(state.fetchers)
        });
      } else {
        updateState({
          errors: errors2,
          loaderData: mergeLoaderData(
            state.loaderData,
            loaderData,
            matches2,
            errors2
          ),
          fetchers: new Map(state.fetchers)
        });
        isRevalidationRequired = false;
      }
    }
    async function handleFetcherLoader(key, routeId, path, match2, matches2, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
      let existingFetcher = state.fetchers.get(key);
      updateFetcherState(
        key,
        getLoadingFetcher(
          submission,
          existingFetcher ? existingFetcher.data : void 0
        ),
        { flushSync }
      );
      let abortController = new AbortController();
      let fetchRequest = createClientSideRequest(
        init.history,
        path,
        abortController.signal
      );
      if (isFogOfWar) {
        let discoverResult = await discoverRoutes(
          matches2,
          path,
          fetchRequest.signal,
          key
        );
        if (discoverResult.type === "aborted") {
          return;
        } else if (discoverResult.type === "error") {
          setFetcherError(key, routeId, discoverResult.error, { flushSync });
          return;
        } else if (!discoverResult.matches) {
          setFetcherError(
            key,
            routeId,
            getInternalRouterError(404, { pathname: path }),
            { flushSync }
          );
          return;
        } else {
          matches2 = discoverResult.matches;
          match2 = getTargetMatch(matches2, path);
        }
      }
      fetchControllers.set(key, abortController);
      let originatingLoadId = incrementingLoadId;
      let results = await callDataStrategy(
        "loader",
        fetchRequest,
        [match2],
        matches2,
        scopedContext,
        key
      );
      let result = results[match2.route.id];
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      if (fetchRequest.signal.aborted) {
        return;
      }
      if (fetchersQueuedForDeletion.has(key)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
      if (isRedirectResult(result)) {
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          await startRedirectNavigation(fetchRequest, result, false, {
            preventScrollReset
          });
          return;
        }
      }
      if (isErrorResult(result)) {
        setFetcherError(key, routeId, result.error);
        return;
      }
      updateFetcherState(key, getDoneFetcher(result.data));
    }
    async function startRedirectNavigation(request, redirect2, isNavigation, {
      submission,
      fetcherSubmission,
      preventScrollReset,
      replace: replace22
    } = {}) {
      if (redirect2.response.headers.has("X-Remix-Revalidate")) {
        isRevalidationRequired = true;
      }
      let location2 = redirect2.response.headers.get("Location");
      invariant(location2, "Expected a Location header on the redirect Response");
      location2 = normalizeRedirectLocation(
        location2,
        new URL(request.url),
        basename
      );
      let redirectLocation = createLocation(state.location, location2, {
        _isRedirect: true
      });
      if (isBrowser22) {
        let isDocumentReload = false;
        if (redirect2.response.headers.has("X-Remix-Reload-Document")) {
          isDocumentReload = true;
        } else if (ABSOLUTE_URL_REGEX.test(location2)) {
          const url2 = init.history.createURL(location2);
          isDocumentReload = // Hard reload if it's an absolute URL to a new origin
          url2.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
          stripBasename(url2.pathname, basename) == null;
        }
        if (isDocumentReload) {
          if (replace22) {
            routerWindow.location.replace(location2);
          } else {
            routerWindow.location.assign(location2);
          }
          return;
        }
      }
      pendingNavigationController = null;
      let redirectNavigationType = replace22 === true || redirect2.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH";
      let { formMethod, formAction, formEncType } = state.navigation;
      if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
        submission = getSubmissionFromNavigation(state.navigation);
      }
      let activeSubmission = submission || fetcherSubmission;
      if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
        await startNavigation(redirectNavigationType, redirectLocation, {
          submission: {
            ...activeSubmission,
            formAction: location2
          },
          // Preserve these flags across redirects
          preventScrollReset: preventScrollReset || pendingPreventScrollReset,
          enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
        });
      } else {
        let overrideNavigation = getLoadingNavigation(
          redirectLocation,
          submission
        );
        await startNavigation(redirectNavigationType, redirectLocation, {
          overrideNavigation,
          // Send fetcher submissions through for shouldRevalidate
          fetcherSubmission,
          // Preserve these flags across redirects
          preventScrollReset: preventScrollReset || pendingPreventScrollReset,
          enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
        });
      }
    }
    async function callDataStrategy(type, request, matchesToLoad, matches2, scopedContext, fetcherKey) {
      let results;
      let dataResults = {};
      try {
        results = await callDataStrategyImpl(
          dataStrategyImpl,
          type,
          request,
          matchesToLoad,
          matches2,
          fetcherKey,
          manifest,
          mapRouteProperties2,
          scopedContext,
          future.unstable_middleware
        );
      } catch (e) {
        matchesToLoad.forEach((m) => {
          dataResults[m.route.id] = {
            type: "error",
            error: e
          };
        });
        return dataResults;
      }
      for (let [routeId, result] of Object.entries(results)) {
        if (isRedirectDataStrategyResult(result)) {
          let response = result.result;
          dataResults[routeId] = {
            type: "redirect",
            response: normalizeRelativeRoutingRedirectResponse(
              response,
              request,
              routeId,
              matches2,
              basename
            )
          };
        } else {
          dataResults[routeId] = await convertDataStrategyResultToDataResult(
            result
          );
        }
      }
      return dataResults;
    }
    async function callLoadersAndMaybeResolveData(matches2, matchesToLoad, fetchersToLoad, request, scopedContext) {
      let loaderResultsPromise = callDataStrategy(
        "loader",
        request,
        matchesToLoad,
        matches2,
        scopedContext,
        null
      );
      let fetcherResultsPromise = Promise.all(
        fetchersToLoad.map(async (f) => {
          if (f.matches && f.match && f.controller) {
            let results = await callDataStrategy(
              "loader",
              createClientSideRequest(init.history, f.path, f.controller.signal),
              [f.match],
              f.matches,
              scopedContext,
              f.key
            );
            let result = results[f.match.route.id];
            return { [f.key]: result };
          } else {
            return Promise.resolve({
              [f.key]: {
                type: "error",
                error: getInternalRouterError(404, {
                  pathname: f.path
                })
              }
            });
          }
        })
      );
      let loaderResults = await loaderResultsPromise;
      let fetcherResults = (await fetcherResultsPromise).reduce(
        (acc, r2) => Object.assign(acc, r2),
        {}
      );
      return {
        loaderResults,
        fetcherResults
      };
    }
    function interruptActiveLoads() {
      isRevalidationRequired = true;
      fetchLoadMatches.forEach((_, key) => {
        if (fetchControllers.has(key)) {
          cancelledFetcherLoads.add(key);
        }
        abortFetcher(key);
      });
    }
    function updateFetcherState(key, fetcher, opts = {}) {
      state.fetchers.set(key, fetcher);
      updateState(
        { fetchers: new Map(state.fetchers) },
        { flushSync: (opts && opts.flushSync) === true }
      );
    }
    function setFetcherError(key, routeId, error, opts = {}) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      deleteFetcher(key);
      updateState(
        {
          errors: {
            [boundaryMatch.route.id]: error
          },
          fetchers: new Map(state.fetchers)
        },
        { flushSync: (opts && opts.flushSync) === true }
      );
    }
    function getFetcher(key) {
      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
      if (fetchersQueuedForDeletion.has(key)) {
        fetchersQueuedForDeletion.delete(key);
      }
      return state.fetchers.get(key) || IDLE_FETCHER;
    }
    function deleteFetcher(key) {
      let fetcher = state.fetchers.get(key);
      if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
        abortFetcher(key);
      }
      fetchLoadMatches.delete(key);
      fetchReloadIds.delete(key);
      fetchRedirectIds.delete(key);
      fetchersQueuedForDeletion.delete(key);
      cancelledFetcherLoads.delete(key);
      state.fetchers.delete(key);
    }
    function queueFetcherForDeletion(key) {
      let count = (activeFetchers.get(key) || 0) - 1;
      if (count <= 0) {
        activeFetchers.delete(key);
        fetchersQueuedForDeletion.add(key);
      } else {
        activeFetchers.set(key, count);
      }
      updateState({ fetchers: new Map(state.fetchers) });
    }
    function abortFetcher(key) {
      let controller = fetchControllers.get(key);
      if (controller) {
        controller.abort();
        fetchControllers.delete(key);
      }
    }
    function markFetchersDone(keys) {
      for (let key of keys) {
        let fetcher = getFetcher(key);
        let doneFetcher = getDoneFetcher(fetcher.data);
        state.fetchers.set(key, doneFetcher);
      }
    }
    function markFetchRedirectsDone() {
      let doneKeys = [];
      let updatedFetchers = false;
      for (let key of fetchRedirectIds) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          fetchRedirectIds.delete(key);
          doneKeys.push(key);
          updatedFetchers = true;
        }
      }
      markFetchersDone(doneKeys);
      return updatedFetchers;
    }
    function abortStaleFetchLoads(landedId) {
      let yeetedKeys = [];
      for (let [key, id] of fetchReloadIds) {
        if (id < landedId) {
          let fetcher = state.fetchers.get(key);
          invariant(fetcher, `Expected fetcher: ${key}`);
          if (fetcher.state === "loading") {
            abortFetcher(key);
            fetchReloadIds.delete(key);
            yeetedKeys.push(key);
          }
        }
      }
      markFetchersDone(yeetedKeys);
      return yeetedKeys.length > 0;
    }
    function getBlocker(key, fn) {
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;
      if (blockerFunctions.get(key) !== fn) {
        blockerFunctions.set(key, fn);
      }
      return blocker;
    }
    function deleteBlocker(key) {
      state.blockers.delete(key);
      blockerFunctions.delete(key);
    }
    function updateBlocker(key, newBlocker) {
      let blocker = state.blockers.get(key) || IDLE_BLOCKER;
      invariant(
        blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked",
        `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`
      );
      let blockers = new Map(state.blockers);
      blockers.set(key, newBlocker);
      updateState({ blockers });
    }
    function shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    }) {
      if (blockerFunctions.size === 0) {
        return;
      }
      if (blockerFunctions.size > 1) {
        warning(false, "A router only supports one blocker at a time");
      }
      let entries = Array.from(blockerFunctions.entries());
      let [blockerKey, blockerFunction] = entries[entries.length - 1];
      let blocker = state.blockers.get(blockerKey);
      if (blocker && blocker.state === "proceeding") {
        return;
      }
      if (blockerFunction({ currentLocation, nextLocation, historyAction })) {
        return blockerKey;
      }
    }
    function handleNavigational404(pathname) {
      let error = getInternalRouterError(404, { pathname });
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let { matches: matches2, route } = getShortCircuitMatches(routesToUse);
      return { notFoundMatches: matches2, route, error };
    }
    function enableScrollRestoration(positions2, getPosition, getKey) {
      savedScrollPositions2 = positions2;
      getScrollPosition = getPosition;
      getScrollRestorationKey2 = getKey || null;
      if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
        initialScrollRestored = true;
        let y = getSavedScrollPosition(state.location, state.matches);
        if (y != null) {
          updateState({ restoreScrollPosition: y });
        }
      }
      return () => {
        savedScrollPositions2 = null;
        getScrollPosition = null;
        getScrollRestorationKey2 = null;
      };
    }
    function getScrollKey(location2, matches2) {
      if (getScrollRestorationKey2) {
        let key = getScrollRestorationKey2(
          location2,
          matches2.map((m) => convertRouteMatchToUiMatch(m, state.loaderData))
        );
        return key || location2.key;
      }
      return location2.key;
    }
    function saveScrollPosition(location2, matches2) {
      if (savedScrollPositions2 && getScrollPosition) {
        let key = getScrollKey(location2, matches2);
        savedScrollPositions2[key] = getScrollPosition();
      }
    }
    function getSavedScrollPosition(location2, matches2) {
      if (savedScrollPositions2) {
        let key = getScrollKey(location2, matches2);
        let y = savedScrollPositions2[key];
        if (typeof y === "number") {
          return y;
        }
      }
      return null;
    }
    function checkFogOfWar(matches2, routesToUse, pathname) {
      if (init.patchRoutesOnNavigation) {
        if (!matches2) {
          let fogMatches = matchRoutesImpl(
            routesToUse,
            pathname,
            basename,
            true
          );
          return { active: true, matches: fogMatches || [] };
        } else {
          if (Object.keys(matches2[0].params).length > 0) {
            let partialMatches = matchRoutesImpl(
              routesToUse,
              pathname,
              basename,
              true
            );
            return { active: true, matches: partialMatches };
          }
        }
      }
      return { active: false, matches: null };
    }
    async function discoverRoutes(matches2, pathname, signal, fetcherKey) {
      if (!init.patchRoutesOnNavigation) {
        return { type: "success", matches: matches2 };
      }
      let partialMatches = matches2;
      while (true) {
        let isNonHMR = inFlightDataRoutes == null;
        let routesToUse = inFlightDataRoutes || dataRoutes;
        let localManifest = manifest;
        try {
          await init.patchRoutesOnNavigation({
            signal,
            path: pathname,
            matches: partialMatches,
            fetcherKey,
            patch: (routeId, children) => {
              if (signal.aborted) return;
              patchRoutesImpl(
                routeId,
                children,
                routesToUse,
                localManifest,
                mapRouteProperties2
              );
            }
          });
        } catch (e) {
          return { type: "error", error: e, partialMatches };
        } finally {
          if (isNonHMR && !signal.aborted) {
            dataRoutes = [...dataRoutes];
          }
        }
        if (signal.aborted) {
          return { type: "aborted" };
        }
        let newMatches = matchRoutes(routesToUse, pathname, basename);
        if (newMatches) {
          return { type: "success", matches: newMatches };
        }
        let newPartialMatches = matchRoutesImpl(
          routesToUse,
          pathname,
          basename,
          true
        );
        if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every(
          (m, i) => m.route.id === newPartialMatches[i].route.id
        )) {
          return { type: "success", matches: null };
        }
        partialMatches = newPartialMatches;
      }
    }
    function _internalSetRoutes(newRoutes) {
      manifest = {};
      inFlightDataRoutes = convertRoutesToDataRoutes(
        newRoutes,
        mapRouteProperties2,
        void 0,
        manifest
      );
    }
    function patchRoutes(routeId, children) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      patchRoutesImpl(
        routeId,
        children,
        routesToUse,
        manifest,
        mapRouteProperties2
      );
      if (isNonHMR) {
        dataRoutes = [...dataRoutes];
        updateState({});
      }
    }
    router2 = {
      get basename() {
        return basename;
      },
      get future() {
        return future;
      },
      get state() {
        return state;
      },
      get routes() {
        return dataRoutes;
      },
      get window() {
        return routerWindow;
      },
      initialize,
      subscribe,
      enableScrollRestoration,
      navigate,
      fetch: fetch2,
      revalidate,
      // Passthrough to history-aware createHref used by useHref so we get proper
      // hash-aware URLs in DOM paths
      createHref: (to2) => init.history.createHref(to2),
      encodeLocation: (to2) => init.history.encodeLocation(to2),
      getFetcher,
      deleteFetcher: queueFetcherForDeletion,
      dispose,
      getBlocker,
      deleteBlocker,
      patchRoutes,
      _internalFetchControllers: fetchControllers,
      // TODO: Remove setRoutes, it's temporary to avoid dealing with
      // updating the tree while validating the update algorithm.
      _internalSetRoutes
    };
    return router2;
  }
  function isSubmissionNavigation(opts) {
    return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
  }
  function normalizeTo(location2, matches2, basename, to2, fromRouteId, relative) {
    let contextualMatches;
    let activeRouteMatch;
    if (fromRouteId) {
      contextualMatches = [];
      for (let match2 of matches2) {
        contextualMatches.push(match2);
        if (match2.route.id === fromRouteId) {
          activeRouteMatch = match2;
          break;
        }
      }
    } else {
      contextualMatches = matches2;
      activeRouteMatch = matches2[matches2.length - 1];
    }
    let path = resolveTo(
      to2 ? to2 : ".",
      getResolveToMatches(contextualMatches),
      stripBasename(location2.pathname, basename) || location2.pathname,
      relative === "path"
    );
    if (to2 == null) {
      path.search = location2.search;
      path.hash = location2.hash;
    }
    if ((to2 == null || to2 === "" || to2 === ".") && activeRouteMatch) {
      let nakedIndex = hasNakedIndexQuery(path.search);
      if (activeRouteMatch.route.index && !nakedIndex) {
        path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
      } else if (!activeRouteMatch.route.index && nakedIndex) {
        let params = new URLSearchParams(path.search);
        let indexValues = params.getAll("index");
        params.delete("index");
        indexValues.filter((v) => v).forEach((v) => params.append("index", v));
        let qs = params.toString();
        path.search = qs ? `?${qs}` : "";
      }
    }
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    return createPath(path);
  }
  function normalizeNavigateOptions(isFetcher, path, opts) {
    if (!opts || !isSubmissionNavigation(opts)) {
      return { path };
    }
    if (opts.formMethod && !isValidMethod(opts.formMethod)) {
      return {
        path,
        error: getInternalRouterError(405, { method: opts.formMethod })
      };
    }
    let getInvalidBodyError = () => ({
      path,
      error: getInternalRouterError(400, { type: "invalid-body" })
    });
    let rawFormMethod = opts.formMethod || "get";
    let formMethod = rawFormMethod.toUpperCase();
    let formAction = stripHashFromPath(path);
    if (opts.body !== void 0) {
      if (opts.formEncType === "text/plain") {
        if (!isMutationMethod(formMethod)) {
          return getInvalidBodyError();
        }
        let text2 = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
          // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
          Array.from(opts.body.entries()).reduce(
            (acc, [name, value]) => `${acc}${name}=${value}
`,
            ""
          )
        ) : String(opts.body);
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json: void 0,
            text: text2
          }
        };
      } else if (opts.formEncType === "application/json") {
        if (!isMutationMethod(formMethod)) {
          return getInvalidBodyError();
        }
        try {
          let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
          return {
            path,
            submission: {
              formMethod,
              formAction,
              formEncType: opts.formEncType,
              formData: void 0,
              json,
              text: void 0
            }
          };
        } catch (e) {
          return getInvalidBodyError();
        }
      }
    }
    invariant(
      typeof FormData === "function",
      "FormData is not available in this environment"
    );
    let searchParams;
    let formData;
    if (opts.formData) {
      searchParams = convertFormDataToSearchParams(opts.formData);
      formData = opts.formData;
    } else if (opts.body instanceof FormData) {
      searchParams = convertFormDataToSearchParams(opts.body);
      formData = opts.body;
    } else if (opts.body instanceof URLSearchParams) {
      searchParams = opts.body;
      formData = convertSearchParamsToFormData(searchParams);
    } else if (opts.body == null) {
      searchParams = new URLSearchParams();
      formData = new FormData();
    } else {
      try {
        searchParams = new URLSearchParams(opts.body);
        formData = convertSearchParamsToFormData(searchParams);
      } catch (e) {
        return getInvalidBodyError();
      }
    }
    let submission = {
      formMethod,
      formAction,
      formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
      formData,
      json: void 0,
      text: void 0
    };
    if (isMutationMethod(submission.formMethod)) {
      return { path, submission };
    }
    let parsedPath = parsePath(path);
    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
      searchParams.append("index", "");
    }
    parsedPath.search = `?${searchParams}`;
    return { path: createPath(parsedPath), submission };
  }
  function getLoaderMatchesUntilBoundary(matches2, boundaryId, includeBoundary = false) {
    let index = matches2.findIndex((m) => m.route.id === boundaryId);
    if (index >= 0) {
      return matches2.slice(0, includeBoundary ? index + 1 : index);
    }
    return matches2;
  }
  function getMatchesToLoad(history, state, matches2, submission, location2, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
    let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
    let currentUrl = history.createURL(state.location);
    let nextUrl = history.createURL(location2);
    let boundaryMatches = matches2;
    if (initialHydration && state.errors) {
      boundaryMatches = getLoaderMatchesUntilBoundary(
        matches2,
        Object.keys(state.errors)[0],
        true
      );
    } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
      boundaryMatches = getLoaderMatchesUntilBoundary(
        matches2,
        pendingActionResult[0]
      );
    }
    let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
    let shouldSkipRevalidation = actionStatus && actionStatus >= 400;
    let navigationMatches = boundaryMatches.filter((match2, index) => {
      let { route } = match2;
      if (route.lazy) {
        return true;
      }
      if (route.loader == null) {
        return false;
      }
      if (initialHydration) {
        return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
      }
      if (isNewLoader(state.loaderData, state.matches[index], match2)) {
        return true;
      }
      let currentRouteMatch = state.matches[index];
      let nextRouteMatch = match2;
      return shouldRevalidateLoader(match2, {
        currentUrl,
        currentParams: currentRouteMatch.params,
        nextUrl,
        nextParams: nextRouteMatch.params,
        ...submission,
        actionResult,
        actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : (
          // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
          isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
          currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
        )
      });
    });
    let revalidatingFetchers = [];
    fetchLoadMatches.forEach((f, key) => {
      if (initialHydration || !matches2.some((m) => m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {
        return;
      }
      let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
      if (!fetcherMatches) {
        revalidatingFetchers.push({
          key,
          routeId: f.routeId,
          path: f.path,
          matches: null,
          match: null,
          controller: null
        });
        return;
      }
      let fetcher = state.fetchers.get(key);
      let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
      let shouldRevalidate = false;
      if (fetchRedirectIds.has(key)) {
        shouldRevalidate = false;
      } else if (cancelledFetcherLoads.has(key)) {
        cancelledFetcherLoads.delete(key);
        shouldRevalidate = true;
      } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
        shouldRevalidate = isRevalidationRequired;
      } else {
        shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {
          currentUrl,
          currentParams: state.matches[state.matches.length - 1].params,
          nextUrl,
          nextParams: matches2[matches2.length - 1].params,
          ...submission,
          actionResult,
          actionStatus,
          defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
        });
      }
      if (shouldRevalidate) {
        revalidatingFetchers.push({
          key,
          routeId: f.routeId,
          path: f.path,
          matches: fetcherMatches,
          match: fetcherMatch,
          controller: new AbortController()
        });
      }
    });
    return [navigationMatches, revalidatingFetchers];
  }
  function shouldLoadRouteOnHydration(route, loaderData, errors2) {
    if (route.lazy) {
      return true;
    }
    if (!route.loader) {
      return false;
    }
    let hasData = loaderData != null && loaderData[route.id] !== void 0;
    let hasError = errors2 != null && errors2[route.id] !== void 0;
    if (!hasData && hasError) {
      return false;
    }
    if (typeof route.loader === "function" && route.loader.hydrate === true) {
      return true;
    }
    return !hasData && !hasError;
  }
  function isNewLoader(currentLoaderData, currentMatch, match2) {
    let isNew = (
      // [a] -> [a, b]
      !currentMatch || // [a, b] -> [a, c]
      match2.route.id !== currentMatch.route.id
    );
    let isMissingData = !currentLoaderData.hasOwnProperty(match2.route.id);
    return isNew || isMissingData;
  }
  function isNewRouteInstance(currentMatch, match2) {
    let currentPath = currentMatch.route.path;
    return (
      // param change for this match, /users/123 -> /users/456
      currentMatch.pathname !== match2.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match2.params["*"]
    );
  }
  function shouldRevalidateLoader(loaderMatch, arg) {
    if (loaderMatch.route.shouldRevalidate) {
      let routeChoice = loaderMatch.route.shouldRevalidate(arg);
      if (typeof routeChoice === "boolean") {
        return routeChoice;
      }
    }
    return arg.defaultShouldRevalidate;
  }
  function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
    let childrenToPatch;
    if (routeId) {
      let route = manifest[routeId];
      invariant(
        route,
        `No route found to patch children into: routeId = ${routeId}`
      );
      if (!route.children) {
        route.children = [];
      }
      childrenToPatch = route.children;
    } else {
      childrenToPatch = routesToUse;
    }
    let uniqueChildren = children.filter(
      (newRoute) => !childrenToPatch.some(
        (existingRoute) => isSameRoute(newRoute, existingRoute)
      )
    );
    let newRoutes = convertRoutesToDataRoutes(
      uniqueChildren,
      mapRouteProperties2,
      [routeId || "_", "patch", String(childrenToPatch?.length || "0")],
      manifest
    );
    childrenToPatch.push(...newRoutes);
  }
  function isSameRoute(newRoute, existingRoute) {
    if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
      return true;
    }
    if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
      return false;
    }
    if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
      return true;
    }
    return newRoute.children.every(
      (aChild, i) => existingRoute.children?.some((bChild) => isSameRoute(aChild, bChild))
    );
  }
  async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
    if (!route.lazy) {
      return;
    }
    let lazyRoute = await route.lazy();
    if (!route.lazy) {
      return;
    }
    let routeToUpdate = manifest[route.id];
    invariant(routeToUpdate, "No route found in manifest");
    let routeUpdates = {};
    for (let lazyRouteProperty in lazyRoute) {
      let staticRouteValue = routeToUpdate[lazyRouteProperty];
      let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
      // on the route updates
      lazyRouteProperty !== "hasErrorBoundary";
      warning(
        !isPropertyStaticallyDefined,
        `Route "${routeToUpdate.id}" has a static property "${lazyRouteProperty}" defined but its lazy function is also returning a value for this property. The lazy route property "${lazyRouteProperty}" will be ignored.`
      );
      if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
        routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
      }
    }
    Object.assign(routeToUpdate, routeUpdates);
    Object.assign(routeToUpdate, {
      // To keep things framework agnostic, we use the provided `mapRouteProperties`
      // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
      // since the logic will differ between frameworks.
      ...mapRouteProperties2(routeToUpdate),
      lazy: void 0
    });
  }
  async function defaultDataStrategy(args) {
    let matchesToLoad = args.matches.filter((m) => m.shouldLoad);
    let keyedResults = {};
    let results = await Promise.all(matchesToLoad.map((m) => m.resolve()));
    results.forEach((result, i) => {
      keyedResults[matchesToLoad[i].route.id] = result;
    });
    return keyedResults;
  }
  async function defaultDataStrategyWithMiddleware(args) {
    if (!args.matches.some((m) => m.route.unstable_middleware)) {
      return defaultDataStrategy(args);
    }
    return runMiddlewarePipeline(
      args,
      false,
      () => defaultDataStrategy(args),
      (error, routeId) => ({ [routeId]: { type: "error", result: error } })
    );
  }
  async function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {
    let { matches: matches2, request, params, context } = args;
    let middlewareState = {
      handlerResult: void 0
    };
    try {
      let tuples = matches2.flatMap(
        (m) => m.route.unstable_middleware ? m.route.unstable_middleware.map((fn) => [m.route.id, fn]) : []
      );
      let result = await callRouteMiddleware(
        { request, params, context },
        tuples,
        propagateResult,
        middlewareState,
        handler
      );
      return propagateResult ? result : middlewareState.handlerResult;
    } catch (e) {
      if (!middlewareState.middlewareError) {
        throw e;
      }
      let result = await errorHandler(
        middlewareState.middlewareError.error,
        middlewareState.middlewareError.routeId
      );
      if (propagateResult || !middlewareState.handlerResult) {
        return result;
      }
      return Object.assign(middlewareState.handlerResult, result);
    }
  }
  async function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {
    let { request } = args;
    if (request.signal.aborted) {
      if (request.signal.reason) {
        throw request.signal.reason;
      }
      throw new Error(
        `Request aborted without an \`AbortSignal.reason\`: ${request.method} ${request.url}`
      );
    }
    let tuple = middlewares[idx];
    if (!tuple) {
      middlewareState.handlerResult = await handler();
      return middlewareState.handlerResult;
    }
    let [routeId, middleware2] = tuple;
    let nextCalled = false;
    let nextResult = void 0;
    let next2 = async () => {
      if (nextCalled) {
        throw new Error("You may only call `next()` once per middleware");
      }
      nextCalled = true;
      let result = await callRouteMiddleware(
        args,
        middlewares,
        propagateResult,
        middlewareState,
        handler,
        idx + 1
      );
      if (propagateResult) {
        nextResult = result;
        return nextResult;
      }
    };
    try {
      let result = await middleware2(
        {
          request: args.request,
          params: args.params,
          context: args.context
        },
        next2
      );
      if (nextCalled) {
        if (result === void 0) {
          return nextResult;
        } else {
          return result;
        }
      } else {
        return next2();
      }
    } catch (error) {
      if (!middlewareState.middlewareError) {
        middlewareState.middlewareError = { routeId, error };
      } else if (middlewareState.middlewareError.error !== error) {
        middlewareState.middlewareError = { routeId, error };
      }
      throw error;
    }
  }
  async function callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches2, fetcherKey, manifest, mapRouteProperties2, scopedContext, enableMiddleware) {
    let loadRouteDefinitionsPromises = matches2.map(
      (m) => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties2, manifest) : void 0
    );
    if (enableMiddleware) {
      await Promise.all(loadRouteDefinitionsPromises);
    }
    let dsMatches = matches2.map((match2, i) => {
      let loadRoutePromise = loadRouteDefinitionsPromises[i];
      let shouldLoad = matchesToLoad.some((m) => m.route.id === match2.route.id);
      let resolve2 = async (handlerOverride) => {
        if (handlerOverride && request.method === "GET" && (match2.route.lazy || match2.route.loader)) {
          shouldLoad = true;
        }
        return shouldLoad ? callLoaderOrAction(
          type,
          request,
          match2,
          loadRoutePromise,
          handlerOverride,
          scopedContext
        ) : Promise.resolve({ type: "data", result: void 0 });
      };
      return {
        ...match2,
        shouldLoad,
        resolve: resolve2
      };
    });
    let results = await dataStrategyImpl({
      matches: dsMatches,
      request,
      params: matches2[0].params,
      fetcherKey,
      context: scopedContext
    });
    try {
      await Promise.all(loadRouteDefinitionsPromises);
    } catch (e) {
    }
    return results;
  }
  async function callLoaderOrAction(type, request, match2, loadRoutePromise, handlerOverride, scopedContext) {
    let result;
    let onReject;
    let runHandler = (handler) => {
      let reject;
      let abortPromise = new Promise((_, r2) => reject = r2);
      onReject = () => reject();
      request.signal.addEventListener("abort", onReject);
      let actualHandler = (ctx) => {
        if (typeof handler !== "function") {
          return Promise.reject(
            new Error(
              `You cannot call the handler for a route which defines a boolean "${type}" [routeId: ${match2.route.id}]`
            )
          );
        }
        return handler(
          {
            request,
            params: match2.params,
            context: scopedContext
          },
          ...ctx !== void 0 ? [ctx] : []
        );
      };
      let handlerPromise = (async () => {
        try {
          let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
          return { type: "data", result: val };
        } catch (e) {
          return { type: "error", result: e };
        }
      })();
      return Promise.race([handlerPromise, abortPromise]);
    };
    try {
      let handler = match2.route[type];
      if (loadRoutePromise) {
        if (handler) {
          let handlerError;
          let [value] = await Promise.all([
            // If the handler throws, don't let it immediately bubble out,
            // since we need to let the lazy() execution finish so we know if this
            // route has a boundary that can handle the error
            runHandler(handler).catch((e) => {
              handlerError = e;
            }),
            loadRoutePromise
          ]);
          if (handlerError !== void 0) {
            throw handlerError;
          }
          result = value;
        } else {
          await loadRoutePromise;
          handler = match2.route[type];
          if (handler) {
            result = await runHandler(handler);
          } else if (type === "action") {
            let url2 = new URL(request.url);
            let pathname = url2.pathname + url2.search;
            throw getInternalRouterError(405, {
              method: request.method,
              pathname,
              routeId: match2.route.id
            });
          } else {
            return { type: "data", result: void 0 };
          }
        }
      } else if (!handler) {
        let url2 = new URL(request.url);
        let pathname = url2.pathname + url2.search;
        throw getInternalRouterError(404, {
          pathname
        });
      } else {
        result = await runHandler(handler);
      }
    } catch (e) {
      return { type: "error", result: e };
    } finally {
      if (onReject) {
        request.signal.removeEventListener("abort", onReject);
      }
    }
    return result;
  }
  async function convertDataStrategyResultToDataResult(dataStrategyResult) {
    let { result, type } = dataStrategyResult;
    if (isResponse(result)) {
      let data2;
      try {
        let contentType = result.headers.get("Content-Type");
        if (contentType && /\bapplication\/json\b/.test(contentType)) {
          if (result.body == null) {
            data2 = null;
          } else {
            data2 = await result.json();
          }
        } else {
          data2 = await result.text();
        }
      } catch (e) {
        return { type: "error", error: e };
      }
      if (type === "error") {
        return {
          type: "error",
          error: new ErrorResponseImpl(result.status, result.statusText, data2),
          statusCode: result.status,
          headers: result.headers
        };
      }
      return {
        type: "data",
        data: data2,
        statusCode: result.status,
        headers: result.headers
      };
    }
    if (type === "error") {
      if (isDataWithResponseInit(result)) {
        if (result.data instanceof Error) {
          return {
            type: "error",
            error: result.data,
            statusCode: result.init?.status,
            headers: result.init?.headers ? new Headers(result.init.headers) : void 0
          };
        }
        return {
          type: "error",
          error: new ErrorResponseImpl(
            result.init?.status || 500,
            void 0,
            result.data
          ),
          statusCode: isRouteErrorResponse(result) ? result.status : void 0,
          headers: result.init?.headers ? new Headers(result.init.headers) : void 0
        };
      }
      return {
        type: "error",
        error: result,
        statusCode: isRouteErrorResponse(result) ? result.status : void 0
      };
    }
    if (isDataWithResponseInit(result)) {
      return {
        type: "data",
        data: result.data,
        statusCode: result.init?.status,
        headers: result.init?.headers ? new Headers(result.init.headers) : void 0
      };
    }
    return { type: "data", data: result };
  }
  function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches2, basename) {
    let location2 = response.headers.get("Location");
    invariant(
      location2,
      "Redirects returned/thrown from loaders/actions must have a Location header"
    );
    if (!ABSOLUTE_URL_REGEX.test(location2)) {
      let trimmedMatches = matches2.slice(
        0,
        matches2.findIndex((m) => m.route.id === routeId) + 1
      );
      location2 = normalizeTo(
        new URL(request.url),
        trimmedMatches,
        basename,
        location2
      );
      response.headers.set("Location", location2);
    }
    return response;
  }
  function normalizeRedirectLocation(location2, currentUrl, basename) {
    if (ABSOLUTE_URL_REGEX.test(location2)) {
      let normalizedLocation = location2;
      let url2 = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
      let isSameBasename = stripBasename(url2.pathname, basename) != null;
      if (url2.origin === currentUrl.origin && isSameBasename) {
        return url2.pathname + url2.search + url2.hash;
      }
    }
    return location2;
  }
  function createClientSideRequest(history, location2, signal, submission) {
    let url2 = history.createURL(stripHashFromPath(location2)).toString();
    let init = { signal };
    if (submission && isMutationMethod(submission.formMethod)) {
      let { formMethod, formEncType } = submission;
      init.method = formMethod.toUpperCase();
      if (formEncType === "application/json") {
        init.headers = new Headers({ "Content-Type": formEncType });
        init.body = JSON.stringify(submission.json);
      } else if (formEncType === "text/plain") {
        init.body = submission.text;
      } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
        init.body = convertFormDataToSearchParams(submission.formData);
      } else {
        init.body = submission.formData;
      }
    }
    return new Request(url2, init);
  }
  function convertFormDataToSearchParams(formData) {
    let searchParams = new URLSearchParams();
    for (let [key, value] of formData.entries()) {
      searchParams.append(key, typeof value === "string" ? value : value.name);
    }
    return searchParams;
  }
  function convertSearchParamsToFormData(searchParams) {
    let formData = new FormData();
    for (let [key, value] of searchParams.entries()) {
      formData.append(key, value);
    }
    return formData;
  }
  function processRouteLoaderData(matches2, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {
    let loaderData = {};
    let errors2 = null;
    let statusCode;
    let foundError = false;
    let loaderHeaders = {};
    let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
    matches2.forEach((match2) => {
      if (!(match2.route.id in results)) {
        return;
      }
      let id = match2.route.id;
      let result = results[id];
      invariant(
        !isRedirectResult(result),
        "Cannot handle redirect results in processLoaderData"
      );
      if (isErrorResult(result)) {
        let error = result.error;
        if (pendingError !== void 0) {
          error = pendingError;
          pendingError = void 0;
        }
        errors2 = errors2 || {};
        if (skipLoaderErrorBubbling) {
          errors2[id] = error;
        } else {
          let boundaryMatch = findNearestBoundary(matches2, id);
          if (errors2[boundaryMatch.route.id] == null) {
            errors2[boundaryMatch.route.id] = error;
          }
        }
        if (!isStaticHandler) {
          loaderData[id] = ResetLoaderDataSymbol;
        }
        if (!foundError) {
          foundError = true;
          statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      } else {
        loaderData[id] = result.data;
        if (result.statusCode && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id] = result.headers;
        }
      }
    });
    if (pendingError !== void 0 && pendingActionResult) {
      errors2 = { [pendingActionResult[0]]: pendingError };
      loaderData[pendingActionResult[0]] = void 0;
    }
    return {
      loaderData,
      errors: errors2,
      statusCode: statusCode || 200,
      loaderHeaders
    };
  }
  function processLoaderData(state, matches2, results, pendingActionResult, revalidatingFetchers, fetcherResults) {
    let { loaderData, errors: errors2 } = processRouteLoaderData(
      matches2,
      results,
      pendingActionResult
    );
    revalidatingFetchers.forEach((rf) => {
      let { key, match: match2, controller } = rf;
      let result = fetcherResults[key];
      invariant(result, "Did not find corresponding fetcher result");
      if (controller && controller.signal.aborted) {
        return;
      } else if (isErrorResult(result)) {
        let boundaryMatch = findNearestBoundary(state.matches, match2?.route.id);
        if (!(errors2 && errors2[boundaryMatch.route.id])) {
          errors2 = {
            ...errors2,
            [boundaryMatch.route.id]: result.error
          };
        }
        state.fetchers.delete(key);
      } else if (isRedirectResult(result)) {
        invariant(false, "Unhandled fetcher revalidation redirect");
      } else {
        let doneFetcher = getDoneFetcher(result.data);
        state.fetchers.set(key, doneFetcher);
      }
    });
    return { loaderData, errors: errors2 };
  }
  function mergeLoaderData(loaderData, newLoaderData, matches2, errors2) {
    let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {
      merged[k] = v;
      return merged;
    }, {});
    for (let match2 of matches2) {
      let id = match2.route.id;
      if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match2.route.loader) {
        mergedLoaderData[id] = loaderData[id];
      }
      if (errors2 && errors2.hasOwnProperty(id)) {
        break;
      }
    }
    return mergedLoaderData;
  }
  function getActionDataForCommit(pendingActionResult) {
    if (!pendingActionResult) {
      return {};
    }
    return isErrorResult(pendingActionResult[1]) ? {
      // Clear out prior actionData on errors
      actionData: {}
    } : {
      actionData: {
        [pendingActionResult[0]]: pendingActionResult[1].data
      }
    };
  }
  function findNearestBoundary(matches2, routeId) {
    let eligibleMatches = routeId ? matches2.slice(0, matches2.findIndex((m) => m.route.id === routeId) + 1) : [...matches2];
    return eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) || matches2[0];
  }
  function getShortCircuitMatches(routes) {
    let route = routes.length === 1 ? routes[0] : routes.find((r2) => r2.index || !r2.path || r2.path === "/") || {
      id: `__shim-error-route__`
    };
    return {
      matches: [
        {
          params: {},
          pathname: "",
          pathnameBase: "",
          route
        }
      ],
      route
    };
  }
  function getInternalRouterError(status, {
    pathname,
    routeId,
    method,
    type,
    message
  } = {}) {
    let statusText = "Unknown Server Error";
    let errorMessage = "Unknown @remix-run/router error";
    if (status === 400) {
      statusText = "Bad Request";
      if (method && pathname && routeId) {
        errorMessage = `You made a ${method} request to "${pathname}" but did not provide a \`loader\` for route "${routeId}", so there is no way to handle the request.`;
      } else if (type === "invalid-body") {
        errorMessage = "Unable to encode submission body";
      }
    } else if (status === 403) {
      statusText = "Forbidden";
      errorMessage = `Route "${routeId}" does not match URL "${pathname}"`;
    } else if (status === 404) {
      statusText = "Not Found";
      errorMessage = `No route matches URL "${pathname}"`;
    } else if (status === 405) {
      statusText = "Method Not Allowed";
      if (method && pathname && routeId) {
        errorMessage = `You made a ${method.toUpperCase()} request to "${pathname}" but did not provide an \`action\` for route "${routeId}", so there is no way to handle the request.`;
      } else if (method) {
        errorMessage = `Invalid request method "${method.toUpperCase()}"`;
      }
    }
    return new ErrorResponseImpl(
      status || 500,
      statusText,
      new Error(errorMessage),
      true
    );
  }
  function findRedirect(results) {
    let entries = Object.entries(results);
    for (let i = entries.length - 1; i >= 0; i--) {
      let [key, result] = entries[i];
      if (isRedirectResult(result)) {
        return { key, result };
      }
    }
  }
  function stripHashFromPath(path) {
    let parsedPath = typeof path === "string" ? parsePath(path) : path;
    return createPath({ ...parsedPath, hash: "" });
  }
  function isHashChangeOnly(a, b) {
    if (a.pathname !== b.pathname || a.search !== b.search) {
      return false;
    }
    if (a.hash === "") {
      return b.hash !== "";
    } else if (a.hash === b.hash) {
      return true;
    } else if (b.hash !== "") {
      return true;
    }
    return false;
  }
  function isRedirectDataStrategyResult(result) {
    return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
  }
  function isErrorResult(result) {
    return result.type === "error";
  }
  function isRedirectResult(result) {
    return (result && result.type) === "redirect";
  }
  function isDataWithResponseInit(value) {
    return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
  }
  function isResponse(value) {
    return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
  }
  function isValidMethod(method) {
    return validRequestMethods.has(method.toUpperCase());
  }
  function isMutationMethod(method) {
    return validMutationMethods.has(method.toUpperCase());
  }
  function hasNakedIndexQuery(search) {
    return new URLSearchParams(search).getAll("index").some((v) => v === "");
  }
  function getTargetMatch(matches2, location2) {
    let search = typeof location2 === "string" ? parsePath(location2).search : location2.search;
    if (matches2[matches2.length - 1].route.index && hasNakedIndexQuery(search || "")) {
      return matches2[matches2.length - 1];
    }
    let pathMatches = getPathContributingMatches(matches2);
    return pathMatches[pathMatches.length - 1];
  }
  function getSubmissionFromNavigation(navigation) {
    let { formMethod, formAction, formEncType, text: text2, formData, json } = navigation;
    if (!formMethod || !formAction || !formEncType) {
      return;
    }
    if (text2 != null) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json: void 0,
        text: text2
      };
    } else if (formData != null) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData,
        json: void 0,
        text: void 0
      };
    } else if (json !== void 0) {
      return {
        formMethod,
        formAction,
        formEncType,
        formData: void 0,
        json,
        text: void 0
      };
    }
  }
  function getLoadingNavigation(location2, submission) {
    if (submission) {
      let navigation = {
        state: "loading",
        location: location2,
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text
      };
      return navigation;
    } else {
      let navigation = {
        state: "loading",
        location: location2,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
      };
      return navigation;
    }
  }
  function getSubmittingNavigation(location2, submission) {
    let navigation = {
      state: "submitting",
      location: location2,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  }
  function getLoadingFetcher(submission, data2) {
    if (submission) {
      let fetcher = {
        state: "loading",
        formMethod: submission.formMethod,
        formAction: submission.formAction,
        formEncType: submission.formEncType,
        formData: submission.formData,
        json: submission.json,
        text: submission.text,
        data: data2
      };
      return fetcher;
    } else {
      let fetcher = {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: data2
      };
      return fetcher;
    }
  }
  function getSubmittingFetcher(submission, existingFetcher) {
    let fetcher = {
      state: "submitting",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data: existingFetcher ? existingFetcher.data : void 0
    };
    return fetcher;
  }
  function getDoneFetcher(data2) {
    let fetcher = {
      state: "idle",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data: data2
    };
    return fetcher;
  }
  function restoreAppliedTransitions(_window, transitions) {
    try {
      let sessionPositions = _window.sessionStorage.getItem(
        TRANSITIONS_STORAGE_KEY
      );
      if (sessionPositions) {
        let json = JSON.parse(sessionPositions);
        for (let [k, v] of Object.entries(json || {})) {
          if (v && Array.isArray(v)) {
            transitions.set(k, new Set(v || []));
          }
        }
      }
    } catch (e) {
    }
  }
  function persistAppliedTransitions(_window, transitions) {
    if (transitions.size > 0) {
      let json = {};
      for (let [k, v] of transitions) {
        json[k] = [...v];
      }
      try {
        _window.sessionStorage.setItem(
          TRANSITIONS_STORAGE_KEY,
          JSON.stringify(json)
        );
      } catch (error) {
        warning(
          false,
          `Failed to save applied view transitions in sessionStorage (${error}).`
        );
      }
    }
  }
  function createDeferred() {
    let resolve2;
    let reject;
    let promise = new Promise((res, rej) => {
      resolve2 = async (val) => {
        res(val);
        try {
          await promise;
        } catch (e) {
        }
      };
      reject = async (error) => {
        rej(error);
        try {
          await promise;
        } catch (e) {
        }
      };
    });
    return {
      promise,
      //@ts-ignore
      resolve: resolve2,
      //@ts-ignore
      reject
    };
  }
  var DataRouterContext = React2.createContext(null);
  DataRouterContext.displayName = "DataRouter";
  var DataRouterStateContext = React2.createContext(null);
  DataRouterStateContext.displayName = "DataRouterState";
  var ViewTransitionContext = React2.createContext({
    isTransitioning: false
  });
  ViewTransitionContext.displayName = "ViewTransition";
  var FetchersContext = React2.createContext(
    /* @__PURE__ */ new Map()
  );
  FetchersContext.displayName = "Fetchers";
  var AwaitContext = React2.createContext(null);
  AwaitContext.displayName = "Await";
  var NavigationContext = React2.createContext(
    null
  );
  NavigationContext.displayName = "Navigation";
  var LocationContext = React2.createContext(
    null
  );
  LocationContext.displayName = "Location";
  var RouteContext = React2.createContext({
    outlet: null,
    matches: [],
    isDataRoute: false
  });
  RouteContext.displayName = "Route";
  var RouteErrorContext = React2.createContext(null);
  RouteErrorContext.displayName = "RouteError";
  var ENABLE_DEV_WARNINGS = true;
  function useHref(to2, { relative } = {}) {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useHref() may be used only in the context of a <Router> component.`
    );
    let { basename, navigator: navigator2 } = React22.useContext(NavigationContext);
    let { hash: hash2, pathname, search } = useResolvedPath(to2, { relative });
    let joinedPathname = pathname;
    if (basename !== "/") {
      joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
    }
    return navigator2.createHref({ pathname: joinedPathname, search, hash: hash2 });
  }
  function useInRouterContext() {
    return React22.useContext(LocationContext) != null;
  }
  function useLocation() {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useLocation() may be used only in the context of a <Router> component.`
    );
    return React22.useContext(LocationContext).location;
  }
  var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
  function useIsomorphicLayoutEffect2(cb) {
    let isStatic = React22.useContext(NavigationContext).static;
    if (!isStatic) {
      React22.useLayoutEffect(cb);
    }
  }
  function useNavigate() {
    let { isDataRoute } = React22.useContext(RouteContext);
    return isDataRoute ? useNavigateStable() : useNavigateUnstable();
  }
  function useNavigateUnstable() {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useNavigate() may be used only in the context of a <Router> component.`
    );
    let dataRouterContext = React22.useContext(DataRouterContext);
    let { basename, navigator: navigator2 } = React22.useContext(NavigationContext);
    let { matches: matches2 } = React22.useContext(RouteContext);
    let { pathname: locationPathname } = useLocation();
    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2));
    let activeRef = React22.useRef(false);
    useIsomorphicLayoutEffect2(() => {
      activeRef.current = true;
    });
    let navigate = React22.useCallback(
      (to2, options2 = {}) => {
        warning(activeRef.current, navigateEffectWarning);
        if (!activeRef.current) return;
        if (typeof to2 === "number") {
          navigator2.go(to2);
          return;
        }
        let path = resolveTo(
          to2,
          JSON.parse(routePathnamesJson),
          locationPathname,
          options2.relative === "path"
        );
        if (dataRouterContext == null && basename !== "/") {
          path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
        }
        (!!options2.replace ? navigator2.replace : navigator2.push)(
          path,
          options2.state,
          options2
        );
      },
      [
        basename,
        navigator2,
        routePathnamesJson,
        locationPathname,
        dataRouterContext
      ]
    );
    return navigate;
  }
  var OutletContext = React22.createContext(null);
  function useOutlet(context) {
    let outlet = React22.useContext(RouteContext).outlet;
    if (outlet) {
      return /* @__PURE__ */ React22.createElement(OutletContext.Provider, { value: context }, outlet);
    }
    return outlet;
  }
  function useParams() {
    let { matches: matches2 } = React22.useContext(RouteContext);
    let routeMatch = matches2[matches2.length - 1];
    return routeMatch ? routeMatch.params : {};
  }
  function useResolvedPath(to2, { relative } = {}) {
    let { matches: matches2 } = React22.useContext(RouteContext);
    let { pathname: locationPathname } = useLocation();
    let routePathnamesJson = JSON.stringify(getResolveToMatches(matches2));
    return React22.useMemo(
      () => resolveTo(
        to2,
        JSON.parse(routePathnamesJson),
        locationPathname,
        relative === "path"
      ),
      [to2, routePathnamesJson, locationPathname, relative]
    );
  }
  function useRoutesImpl(routes, locationArg, dataRouterState, future) {
    invariant(
      useInRouterContext(),
      // TODO: This error is probably because they somehow have 2 versions of the
      // router loaded. We can help them understand how to avoid that.
      `useRoutes() may be used only in the context of a <Router> component.`
    );
    let { navigator: navigator2, static: isStatic } = React22.useContext(NavigationContext);
    let { matches: parentMatches } = React22.useContext(RouteContext);
    let routeMatch = parentMatches[parentMatches.length - 1];
    let parentParams = routeMatch ? routeMatch.params : {};
    let parentPathname = routeMatch ? routeMatch.pathname : "/";
    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
    let parentRoute = routeMatch && routeMatch.route;
    if (ENABLE_DEV_WARNINGS) {
      let parentPath = parentRoute && parentRoute.path || "";
      warningOnce(
        parentPathname,
        !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
        `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
      );
    }
    let locationFromContext = useLocation();
    let location2;
    if (locationArg) {
      let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      invariant(
        parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
        `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
      );
      location2 = parsedLocationArg;
    } else {
      location2 = locationFromContext;
    }
    let pathname = location2.pathname || "/";
    let remainingPathname = pathname;
    if (parentPathnameBase !== "/") {
      let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
      let segments = pathname.replace(/^\//, "").split("/");
      remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
    }
    let matches2 = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : matchRoutes(routes, { pathname: remainingPathname });
    if (ENABLE_DEV_WARNINGS) {
      warning(
        parentRoute || matches2 != null,
        `No routes matched location "${location2.pathname}${location2.search}${location2.hash}" `
      );
      warning(
        matches2 == null || matches2[matches2.length - 1].route.element !== void 0 || matches2[matches2.length - 1].route.Component !== void 0 || matches2[matches2.length - 1].route.lazy !== void 0,
        `Matched leaf route at location "${location2.pathname}${location2.search}${location2.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
      );
    }
    let renderedMatches = _renderMatches(
      matches2 && matches2.map(
        (match2) => Object.assign({}, match2, {
          params: Object.assign({}, parentParams, match2.params),
          pathname: joinPaths([
            parentPathnameBase,
            // Re-encode pathnames that were decoded inside matchRoutes
            navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
          ]),
          pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
            parentPathnameBase,
            // Re-encode pathnames that were decoded inside matchRoutes
            navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
          ])
        })
      ),
      parentMatches,
      dataRouterState,
      future
    );
    if (locationArg && renderedMatches) {
      return /* @__PURE__ */ React22.createElement(
        LocationContext.Provider,
        {
          value: {
            location: {
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default",
              ...location2
            },
            navigationType: "POP"
            /* Pop */
          }
        },
        renderedMatches
      );
    }
    return renderedMatches;
  }
  function DefaultErrorComponent() {
    let error = useRouteError();
    let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
    let stack = error instanceof Error ? error.stack : null;
    let lightgrey = "rgba(200,200,200, 0.5)";
    let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
    let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
    let devInfo = null;
    if (ENABLE_DEV_WARNINGS) {
      console.error(
        "Error handled by React Router default ErrorBoundary:",
        error
      );
      devInfo = /* @__PURE__ */ React22.createElement(React22.Fragment, null, /* @__PURE__ */ React22.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ React22.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ React22.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ React22.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
    }
    return /* @__PURE__ */ React22.createElement(React22.Fragment, null, /* @__PURE__ */ React22.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React22.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ React22.createElement("pre", { style: preStyles }, stack) : null, devInfo);
  }
  var defaultErrorElement = /* @__PURE__ */ React22.createElement(DefaultErrorComponent, null);
  var RenderErrorBoundary = class extends React22.Component {
    constructor(props) {
      super(props);
      this.state = {
        location: props.location,
        revalidation: props.revalidation,
        error: props.error
      };
    }
    static getDerivedStateFromError(error) {
      return { error };
    }
    static getDerivedStateFromProps(props, state) {
      if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
        return {
          error: props.error,
          location: props.location,
          revalidation: props.revalidation
        };
      }
      return {
        error: props.error !== void 0 ? props.error : state.error,
        location: state.location,
        revalidation: props.revalidation || state.revalidation
      };
    }
    componentDidCatch(error, errorInfo) {
      console.error(
        "React Router caught the following error during render",
        error,
        errorInfo
      );
    }
    render() {
      return this.state.error !== void 0 ? /* @__PURE__ */ React22.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ React22.createElement(
        RouteErrorContext.Provider,
        {
          value: this.state.error,
          children: this.props.component
        }
      )) : this.props.children;
    }
  };
  function RenderedRoute({ routeContext, match: match2, children }) {
    let dataRouterContext = React22.useContext(DataRouterContext);
    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
      dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
    }
    return /* @__PURE__ */ React22.createElement(RouteContext.Provider, { value: routeContext }, children);
  }
  function _renderMatches(matches2, parentMatches = [], dataRouterState = null, future = null) {
    if (matches2 == null) {
      if (!dataRouterState) {
        return null;
      }
      if (dataRouterState.errors) {
        matches2 = dataRouterState.matches;
      } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
        matches2 = dataRouterState.matches;
      } else {
        return null;
      }
    }
    let renderedMatches = matches2;
    let errors2 = dataRouterState?.errors;
    if (errors2 != null) {
      let errorIndex = renderedMatches.findIndex(
        (m) => m.route.id && errors2?.[m.route.id] !== void 0
      );
      invariant(
        errorIndex >= 0,
        `Could not find a matching route for errors on route IDs: ${Object.keys(
          errors2
        ).join(",")}`
      );
      renderedMatches = renderedMatches.slice(
        0,
        Math.min(renderedMatches.length, errorIndex + 1)
      );
    }
    let renderFallback = false;
    let fallbackIndex = -1;
    if (dataRouterState) {
      for (let i = 0; i < renderedMatches.length; i++) {
        let match2 = renderedMatches[i];
        if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
          fallbackIndex = i;
        }
        if (match2.route.id) {
          let { loaderData, errors: errors22 } = dataRouterState;
          let needsToRunLoader = match2.route.loader && !loaderData.hasOwnProperty(match2.route.id) && (!errors22 || errors22[match2.route.id] === void 0);
          if (match2.route.lazy || needsToRunLoader) {
            renderFallback = true;
            if (fallbackIndex >= 0) {
              renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
            } else {
              renderedMatches = [renderedMatches[0]];
            }
            break;
          }
        }
      }
    }
    return renderedMatches.reduceRight((outlet, match2, index) => {
      let error;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error = errors2 && match2.route.id ? errors2[match2.route.id] : void 0;
        errorElement = match2.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index === 0) {
            warningOnce(
              "route-fallback",
              false,
              "No `HydrateFallback` element provided to render during initial hydration"
            );
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches22 = parentMatches.concat(renderedMatches.slice(0, index + 1));
      let getChildren = () => {
        let children;
        if (error) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match2.route.Component) {
          children = /* @__PURE__ */ React22.createElement(match2.route.Component, null);
        } else if (match2.route.element) {
          children = match2.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ React22.createElement(
          RenderedRoute,
          {
            match: match2,
            routeContext: {
              outlet,
              matches: matches22,
              isDataRoute: dataRouterState != null
            },
            children
          }
        );
      };
      return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index === 0) ? /* @__PURE__ */ React22.createElement(
        RenderErrorBoundary,
        {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren(),
          routeContext: { outlet: null, matches: matches22, isDataRoute: true }
        }
      ) : getChildren();
    }, null);
  }
  function getDataRouterConsoleError(hookName) {
    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
  }
  function useDataRouterContext(hookName) {
    let ctx = React22.useContext(DataRouterContext);
    invariant(ctx, getDataRouterConsoleError(hookName));
    return ctx;
  }
  function useDataRouterState(hookName) {
    let state = React22.useContext(DataRouterStateContext);
    invariant(state, getDataRouterConsoleError(hookName));
    return state;
  }
  function useRouteContext(hookName) {
    let route = React22.useContext(RouteContext);
    invariant(route, getDataRouterConsoleError(hookName));
    return route;
  }
  function useCurrentRouteId(hookName) {
    let route = useRouteContext(hookName);
    let thisRoute = route.matches[route.matches.length - 1];
    invariant(
      thisRoute.route.id,
      `${hookName} can only be used on routes that contain a unique "id"`
    );
    return thisRoute.route.id;
  }
  function useRouteId() {
    return useCurrentRouteId(
      "useRouteId"
      /* UseRouteId */
    );
  }
  function useNavigation() {
    let state = useDataRouterState(
      "useNavigation"
      /* UseNavigation */
    );
    return state.navigation;
  }
  function useMatches() {
    let { matches: matches2, loaderData } = useDataRouterState(
      "useMatches"
      /* UseMatches */
    );
    return React22.useMemo(
      () => matches2.map((m) => convertRouteMatchToUiMatch(m, loaderData)),
      [matches2, loaderData]
    );
  }
  function useRouteError() {
    let error = React22.useContext(RouteErrorContext);
    let state = useDataRouterState(
      "useRouteError"
      /* UseRouteError */
    );
    let routeId = useCurrentRouteId(
      "useRouteError"
      /* UseRouteError */
    );
    if (error !== void 0) {
      return error;
    }
    return state.errors?.[routeId];
  }
  function useNavigateStable() {
    let { router: router2 } = useDataRouterContext(
      "useNavigate"
      /* UseNavigateStable */
    );
    let id = useCurrentRouteId(
      "useNavigate"
      /* UseNavigateStable */
    );
    let activeRef = React22.useRef(false);
    useIsomorphicLayoutEffect2(() => {
      activeRef.current = true;
    });
    let navigate = React22.useCallback(
      async (to2, options2 = {}) => {
        warning(activeRef.current, navigateEffectWarning);
        if (!activeRef.current) return;
        if (typeof to2 === "number") {
          router2.navigate(to2);
        } else {
          await router2.navigate(to2, { fromRouteId: id, ...options2 });
        }
      },
      [router2, id]
    );
    return navigate;
  }
  var alreadyWarned = {};
  function warningOnce(key, cond, message) {
    if (!cond && !alreadyWarned[key]) {
      alreadyWarned[key] = true;
      warning(false, message);
    }
  }
  var alreadyWarned2 = {};
  function warnOnce(condition, message) {
    if (!condition && !alreadyWarned2[message]) {
      alreadyWarned2[message] = true;
      console.warn(message);
    }
  }
  var ENABLE_DEV_WARNINGS2 = true;
  function mapRouteProperties(route) {
    let updates = {
      // Note: this check also occurs in createRoutesFromChildren so update
      // there if you change this -- please and thank you!
      hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null
    };
    if (route.Component) {
      if (ENABLE_DEV_WARNINGS2) {
        if (route.element) {
          warning(
            false,
            "You should not include both `Component` and `element` on your route - `Component` will be used."
          );
        }
      }
      Object.assign(updates, {
        element: React3.createElement(route.Component),
        Component: void 0
      });
    }
    if (route.HydrateFallback) {
      if (ENABLE_DEV_WARNINGS2) {
        if (route.hydrateFallbackElement) {
          warning(
            false,
            "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
          );
        }
      }
      Object.assign(updates, {
        hydrateFallbackElement: React3.createElement(route.HydrateFallback),
        HydrateFallback: void 0
      });
    }
    if (route.ErrorBoundary) {
      if (ENABLE_DEV_WARNINGS2) {
        if (route.errorElement) {
          warning(
            false,
            "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
          );
        }
      }
      Object.assign(updates, {
        errorElement: React3.createElement(route.ErrorBoundary),
        ErrorBoundary: void 0
      });
    }
    return updates;
  }
  var Deferred = class {
    constructor() {
      this.status = "pending";
      this.promise = new Promise((resolve2, reject) => {
        this.resolve = (value) => {
          if (this.status === "pending") {
            this.status = "resolved";
            resolve2(value);
          }
        };
        this.reject = (reason) => {
          if (this.status === "pending") {
            this.status = "rejected";
            reject(reason);
          }
        };
      });
    }
  };
  function RouterProvider({
    router: router2,
    flushSync: reactDomFlushSyncImpl
  }) {
    let [state, setStateImpl] = React3.useState(router2.state);
    let [pendingState, setPendingState] = React3.useState();
    let [vtContext, setVtContext] = React3.useState({
      isTransitioning: false
    });
    let [renderDfd, setRenderDfd] = React3.useState();
    let [transition, setTransition] = React3.useState();
    let [interruption, setInterruption] = React3.useState();
    let fetcherData = React3.useRef(/* @__PURE__ */ new Map());
    let setState = React3.useCallback(
      (newState, { deletedFetchers, flushSync, viewTransitionOpts }) => {
        newState.fetchers.forEach((fetcher, key) => {
          if (fetcher.data !== void 0) {
            fetcherData.current.set(key, fetcher.data);
          }
        });
        deletedFetchers.forEach((key) => fetcherData.current.delete(key));
        warnOnce(
          flushSync === false || reactDomFlushSyncImpl != null,
          'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
        );
        let isViewTransitionAvailable = router2.window != null && router2.window.document != null && typeof router2.window.document.startViewTransition === "function";
        warnOnce(
          viewTransitionOpts == null || isViewTransitionAvailable,
          "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
        );
        if (!viewTransitionOpts || !isViewTransitionAvailable) {
          if (reactDomFlushSyncImpl && flushSync) {
            reactDomFlushSyncImpl(() => setStateImpl(newState));
          } else {
            React3.startTransition(() => setStateImpl(newState));
          }
          return;
        }
        if (reactDomFlushSyncImpl && flushSync) {
          reactDomFlushSyncImpl(() => {
            if (transition) {
              renderDfd && renderDfd.resolve();
              transition.skipTransition();
            }
            setVtContext({
              isTransitioning: true,
              flushSync: true,
              currentLocation: viewTransitionOpts.currentLocation,
              nextLocation: viewTransitionOpts.nextLocation
            });
          });
          let t2 = router2.window.document.startViewTransition(() => {
            reactDomFlushSyncImpl(() => setStateImpl(newState));
          });
          t2.finished.finally(() => {
            reactDomFlushSyncImpl(() => {
              setRenderDfd(void 0);
              setTransition(void 0);
              setPendingState(void 0);
              setVtContext({ isTransitioning: false });
            });
          });
          reactDomFlushSyncImpl(() => setTransition(t2));
          return;
        }
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
          setInterruption({
            state: newState,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        } else {
          setPendingState(newState);
          setVtContext({
            isTransitioning: true,
            flushSync: false,
            currentLocation: viewTransitionOpts.currentLocation,
            nextLocation: viewTransitionOpts.nextLocation
          });
        }
      },
      [router2.window, reactDomFlushSyncImpl, transition, renderDfd]
    );
    React3.useLayoutEffect(() => router2.subscribe(setState), [router2, setState]);
    React3.useEffect(() => {
      if (vtContext.isTransitioning && !vtContext.flushSync) {
        setRenderDfd(new Deferred());
      }
    }, [vtContext]);
    React3.useEffect(() => {
      if (renderDfd && pendingState && router2.window) {
        let newState = pendingState;
        let renderPromise = renderDfd.promise;
        let transition2 = router2.window.document.startViewTransition(async () => {
          React3.startTransition(() => setStateImpl(newState));
          await renderPromise;
        });
        transition2.finished.finally(() => {
          setRenderDfd(void 0);
          setTransition(void 0);
          setPendingState(void 0);
          setVtContext({ isTransitioning: false });
        });
        setTransition(transition2);
      }
    }, [pendingState, renderDfd, router2.window]);
    React3.useEffect(() => {
      if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
        renderDfd.resolve();
      }
    }, [renderDfd, transition, state.location, pendingState]);
    React3.useEffect(() => {
      if (!vtContext.isTransitioning && interruption) {
        setPendingState(interruption.state);
        setVtContext({
          isTransitioning: true,
          flushSync: false,
          currentLocation: interruption.currentLocation,
          nextLocation: interruption.nextLocation
        });
        setInterruption(void 0);
      }
    }, [vtContext.isTransitioning, interruption]);
    let navigator2 = React3.useMemo(() => {
      return {
        createHref: router2.createHref,
        encodeLocation: router2.encodeLocation,
        go: (n) => router2.navigate(n),
        push: (to2, state2, opts) => router2.navigate(to2, {
          state: state2,
          preventScrollReset: opts?.preventScrollReset
        }),
        replace: (to2, state2, opts) => router2.navigate(to2, {
          replace: true,
          state: state2,
          preventScrollReset: opts?.preventScrollReset
        })
      };
    }, [router2]);
    let basename = router2.basename || "/";
    let dataRouterContext = React3.useMemo(
      () => ({
        router: router2,
        navigator: navigator2,
        static: false,
        basename
      }),
      [router2, navigator2, basename]
    );
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(DataRouterContext.Provider, { value: dataRouterContext }, /* @__PURE__ */ React3.createElement(DataRouterStateContext.Provider, { value: state }, /* @__PURE__ */ React3.createElement(FetchersContext.Provider, { value: fetcherData.current }, /* @__PURE__ */ React3.createElement(ViewTransitionContext.Provider, { value: vtContext }, /* @__PURE__ */ React3.createElement(
      Router,
      {
        basename,
        location: state.location,
        navigationType: state.historyAction,
        navigator: navigator2
      },
      /* @__PURE__ */ React3.createElement(
        MemoizedDataRoutes,
        {
          routes: router2.routes,
          future: router2.future,
          state
        }
      )
    ))))), null);
  }
  var MemoizedDataRoutes = React3.memo(DataRoutes);
  function DataRoutes({
    routes,
    future,
    state
  }) {
    return useRoutesImpl(routes, void 0, state, future);
  }
  function Outlet(props) {
    return useOutlet(props.context);
  }
  function Router({
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = "POP",
    navigator: navigator2,
    static: staticProp = false
  }) {
    invariant(
      !useInRouterContext(),
      `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
    );
    let basename = basenameProp.replace(/^\/*/, "/");
    let navigationContext = React3.useMemo(
      () => ({
        basename,
        navigator: navigator2,
        static: staticProp,
        future: {}
      }),
      [basename, navigator2, staticProp]
    );
    if (typeof locationProp === "string") {
      locationProp = parsePath(locationProp);
    }
    let {
      pathname = "/",
      search = "",
      hash: hash2 = "",
      state = null,
      key = "default"
    } = locationProp;
    let locationContext = React3.useMemo(() => {
      let trailingPathname = stripBasename(pathname, basename);
      if (trailingPathname == null) {
        return null;
      }
      return {
        location: {
          pathname: trailingPathname,
          search,
          hash: hash2,
          state,
          key
        },
        navigationType
      };
    }, [basename, pathname, search, hash2, state, key, navigationType]);
    warning(
      locationContext != null,
      `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash2}" because it does not start with the basename, so the <Router> won't render anything.`
    );
    if (locationContext == null) {
      return null;
    }
    return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, { children, value: locationContext }));
  }
  var defaultMethod = "get";
  var defaultEncType = "application/x-www-form-urlencoded";
  function isHtmlElement(object) {
    return object != null && typeof object.tagName === "string";
  }
  function isButtonElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
  }
  function isFormElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
  }
  function isInputElement(object) {
    return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
  }
  function isModifiedEvent(event) {
    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
  }
  function shouldProcessLinkClick(event, target) {
    return event.button === 0 && // Ignore everything but left clicks
    (!target || target === "_self") && // Let browser handle "target=_blank" etc.
    !isModifiedEvent(event);
  }
  function createSearchParams(init = "") {
    return new URLSearchParams(
      typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo22, key) => {
        let value = init[key];
        return memo22.concat(
          Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]
        );
      }, [])
    );
  }
  function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
    let searchParams = createSearchParams(locationSearch);
    if (defaultSearchParams) {
      defaultSearchParams.forEach((_, key) => {
        if (!searchParams.has(key)) {
          defaultSearchParams.getAll(key).forEach((value) => {
            searchParams.append(key, value);
          });
        }
      });
    }
    return searchParams;
  }
  var _formDataSupportsSubmitter = null;
  function isFormDataSubmitterSupported() {
    if (_formDataSupportsSubmitter === null) {
      try {
        new FormData(
          document.createElement("form"),
          // @ts-expect-error if FormData supports the submitter parameter, this will throw
          0
        );
        _formDataSupportsSubmitter = false;
      } catch (e) {
        _formDataSupportsSubmitter = true;
      }
    }
    return _formDataSupportsSubmitter;
  }
  var supportedFormEncTypes = /* @__PURE__ */ new Set([
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  ]);
  function getFormEncType(encType) {
    if (encType != null && !supportedFormEncTypes.has(encType)) {
      warning(
        false,
        `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
      );
      return null;
    }
    return encType;
  }
  function getFormSubmissionInfo(target, basename) {
    let method;
    let action;
    let encType;
    let formData;
    let body;
    if (isFormElement(target)) {
      let attr = target.getAttribute("action");
      action = attr ? stripBasename(attr, basename) : null;
      method = target.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(target);
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null) {
        throw new Error(
          `Cannot submit a <button> or <input type="submit"> without a <form>`
        );
      }
      let attr = target.getAttribute("formaction") || form.getAttribute("action");
      action = attr ? stripBasename(attr, basename) : null;
      method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
      encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
      formData = new FormData(form, target);
      if (!isFormDataSubmitterSupported()) {
        let { name, type, value } = target;
        if (type === "image") {
          let prefix2 = name ? `${name}.` : "";
          formData.append(`${prefix2}x`, "0");
          formData.append(`${prefix2}y`, "0");
        } else if (name) {
          formData.append(name, value);
        }
      }
    } else if (isHtmlElement(target)) {
      throw new Error(
        `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
      );
    } else {
      method = defaultMethod;
      action = null;
      encType = defaultEncType;
      body = target;
    }
    if (formData && encType === "text/plain") {
      body = formData;
      formData = void 0;
    }
    return { action, method: method.toLowerCase(), encType, formData, body };
  }
  function invariant2(value, message) {
    if (value === false || value === null || typeof value === "undefined") {
      throw new Error(message);
    }
  }
  async function loadRouteModule(route, routeModulesCache) {
    if (route.id in routeModulesCache) {
      return routeModulesCache[route.id];
    }
    try {
      let routeModule = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        route.module
      );
      routeModulesCache[route.id] = routeModule;
      return routeModule;
    } catch (error) {
      console.error(
        `Error loading route module \`${route.module}\`, reloading page...`
      );
      console.error(error);
      if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
      import_meta.hot) {
        throw error;
      }
      window.location.reload();
      return new Promise(() => {
      });
    }
  }
  function isPageLinkDescriptor(object) {
    return object != null && typeof object.page === "string";
  }
  function isHtmlLinkDescriptor(object) {
    if (object == null) {
      return false;
    }
    if (object.href == null) {
      return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
    }
    return typeof object.rel === "string" && typeof object.href === "string";
  }
  async function getKeyedPrefetchLinks(matches2, manifest, routeModules) {
    let links = await Promise.all(
      matches2.map(async (match2) => {
        let route = manifest.routes[match2.route.id];
        if (route) {
          let mod = await loadRouteModule(route, routeModules);
          return mod.links ? mod.links() : [];
        }
        return [];
      })
    );
    return dedupeLinkDescriptors(
      links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
        (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
      )
    );
  }
  function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location2, mode) {
    let isNew = (match2, index) => {
      if (!currentMatches[index]) return true;
      return match2.route.id !== currentMatches[index].route.id;
    };
    let matchPathChanged = (match2, index) => {
      return (
        // param change, /users/123 -> /users/456
        currentMatches[index].pathname !== match2.pathname || // splat param changed, which is not present in match.path
        // e.g. /files/images/avatar.jpg -> files/finances.xls
        currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match2.params["*"]
      );
    };
    if (mode === "assets") {
      return nextMatches.filter(
        (match2, index) => isNew(match2, index) || matchPathChanged(match2, index)
      );
    }
    if (mode === "data") {
      return nextMatches.filter((match2, index) => {
        let manifestRoute = manifest.routes[match2.route.id];
        if (!manifestRoute || !manifestRoute.hasLoader) {
          return false;
        }
        if (isNew(match2, index) || matchPathChanged(match2, index)) {
          return true;
        }
        if (match2.route.shouldRevalidate) {
          let routeChoice = match2.route.shouldRevalidate({
            currentUrl: new URL(
              location2.pathname + location2.search + location2.hash,
              window.origin
            ),
            currentParams: currentMatches[0]?.params || {},
            nextUrl: new URL(page, window.origin),
            nextParams: match2.params,
            defaultShouldRevalidate: true
          });
          if (typeof routeChoice === "boolean") {
            return routeChoice;
          }
        }
        return true;
      });
    }
    return [];
  }
  function getModuleLinkHrefs(matches2, manifest, { includeHydrateFallback } = {}) {
    return dedupeHrefs(
      matches2.map((match2) => {
        let route = manifest.routes[match2.route.id];
        if (!route) return [];
        let hrefs = [route.module];
        if (route.clientActionModule) {
          hrefs = hrefs.concat(route.clientActionModule);
        }
        if (route.clientLoaderModule) {
          hrefs = hrefs.concat(route.clientLoaderModule);
        }
        if (includeHydrateFallback && route.hydrateFallbackModule) {
          hrefs = hrefs.concat(route.hydrateFallbackModule);
        }
        if (route.imports) {
          hrefs = hrefs.concat(route.imports);
        }
        return hrefs;
      }).flat(1)
    );
  }
  function dedupeHrefs(hrefs) {
    return [...new Set(hrefs)];
  }
  function sortKeys(obj) {
    let sorted = {};
    let keys = Object.keys(obj).sort();
    for (let key of keys) {
      sorted[key] = obj[key];
    }
    return sorted;
  }
  function dedupeLinkDescriptors(descriptors2, preloads) {
    let set7 = /* @__PURE__ */ new Set();
    let preloadsSet = new Set(preloads);
    return descriptors2.reduce((deduped, descriptor) => {
      let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
      if (alreadyModulePreload) {
        return deduped;
      }
      let key = JSON.stringify(sortKeys(descriptor));
      if (!set7.has(key)) {
        set7.add(key);
        deduped.push({ key, link: descriptor });
      }
      return deduped;
    }, []);
  }
  var SingleFetchRedirectSymbol = Symbol("SingleFetchRedirect");
  function singleFetchUrl(reqUrl, basename) {
    let url2 = typeof reqUrl === "string" ? new URL(
      reqUrl,
      // This can be called during the SSR flow via PrefetchPageLinksImpl so
      // don't assume window is available
      typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
    ) : reqUrl;
    if (url2.pathname === "/") {
      url2.pathname = "_root.data";
    } else if (basename && stripBasename(url2.pathname, basename) === "/") {
      url2.pathname = `${basename.replace(/\/$/, "")}/_root.data`;
    } else {
      url2.pathname = `${url2.pathname.replace(/\/$/, "")}.data`;
    }
    return url2;
  }
  function useDataRouterContext2() {
    let context = React9.useContext(DataRouterContext);
    invariant2(
      context,
      "You must render this element inside a <DataRouterContext.Provider> element"
    );
    return context;
  }
  function useDataRouterStateContext() {
    let context = React9.useContext(DataRouterStateContext);
    invariant2(
      context,
      "You must render this element inside a <DataRouterStateContext.Provider> element"
    );
    return context;
  }
  var FrameworkContext = React9.createContext(void 0);
  FrameworkContext.displayName = "FrameworkContext";
  function useFrameworkContext() {
    let context = React9.useContext(FrameworkContext);
    invariant2(
      context,
      "You must render this element inside a <HydratedRouter> element"
    );
    return context;
  }
  function usePrefetchBehavior(prefetch, theirElementProps) {
    let frameworkContext = React9.useContext(FrameworkContext);
    let [maybePrefetch, setMaybePrefetch] = React9.useState(false);
    let [shouldPrefetch, setShouldPrefetch] = React9.useState(false);
    let { onFocus: onFocus2, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
    let ref = React9.useRef(null);
    React9.useEffect(() => {
      if (prefetch === "render") {
        setShouldPrefetch(true);
      }
      if (prefetch === "viewport") {
        let callback2 = (entries) => {
          entries.forEach((entry) => {
            setShouldPrefetch(entry.isIntersecting);
          });
        };
        let observer = new IntersectionObserver(callback2, { threshold: 0.5 });
        if (ref.current) observer.observe(ref.current);
        return () => {
          observer.disconnect();
        };
      }
    }, [prefetch]);
    React9.useEffect(() => {
      if (maybePrefetch) {
        let id = setTimeout(() => {
          setShouldPrefetch(true);
        }, 100);
        return () => {
          clearTimeout(id);
        };
      }
    }, [maybePrefetch]);
    let setIntent = () => {
      setMaybePrefetch(true);
    };
    let cancelIntent = () => {
      setMaybePrefetch(false);
      setShouldPrefetch(false);
    };
    if (!frameworkContext) {
      return [false, ref, {}];
    }
    if (prefetch !== "intent") {
      return [shouldPrefetch, ref, {}];
    }
    return [
      shouldPrefetch,
      ref,
      {
        onFocus: composeEventHandlers(onFocus2, setIntent),
        onBlur: composeEventHandlers(onBlur, cancelIntent),
        onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
        onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
        onTouchStart: composeEventHandlers(onTouchStart, setIntent)
      }
    ];
  }
  function composeEventHandlers(theirHandler, ourHandler) {
    return (event) => {
      theirHandler && theirHandler(event);
      if (!event.defaultPrevented) {
        ourHandler(event);
      }
    };
  }
  function PrefetchPageLinks({
    page,
    ...dataLinkProps
  }) {
    let { router: router2 } = useDataRouterContext2();
    let matches2 = React9.useMemo(
      () => matchRoutes(router2.routes, page, router2.basename),
      [router2.routes, page, router2.basename]
    );
    if (!matches2) {
      return null;
    }
    return /* @__PURE__ */ React9.createElement(PrefetchPageLinksImpl, { page, matches: matches2, ...dataLinkProps });
  }
  function useKeyedPrefetchLinks(matches2) {
    let { manifest, routeModules } = useFrameworkContext();
    let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React9.useState([]);
    React9.useEffect(() => {
      let interrupted = false;
      void getKeyedPrefetchLinks(matches2, manifest, routeModules).then(
        (links) => {
          if (!interrupted) {
            setKeyedPrefetchLinks(links);
          }
        }
      );
      return () => {
        interrupted = true;
      };
    }, [matches2, manifest, routeModules]);
    return keyedPrefetchLinks;
  }
  function PrefetchPageLinksImpl({
    page,
    matches: nextMatches,
    ...linkProps
  }) {
    let location2 = useLocation();
    let { manifest, routeModules } = useFrameworkContext();
    let { basename } = useDataRouterContext2();
    let { loaderData, matches: matches2 } = useDataRouterStateContext();
    let newMatchesForData = React9.useMemo(
      () => getNewMatchesForLinks(
        page,
        nextMatches,
        matches2,
        manifest,
        location2,
        "data"
      ),
      [page, nextMatches, matches2, manifest, location2]
    );
    let newMatchesForAssets = React9.useMemo(
      () => getNewMatchesForLinks(
        page,
        nextMatches,
        matches2,
        manifest,
        location2,
        "assets"
      ),
      [page, nextMatches, matches2, manifest, location2]
    );
    let dataHrefs = React9.useMemo(() => {
      if (page === location2.pathname + location2.search + location2.hash) {
        return [];
      }
      let routesParams = /* @__PURE__ */ new Set();
      let foundOptOutRoute = false;
      nextMatches.forEach((m) => {
        let manifestRoute = manifest.routes[m.route.id];
        if (!manifestRoute || !manifestRoute.hasLoader) {
          return;
        }
        if (!newMatchesForData.some((m2) => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
          foundOptOutRoute = true;
        } else if (manifestRoute.hasClientLoader) {
          foundOptOutRoute = true;
        } else {
          routesParams.add(m.route.id);
        }
      });
      if (routesParams.size === 0) {
        return [];
      }
      let url2 = singleFetchUrl(page, basename);
      if (foundOptOutRoute && routesParams.size > 0) {
        url2.searchParams.set(
          "_routes",
          nextMatches.filter((m) => routesParams.has(m.route.id)).map((m) => m.route.id).join(",")
        );
      }
      return [url2.pathname + url2.search];
    }, [
      basename,
      loaderData,
      location2,
      manifest,
      newMatchesForData,
      nextMatches,
      page,
      routeModules
    ]);
    let moduleHrefs = React9.useMemo(
      () => getModuleLinkHrefs(newMatchesForAssets, manifest),
      [newMatchesForAssets, manifest]
    );
    let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
    return /* @__PURE__ */ React9.createElement(React9.Fragment, null, dataHrefs.map((href2) => /* @__PURE__ */ React9.createElement("link", { key: href2, rel: "prefetch", as: "fetch", href: href2, ...linkProps })), moduleHrefs.map((href2) => /* @__PURE__ */ React9.createElement("link", { key: href2, rel: "modulepreload", href: href2, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
      // these don't spread `linkProps` because they are full link descriptors
      // already with their own props
      /* @__PURE__ */ React9.createElement("link", { key, ...link })
    )));
  }
  function mergeRefs(...refs) {
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref != null) {
          ref.current = value;
        }
      });
    };
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
  try {
    if (isBrowser) {
      window.__reactRouterVersion = "7.4.0";
    }
  } catch (e) {
  }
  function createBrowserRouter(routes, opts) {
    return createRouter({
      basename: opts?.basename,
      unstable_getContext: opts?.unstable_getContext,
      future: opts?.future,
      history: createBrowserHistory({ window: opts?.window }),
      hydrationData: opts?.hydrationData || parseHydrationData(),
      routes,
      mapRouteProperties,
      dataStrategy: opts?.dataStrategy,
      patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
      window: opts?.window
    }).initialize();
  }
  function parseHydrationData() {
    let state = window?.__staticRouterHydrationData;
    if (state && state.errors) {
      state = {
        ...state,
        errors: deserializeErrors(state.errors)
      };
    }
    return state;
  }
  function deserializeErrors(errors2) {
    if (!errors2) return null;
    let entries = Object.entries(errors2);
    let serialized = {};
    for (let [key, val] of entries) {
      if (val && val.__type === "RouteErrorResponse") {
        serialized[key] = new ErrorResponseImpl(
          val.status,
          val.statusText,
          val.data,
          val.internal === true
        );
      } else if (val && val.__type === "Error") {
        if (val.__subType) {
          let ErrorConstructor = window[val.__subType];
          if (typeof ErrorConstructor === "function") {
            try {
              let error = new ErrorConstructor(val.message);
              error.stack = "";
              serialized[key] = error;
            } catch (e) {
            }
          }
        }
        if (serialized[key] == null) {
          let error = new Error(val.message);
          error.stack = "";
          serialized[key] = error;
        }
      } else {
        serialized[key] = val;
      }
    }
    return serialized;
  }
  function HistoryRouter({
    basename,
    children,
    history
  }) {
    let [state, setStateImpl] = React10.useState({
      action: history.action,
      location: history.location
    });
    let setState = React10.useCallback(
      (newState) => {
        React10.startTransition(() => setStateImpl(newState));
      },
      [setStateImpl]
    );
    React10.useLayoutEffect(() => history.listen(setState), [history, setState]);
    return /* @__PURE__ */ React10.createElement(
      Router,
      {
        basename,
        children,
        location: state.location,
        navigationType: state.action,
        navigator: history
      }
    );
  }
  HistoryRouter.displayName = "unstable_HistoryRouter";
  var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
  var Link = React10.forwardRef(
    function LinkWithRef({
      onClick,
      discover = "render",
      prefetch = "none",
      relative,
      reloadDocument,
      replace: replace22,
      state,
      target,
      to: to2,
      preventScrollReset,
      viewTransition,
      ...rest
    }, forwardedRef) {
      let { basename } = React10.useContext(NavigationContext);
      let isAbsolute = typeof to2 === "string" && ABSOLUTE_URL_REGEX2.test(to2);
      let absoluteHref;
      let isExternal = false;
      if (typeof to2 === "string" && isAbsolute) {
        absoluteHref = to2;
        if (isBrowser) {
          try {
            let currentUrl = new URL(window.location.href);
            let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
            let path = stripBasename(targetUrl.pathname, basename);
            if (targetUrl.origin === currentUrl.origin && path != null) {
              to2 = path + targetUrl.search + targetUrl.hash;
            } else {
              isExternal = true;
            }
          } catch (e) {
            warning(
              false,
              `<Link to="${to2}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
            );
          }
        }
      }
      let href2 = useHref(to2, { relative });
      let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
        prefetch,
        rest
      );
      let internalOnClick = useLinkClickHandler(to2, {
        replace: replace22,
        state,
        target,
        preventScrollReset,
        relative,
        viewTransition
      });
      function handleClick(event) {
        if (onClick) onClick(event);
        if (!event.defaultPrevented) {
          internalOnClick(event);
        }
      }
      let link = (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ React10.createElement(
          "a",
          {
            ...rest,
            ...prefetchHandlers,
            href: absoluteHref || href2,
            onClick: isExternal || reloadDocument ? onClick : handleClick,
            ref: mergeRefs(forwardedRef, prefetchRef),
            target,
            "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
          }
        )
      );
      return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, { page: href2 })) : link;
    }
  );
  Link.displayName = "Link";
  var NavLink = React10.forwardRef(
    function NavLinkWithRef({
      "aria-current": ariaCurrentProp = "page",
      caseSensitive = false,
      className: classNameProp = "",
      end: end2 = false,
      style: styleProp,
      to: to2,
      viewTransition,
      children,
      ...rest
    }, ref) {
      let path = useResolvedPath(to2, { relative: rest.relative });
      let location2 = useLocation();
      let routerState = React10.useContext(DataRouterStateContext);
      let { navigator: navigator2, basename } = React10.useContext(NavigationContext);
      let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
      // eslint-disable-next-line react-hooks/rules-of-hooks
      useViewTransitionState(path) && viewTransition === true;
      let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
      let locationPathname = location2.pathname;
      let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
      if (!caseSensitive) {
        locationPathname = locationPathname.toLowerCase();
        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
        toPathname = toPathname.toLowerCase();
      }
      if (nextLocationPathname && basename) {
        nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
      }
      const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
      let isActive = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
      let isPending2 = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
      let renderProps = {
        isActive,
        isPending: isPending2,
        isTransitioning
      };
      let ariaCurrent = isActive ? ariaCurrentProp : void 0;
      let className;
      if (typeof classNameProp === "function") {
        className = classNameProp(renderProps);
      } else {
        className = [
          classNameProp,
          isActive ? "active" : null,
          isPending2 ? "pending" : null,
          isTransitioning ? "transitioning" : null
        ].filter(Boolean).join(" ");
      }
      let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
      return /* @__PURE__ */ React10.createElement(
        Link,
        {
          ...rest,
          "aria-current": ariaCurrent,
          className,
          ref,
          style,
          to: to2,
          viewTransition
        },
        typeof children === "function" ? children(renderProps) : children
      );
    }
  );
  NavLink.displayName = "NavLink";
  var Form = React10.forwardRef(
    ({
      discover = "render",
      fetcherKey,
      navigate,
      reloadDocument,
      replace: replace22,
      state,
      method = defaultMethod,
      action,
      onSubmit,
      relative,
      preventScrollReset,
      viewTransition,
      ...props
    }, forwardedRef) => {
      let submit = useSubmit();
      let formAction = useFormAction(action, { relative });
      let formMethod = method.toLowerCase() === "get" ? "get" : "post";
      let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
      let submitHandler = (event) => {
        onSubmit && onSubmit(event);
        if (event.defaultPrevented) return;
        event.preventDefault();
        let submitter = event.nativeEvent.submitter;
        let submitMethod = submitter?.getAttribute("formmethod") || method;
        submit(submitter || event.currentTarget, {
          fetcherKey,
          method: submitMethod,
          navigate,
          replace: replace22,
          state,
          relative,
          preventScrollReset,
          viewTransition
        });
      };
      return /* @__PURE__ */ React10.createElement(
        "form",
        {
          ref: forwardedRef,
          method: formMethod,
          action: formAction,
          onSubmit: reloadDocument ? onSubmit : submitHandler,
          ...props,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }
      );
    }
  );
  Form.displayName = "Form";
  function ScrollRestoration({
    getKey,
    storageKey,
    ...props
  }) {
    let remixContext = React10.useContext(FrameworkContext);
    let { basename } = React10.useContext(NavigationContext);
    let location2 = useLocation();
    let matches2 = useMatches();
    useScrollRestoration({ getKey, storageKey });
    let ssrKey = React10.useMemo(
      () => {
        if (!remixContext || !getKey) return null;
        let userKey = getScrollRestorationKey(
          location2,
          matches2,
          basename,
          getKey
        );
        return userKey !== location2.key ? userKey : null;
      },
      // Nah, we only need this the first time for the SSR render
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    if (!remixContext || remixContext.isSpaMode) {
      return null;
    }
    let restoreScroll = ((storageKey2, restoreKey) => {
      if (!window.history.state || !window.history.state.key) {
        let key = Math.random().toString(32).slice(2);
        window.history.replaceState({ key }, "");
      }
      try {
        let positions2 = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
        let storedY = positions2[restoreKey || window.history.state.key];
        if (typeof storedY === "number") {
          window.scrollTo(0, storedY);
        }
      } catch (error) {
        console.error(error);
        sessionStorage.removeItem(storageKey2);
      }
    }).toString();
    return /* @__PURE__ */ React10.createElement(
      "script",
      {
        ...props,
        suppressHydrationWarning: true,
        dangerouslySetInnerHTML: {
          __html: `(${restoreScroll})(${JSON.stringify(
            storageKey || SCROLL_RESTORATION_STORAGE_KEY
          )}, ${JSON.stringify(ssrKey)})`
        }
      }
    );
  }
  ScrollRestoration.displayName = "ScrollRestoration";
  function getDataRouterConsoleError2(hookName) {
    return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
  }
  function useDataRouterContext3(hookName) {
    let ctx = React10.useContext(DataRouterContext);
    invariant(ctx, getDataRouterConsoleError2(hookName));
    return ctx;
  }
  function useDataRouterState2(hookName) {
    let state = React10.useContext(DataRouterStateContext);
    invariant(state, getDataRouterConsoleError2(hookName));
    return state;
  }
  function useLinkClickHandler(to2, {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = {}) {
    let navigate = useNavigate();
    let location2 = useLocation();
    let path = useResolvedPath(to2, { relative });
    return React10.useCallback(
      (event) => {
        if (shouldProcessLinkClick(event, target)) {
          event.preventDefault();
          let replace22 = replaceProp !== void 0 ? replaceProp : createPath(location2) === createPath(path);
          navigate(to2, {
            replace: replace22,
            state,
            preventScrollReset,
            relative,
            viewTransition
          });
        }
      },
      [
        location2,
        navigate,
        path,
        replaceProp,
        state,
        target,
        to2,
        preventScrollReset,
        relative,
        viewTransition
      ]
    );
  }
  function useSearchParams(defaultInit) {
    warning(
      typeof URLSearchParams !== "undefined",
      `You cannot use the \`useSearchParams\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`
    );
    let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));
    let hasSetSearchParamsRef = React10.useRef(false);
    let location2 = useLocation();
    let searchParams = React10.useMemo(
      () => (
        // Only merge in the defaults if we haven't yet called setSearchParams.
        // Once we call that we want those to take precedence, otherwise you can't
        // remove a param with setSearchParams({}) if it has an initial value
        getSearchParamsForLocation(
          location2.search,
          hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current
        )
      ),
      [location2.search]
    );
    let navigate = useNavigate();
    let setSearchParams = React10.useCallback(
      (nextInit, navigateOptions) => {
        const newSearchParams = createSearchParams(
          typeof nextInit === "function" ? nextInit(searchParams) : nextInit
        );
        hasSetSearchParamsRef.current = true;
        navigate("?" + newSearchParams, navigateOptions);
      },
      [navigate, searchParams]
    );
    return [searchParams, setSearchParams];
  }
  var fetcherId = 0;
  var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
  function useSubmit() {
    let { router: router2 } = useDataRouterContext3(
      "useSubmit"
      /* UseSubmit */
    );
    let { basename } = React10.useContext(NavigationContext);
    let currentRouteId = useRouteId();
    return React10.useCallback(
      async (target, options2 = {}) => {
        let { action, method, encType, formData, body } = getFormSubmissionInfo(
          target,
          basename
        );
        if (options2.navigate === false) {
          let key = options2.fetcherKey || getUniqueFetcherId();
          await router2.fetch(key, currentRouteId, options2.action || action, {
            preventScrollReset: options2.preventScrollReset,
            formData,
            body,
            formMethod: options2.method || method,
            formEncType: options2.encType || encType,
            flushSync: options2.flushSync
          });
        } else {
          await router2.navigate(options2.action || action, {
            preventScrollReset: options2.preventScrollReset,
            formData,
            body,
            formMethod: options2.method || method,
            formEncType: options2.encType || encType,
            replace: options2.replace,
            state: options2.state,
            fromRouteId: currentRouteId,
            flushSync: options2.flushSync,
            viewTransition: options2.viewTransition
          });
        }
      },
      [router2, basename, currentRouteId]
    );
  }
  function useFormAction(action, { relative } = {}) {
    let { basename } = React10.useContext(NavigationContext);
    let routeContext = React10.useContext(RouteContext);
    invariant(routeContext, "useFormAction must be used inside a RouteContext");
    let [match2] = routeContext.matches.slice(-1);
    let path = { ...useResolvedPath(action ? action : ".", { relative }) };
    let location2 = useLocation();
    if (action == null) {
      path.search = location2.search;
      let params = new URLSearchParams(path.search);
      let indexValues = params.getAll("index");
      let hasNakedIndexParam = indexValues.some((v) => v === "");
      if (hasNakedIndexParam) {
        params.delete("index");
        indexValues.filter((v) => v).forEach((v) => params.append("index", v));
        let qs = params.toString();
        path.search = qs ? `?${qs}` : "";
      }
    }
    if ((!action || action === ".") && match2.route.index) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    }
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    return createPath(path);
  }
  var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
  var savedScrollPositions = {};
  function getScrollRestorationKey(location2, matches2, basename, getKey) {
    let key = null;
    if (getKey) {
      if (basename !== "/") {
        key = getKey(
          {
            ...location2,
            pathname: stripBasename(location2.pathname, basename) || location2.pathname
          },
          matches2
        );
      } else {
        key = getKey(location2, matches2);
      }
    }
    if (key == null) {
      key = location2.key;
    }
    return key;
  }
  function useScrollRestoration({
    getKey,
    storageKey
  } = {}) {
    let { router: router2 } = useDataRouterContext3(
      "useScrollRestoration"
      /* UseScrollRestoration */
    );
    let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(
      "useScrollRestoration"
      /* UseScrollRestoration */
    );
    let { basename } = React10.useContext(NavigationContext);
    let location2 = useLocation();
    let matches2 = useMatches();
    let navigation = useNavigation();
    React10.useEffect(() => {
      window.history.scrollRestoration = "manual";
      return () => {
        window.history.scrollRestoration = "auto";
      };
    }, []);
    usePageHide(
      React10.useCallback(() => {
        if (navigation.state === "idle") {
          let key = getScrollRestorationKey(location2, matches2, basename, getKey);
          savedScrollPositions[key] = window.scrollY;
        }
        try {
          sessionStorage.setItem(
            storageKey || SCROLL_RESTORATION_STORAGE_KEY,
            JSON.stringify(savedScrollPositions)
          );
        } catch (error) {
          warning(
            false,
            `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`
          );
        }
        window.history.scrollRestoration = "auto";
      }, [navigation.state, getKey, basename, location2, matches2, storageKey])
    );
    if (typeof document !== "undefined") {
      React10.useLayoutEffect(() => {
        try {
          let sessionPositions = sessionStorage.getItem(
            storageKey || SCROLL_RESTORATION_STORAGE_KEY
          );
          if (sessionPositions) {
            savedScrollPositions = JSON.parse(sessionPositions);
          }
        } catch (e) {
        }
      }, [storageKey]);
      React10.useLayoutEffect(() => {
        let disableScrollRestoration = router2?.enableScrollRestoration(
          savedScrollPositions,
          () => window.scrollY,
          getKey ? (location22, matches22) => getScrollRestorationKey(location22, matches22, basename, getKey) : void 0
        );
        return () => disableScrollRestoration && disableScrollRestoration();
      }, [router2, basename, getKey]);
      React10.useLayoutEffect(() => {
        if (restoreScrollPosition === false) {
          return;
        }
        if (typeof restoreScrollPosition === "number") {
          window.scrollTo(0, restoreScrollPosition);
          return;
        }
        if (location2.hash) {
          let el = document.getElementById(
            decodeURIComponent(location2.hash.slice(1))
          );
          if (el) {
            el.scrollIntoView();
            return;
          }
        }
        if (preventScrollReset === true) {
          return;
        }
        window.scrollTo(0, 0);
      }, [location2, restoreScrollPosition, preventScrollReset]);
    }
  }
  function usePageHide(callback2, options2) {
    let { capture } = options2 || {};
    React10.useEffect(() => {
      let opts = capture != null ? { capture } : void 0;
      window.addEventListener("pagehide", callback2, opts);
      return () => {
        window.removeEventListener("pagehide", callback2, opts);
      };
    }, [callback2, capture]);
  }
  function useViewTransitionState(to2, opts = {}) {
    let vtContext = React10.useContext(ViewTransitionContext);
    invariant(
      vtContext != null,
      "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
    );
    let { basename } = useDataRouterContext3(
      "useViewTransitionState"
      /* useViewTransitionState */
    );
    let path = useResolvedPath(to2, { relative: opts.relative });
    if (!vtContext.isTransitioning) {
      return false;
    }
    let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
    let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
    return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
  }
  var encoder = new TextEncoder();

  // node_modules/redux/dist/redux.mjs
  var $$observable = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
  var symbol_observable_default = $$observable;
  var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
  var ActionTypes = {
    INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
    REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
    PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
  };
  var actionTypes_default = ActionTypes;
  function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null)
      return false;
    let proto2 = obj;
    while (Object.getPrototypeOf(proto2) !== null) {
      proto2 = Object.getPrototypeOf(proto2);
    }
    return Object.getPrototypeOf(obj) === proto2 || Object.getPrototypeOf(obj) === null;
  }
  function miniKindOf(val) {
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    const type = typeof val;
    switch (type) {
      case "boolean":
      case "string":
      case "number":
      case "symbol":
      case "function": {
        return type;
      }
    }
    if (Array.isArray(val))
      return "array";
    if (isDate(val))
      return "date";
    if (isError(val))
      return "error";
    const constructorName = ctorName(val);
    switch (constructorName) {
      case "Symbol":
      case "Promise":
      case "WeakMap":
      case "WeakSet":
      case "Map":
      case "Set":
        return constructorName;
    }
    return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
  }
  function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
  }
  function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
  }
  function isDate(val) {
    if (val instanceof Date)
      return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
  }
  function kindOf(val) {
    let typeOfVal = typeof val;
    if (true) {
      typeOfVal = miniKindOf(val);
    }
    return typeOfVal;
  }
  function createStore(reducer, preloadedState, enhancer) {
    if (typeof reducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(2) : `Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);
    }
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
      throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
    }
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
      enhancer = preloadedState;
      preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
      if (typeof enhancer !== "function") {
        throw new Error(false ? formatProdErrorMessage(1) : `Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
      }
      return enhancer(createStore)(reducer, preloadedState);
    }
    let currentReducer = reducer;
    let currentState = preloadedState;
    let currentListeners = /* @__PURE__ */ new Map();
    let nextListeners = currentListeners;
    let listenerIdCounter = 0;
    let isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = /* @__PURE__ */ new Map();
        currentListeners.forEach((listener3, key) => {
          nextListeners.set(key, listener3);
        });
      }
    }
    function getState() {
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
      }
      return currentState;
    }
    function subscribe(listener3) {
      if (typeof listener3 !== "function") {
        throw new Error(false ? formatProdErrorMessage(4) : `Expected the listener to be a function. Instead, received: '${kindOf(listener3)}'`);
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      let isSubscribed = true;
      ensureCanMutateNextListeners();
      const listenerId = listenerIdCounter++;
      nextListeners.set(listenerId, listener3);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        if (isDispatching) {
          throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        nextListeners.delete(listenerId);
        currentListeners = null;
      };
    }
    function dispatch(action) {
      if (!isPlainObject(action)) {
        throw new Error(false ? formatProdErrorMessage(7) : `Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
      }
      if (typeof action.type === "undefined") {
        throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
      }
      if (typeof action.type !== "string") {
        throw new Error(false ? formatProdErrorMessage(17) : `Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      const listeners = currentListeners = nextListeners;
      listeners.forEach((listener3) => {
        listener3();
      });
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== "function") {
        throw new Error(false ? formatProdErrorMessage(10) : `Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
      }
      currentReducer = nextReducer;
      dispatch({
        type: actionTypes_default.REPLACE
      });
    }
    function observable() {
      const outerSubscribe = subscribe;
      return {
        /**
         * The minimal observable subscription method.
         * @param observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe(observer) {
          if (typeof observer !== "object" || observer === null) {
            throw new Error(false ? formatProdErrorMessage(11) : `Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
          }
          function observeState() {
            const observerAsObserver = observer;
            if (observerAsObserver.next) {
              observerAsObserver.next(getState());
            }
          }
          observeState();
          const unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe
          };
        },
        [symbol_observable_default]() {
          return this;
        }
      };
    }
    dispatch({
      type: actionTypes_default.INIT
    });
    const store2 = {
      dispatch,
      subscribe,
      getState,
      replaceReducer,
      [symbol_observable_default]: observable
    };
    return store2;
  }
  function warning2(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    const reducerKeys = Object.keys(reducers);
    const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
    if (reducerKeys.length === 0) {
      return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
    }
    if (!isPlainObject(inputState)) {
      return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join('", "')}"`;
    }
    const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
    unexpectedKeys.forEach((key) => {
      unexpectedKeyCache[key] = true;
    });
    if (action && action.type === actionTypes_default.REPLACE)
      return;
    if (unexpectedKeys.length > 0) {
      return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join('", "')}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join('", "')}". Unexpected keys will be ignored.`;
    }
  }
  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach((key) => {
      const reducer = reducers[key];
      const initialState6 = reducer(void 0, {
        type: actionTypes_default.INIT
      });
      if (typeof initialState6 === "undefined") {
        throw new Error(false ? formatProdErrorMessage(12) : `The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
      }
      if (typeof reducer(void 0, {
        type: actionTypes_default.PROBE_UNKNOWN_ACTION()
      }) === "undefined") {
        throw new Error(false ? formatProdErrorMessage(13) : `The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
      }
    });
  }
  function combineReducers(reducers) {
    const reducerKeys = Object.keys(reducers);
    const finalReducers = {};
    for (let i = 0; i < reducerKeys.length; i++) {
      const key = reducerKeys[i];
      if (true) {
        if (typeof reducers[key] === "undefined") {
          warning2(`No reducer provided for key "${key}"`);
        }
      }
      if (typeof reducers[key] === "function") {
        finalReducers[key] = reducers[key];
      }
    }
    const finalReducerKeys = Object.keys(finalReducers);
    let unexpectedKeyCache;
    if (true) {
      unexpectedKeyCache = {};
    }
    let shapeAssertionError;
    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }
    return function combination(state = {}, action) {
      if (shapeAssertionError) {
        throw shapeAssertionError;
      }
      if (true) {
        const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
        if (warningMessage) {
          warning2(warningMessage);
        }
      }
      let hasChanged = false;
      const nextState = {};
      for (let i = 0; i < finalReducerKeys.length; i++) {
        const key = finalReducerKeys[i];
        const reducer = finalReducers[key];
        const previousStateForKey = state[key];
        const nextStateForKey = reducer(previousStateForKey, action);
        if (typeof nextStateForKey === "undefined") {
          const actionType = action && action.type;
          throw new Error(false ? formatProdErrorMessage(14) : `When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
        }
        nextState[key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }
      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
      return hasChanged ? nextState : state;
    };
  }
  function compose(...funcs) {
    if (funcs.length === 0) {
      return (arg) => arg;
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce((a, b) => (...args) => a(b(...args)));
  }
  function applyMiddleware(...middlewares) {
    return (createStore2) => (reducer, preloadedState) => {
      const store2 = createStore2(reducer, preloadedState);
      let dispatch = () => {
        throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      };
      const middlewareAPI = {
        getState: store2.getState,
        dispatch: (action, ...args) => dispatch(action, ...args)
      };
      const chain = middlewares.map((middleware2) => middleware2(middlewareAPI));
      dispatch = compose(...chain)(store2.dispatch);
      return {
        ...store2,
        dispatch
      };
    };
  }
  function isAction(action) {
    return isPlainObject(action) && "type" in action && typeof action.type === "string";
  }

  // node_modules/immer/dist/immer.mjs
  var NOTHING = Symbol.for("immer-nothing");
  var DRAFTABLE = Symbol.for("immer-draftable");
  var DRAFT_STATE = Symbol.for("immer-state");
  var errors = true ? [
    // All error codes, starting by 0:
    function(plugin) {
      return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
    },
    function(thing) {
      return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
    },
    "This object has been frozen and should not be mutated",
    function(data2) {
      return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data2;
    },
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
    "Immer forbids circular references",
    "The first or second argument to `produce` must be a function",
    "The third argument to `produce` must be a function or undefined",
    "First argument to `createDraft` must be a plain object, an array, or an immerable object",
    "First argument to `finishDraft` must be a draft returned by `createDraft`",
    function(thing) {
      return `'current' expects a draft, got: ${thing}`;
    },
    "Object.defineProperty() cannot be used on an Immer draft",
    "Object.setPrototypeOf() cannot be used on an Immer draft",
    "Immer only supports deleting array indices",
    "Immer only supports setting array indices and the 'length' property",
    function(thing) {
      return `'original' expects a draft, got: ${thing}`;
    }
    // Note: if more errors are added, the errorOffset in Patches.ts should be increased
    // See Patches.ts for additional errors
  ] : [];
  function die(error, ...args) {
    if (true) {
      const e = errors[error];
      const msg = typeof e === "function" ? e.apply(null, args) : e;
      throw new Error(`[Immer] ${msg}`);
    }
    throw new Error(
      `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
    );
  }
  var getPrototypeOf = Object.getPrototypeOf;
  function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
  }
  function isDraftable(value) {
    if (!value)
      return false;
    return isPlainObject2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
  }
  var objectCtorString = Object.prototype.constructor.toString();
  function isPlainObject2(value) {
    if (!value || typeof value !== "object")
      return false;
    const proto2 = getPrototypeOf(value);
    if (proto2 === null) {
      return true;
    }
    const Ctor = Object.hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
    if (Ctor === Object)
      return true;
    return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
  }
  function original(value) {
    if (!isDraft(value))
      die(15, value);
    return value[DRAFT_STATE].base_;
  }
  function each(obj, iter) {
    if (getArchtype(obj) === 0) {
      Reflect.ownKeys(obj).forEach((key) => {
        iter(key, obj[key], obj);
      });
    } else {
      obj.forEach((entry, index) => iter(index, entry, obj));
    }
  }
  function getArchtype(thing) {
    const state = thing[DRAFT_STATE];
    return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
  }
  function has(thing, prop) {
    return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
  }
  function get(thing, prop) {
    return getArchtype(thing) === 2 ? thing.get(prop) : thing[prop];
  }
  function set(thing, propOrOldValue, value) {
    const t2 = getArchtype(thing);
    if (t2 === 2)
      thing.set(propOrOldValue, value);
    else if (t2 === 3) {
      thing.add(value);
    } else
      thing[propOrOldValue] = value;
  }
  function is2(x2, y) {
    if (x2 === y) {
      return x2 !== 0 || 1 / x2 === 1 / y;
    } else {
      return x2 !== x2 && y !== y;
    }
  }
  function isMap(target) {
    return target instanceof Map;
  }
  function isSet(target) {
    return target instanceof Set;
  }
  function latest(state) {
    return state.copy_ || state.base_;
  }
  function shallowCopy(base, strict) {
    if (isMap(base)) {
      return new Map(base);
    }
    if (isSet(base)) {
      return new Set(base);
    }
    if (Array.isArray(base))
      return Array.prototype.slice.call(base);
    const isPlain2 = isPlainObject2(base);
    if (strict === true || strict === "class_only" && !isPlain2) {
      const descriptors2 = Object.getOwnPropertyDescriptors(base);
      delete descriptors2[DRAFT_STATE];
      let keys = Reflect.ownKeys(descriptors2);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const desc = descriptors2[key];
        if (desc.writable === false) {
          desc.writable = true;
          desc.configurable = true;
        }
        if (desc.get || desc.set)
          descriptors2[key] = {
            configurable: true,
            writable: true,
            // could live with !!desc.set as well here...
            enumerable: desc.enumerable,
            value: base[key]
          };
      }
      return Object.create(getPrototypeOf(base), descriptors2);
    } else {
      const proto2 = getPrototypeOf(base);
      if (proto2 !== null && isPlain2) {
        return { ...base };
      }
      const obj = Object.create(proto2);
      return Object.assign(obj, base);
    }
  }
  function freeze(obj, deep = false) {
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
      return obj;
    if (getArchtype(obj) > 1) {
      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;
    }
    Object.freeze(obj);
    if (deep)
      Object.entries(obj).forEach(([key, value]) => freeze(value, true));
    return obj;
  }
  function dontMutateFrozenCollections() {
    die(2);
  }
  function isFrozen(obj) {
    return Object.isFrozen(obj);
  }
  var plugins = {};
  function getPlugin(pluginKey) {
    const plugin = plugins[pluginKey];
    if (!plugin) {
      die(0, pluginKey);
    }
    return plugin;
  }
  function loadPlugin(pluginKey, implementation) {
    if (!plugins[pluginKey])
      plugins[pluginKey] = implementation;
  }
  var currentScope;
  function getCurrentScope() {
    return currentScope;
  }
  function createScope(parent_, immer_) {
    return {
      drafts_: [],
      parent_,
      immer_,
      // Whenever the modified draft contains a draft from another scope, we
      // need to prevent auto-freezing so the unowned draft can be finalized.
      canAutoFreeze_: true,
      unfinalizedDrafts_: 0
    };
  }
  function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
      getPlugin("Patches");
      scope.patches_ = [];
      scope.inversePatches_ = [];
      scope.patchListener_ = patchListener;
    }
  }
  function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
  }
  function leaveScope(scope) {
    if (scope === currentScope) {
      currentScope = scope.parent_;
    }
  }
  function enterScope(immer2) {
    return currentScope = createScope(currentScope, immer2);
  }
  function revokeDraft(draft) {
    const state = draft[DRAFT_STATE];
    if (state.type_ === 0 || state.type_ === 1)
      state.revoke_();
    else
      state.revoked_ = true;
  }
  function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    const baseDraft = scope.drafts_[0];
    const isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
      if (baseDraft[DRAFT_STATE].modified_) {
        revokeScope(scope);
        die(4);
      }
      if (isDraftable(result)) {
        result = finalize(scope, result);
        if (!scope.parent_)
          maybeFreeze(scope, result);
      }
      if (scope.patches_) {
        getPlugin("Patches").generateReplacementPatches_(
          baseDraft[DRAFT_STATE].base_,
          result,
          scope.patches_,
          scope.inversePatches_
        );
      }
    } else {
      result = finalize(scope, baseDraft, []);
    }
    revokeScope(scope);
    if (scope.patches_) {
      scope.patchListener_(scope.patches_, scope.inversePatches_);
    }
    return result !== NOTHING ? result : void 0;
  }
  function finalize(rootScope, value, path) {
    if (isFrozen(value))
      return value;
    const state = value[DRAFT_STATE];
    if (!state) {
      each(
        value,
        (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path)
      );
      return value;
    }
    if (state.scope_ !== rootScope)
      return value;
    if (!state.modified_) {
      maybeFreeze(rootScope, state.base_, true);
      return state.base_;
    }
    if (!state.finalized_) {
      state.finalized_ = true;
      state.scope_.unfinalizedDrafts_--;
      const result = state.copy_;
      let resultEach = result;
      let isSet2 = false;
      if (state.type_ === 3) {
        resultEach = new Set(result);
        result.clear();
        isSet2 = true;
      }
      each(
        resultEach,
        (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)
      );
      maybeFreeze(rootScope, result, false);
      if (path && rootScope.patches_) {
        getPlugin("Patches").generatePatches_(
          state,
          path,
          rootScope.patches_,
          rootScope.inversePatches_
        );
      }
    }
    return state.copy_;
  }
  function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
    if (childValue === targetObject)
      die(5);
    if (isDraft(childValue)) {
      const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
      !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
      const res = finalize(rootScope, childValue, path);
      set(targetObject, prop, res);
      if (isDraft(res)) {
        rootScope.canAutoFreeze_ = false;
      } else
        return;
    } else if (targetIsSet) {
      targetObject.add(childValue);
    }
    if (isDraftable(childValue) && !isFrozen(childValue)) {
      if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
        return;
      }
      finalize(rootScope, childValue);
      if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && Object.prototype.propertyIsEnumerable.call(targetObject, prop))
        maybeFreeze(rootScope, childValue);
    }
  }
  function maybeFreeze(scope, value, deep = false) {
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
      freeze(value, deep);
    }
  }
  function createProxyProxy(base, parent) {
    const isArray2 = Array.isArray(base);
    const state = {
      type_: isArray2 ? 1 : 0,
      // Track which produce call this is associated with.
      scope_: parent ? parent.scope_ : getCurrentScope(),
      // True for both shallow and deep changes.
      modified_: false,
      // Used during finalization.
      finalized_: false,
      // Track which properties have been assigned (true) or deleted (false).
      assigned_: {},
      // The parent draft state.
      parent_: parent,
      // The base state.
      base_: base,
      // The base proxy.
      draft_: null,
      // set below
      // The base copy with any updated values.
      copy_: null,
      // Called by the `produce` function.
      revoke_: null,
      isManual_: false
    };
    let target = state;
    let traps = objectTraps;
    if (isArray2) {
      target = [state];
      traps = arrayTraps;
    }
    const { revoke, proxy } = Proxy.revocable(target, traps);
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return proxy;
  }
  var objectTraps = {
    get(state, prop) {
      if (prop === DRAFT_STATE)
        return state;
      const source = latest(state);
      if (!has(source, prop)) {
        return readPropFromProto(state, source, prop);
      }
      const value = source[prop];
      if (state.finalized_ || !isDraftable(value)) {
        return value;
      }
      if (value === peek(state.base_, prop)) {
        prepareCopy(state);
        return state.copy_[prop] = createProxy(value, state);
      }
      return value;
    },
    has(state, prop) {
      return prop in latest(state);
    },
    ownKeys(state) {
      return Reflect.ownKeys(latest(state));
    },
    set(state, prop, value) {
      const desc = getDescriptorFromProto(latest(state), prop);
      if (desc?.set) {
        desc.set.call(state.draft_, value);
        return true;
      }
      if (!state.modified_) {
        const current2 = peek(latest(state), prop);
        const currentState = current2?.[DRAFT_STATE];
        if (currentState && currentState.base_ === value) {
          state.copy_[prop] = value;
          state.assigned_[prop] = false;
          return true;
        }
        if (is2(value, current2) && (value !== void 0 || has(state.base_, prop)))
          return true;
        prepareCopy(state);
        markChanged(state);
      }
      if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
      (value !== void 0 || prop in state.copy_) || // special case: NaN
      Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
        return true;
      state.copy_[prop] = value;
      state.assigned_[prop] = true;
      return true;
    },
    deleteProperty(state, prop) {
      if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
        state.assigned_[prop] = false;
        prepareCopy(state);
        markChanged(state);
      } else {
        delete state.assigned_[prop];
      }
      if (state.copy_) {
        delete state.copy_[prop];
      }
      return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor(state, prop) {
      const owner = latest(state);
      const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
      if (!desc)
        return desc;
      return {
        writable: true,
        configurable: state.type_ !== 1 || prop !== "length",
        enumerable: desc.enumerable,
        value: owner[prop]
      };
    },
    defineProperty() {
      die(11);
    },
    getPrototypeOf(state) {
      return getPrototypeOf(state.base_);
    },
    setPrototypeOf() {
      die(12);
    }
  };
  var arrayTraps = {};
  each(objectTraps, (key, fn) => {
    arrayTraps[key] = function() {
      arguments[0] = arguments[0][0];
      return fn.apply(this, arguments);
    };
  });
  arrayTraps.deleteProperty = function(state, prop) {
    if (isNaN(parseInt(prop)))
      die(13);
    return arrayTraps.set.call(this, state, prop, void 0);
  };
  arrayTraps.set = function(state, prop, value) {
    if (prop !== "length" && isNaN(parseInt(prop)))
      die(14);
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
  };
  function peek(draft, prop) {
    const state = draft[DRAFT_STATE];
    const source = state ? latest(state) : draft;
    return source[prop];
  }
  function readPropFromProto(state, source, prop) {
    const desc = getDescriptorFromProto(source, prop);
    return desc ? `value` in desc ? desc.value : (
      // This is a very special case, if the prop is a getter defined by the
      // prototype, we should invoke it with the draft as context!
      desc.get?.call(state.draft_)
    ) : void 0;
  }
  function getDescriptorFromProto(source, prop) {
    if (!(prop in source))
      return void 0;
    let proto2 = getPrototypeOf(source);
    while (proto2) {
      const desc = Object.getOwnPropertyDescriptor(proto2, prop);
      if (desc)
        return desc;
      proto2 = getPrototypeOf(proto2);
    }
    return void 0;
  }
  function markChanged(state) {
    if (!state.modified_) {
      state.modified_ = true;
      if (state.parent_) {
        markChanged(state.parent_);
      }
    }
  }
  function prepareCopy(state) {
    if (!state.copy_) {
      state.copy_ = shallowCopy(
        state.base_,
        state.scope_.immer_.useStrictShallowCopy_
      );
    }
  }
  var Immer2 = class {
    constructor(config2) {
      this.autoFreeze_ = true;
      this.useStrictShallowCopy_ = false;
      this.produce = (base, recipe, patchListener) => {
        if (typeof base === "function" && typeof recipe !== "function") {
          const defaultBase = recipe;
          recipe = base;
          const self = this;
          return function curriedProduce(base2 = defaultBase, ...args) {
            return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
          };
        }
        if (typeof recipe !== "function")
          die(6);
        if (patchListener !== void 0 && typeof patchListener !== "function")
          die(7);
        let result;
        if (isDraftable(base)) {
          const scope = enterScope(this);
          const proxy = createProxy(base, void 0);
          let hasError = true;
          try {
            result = recipe(proxy);
            hasError = false;
          } finally {
            if (hasError)
              revokeScope(scope);
            else
              leaveScope(scope);
          }
          usePatchesInScope(scope, patchListener);
          return processResult(result, scope);
        } else if (!base || typeof base !== "object") {
          result = recipe(base);
          if (result === void 0)
            result = base;
          if (result === NOTHING)
            result = void 0;
          if (this.autoFreeze_)
            freeze(result, true);
          if (patchListener) {
            const p2 = [];
            const ip = [];
            getPlugin("Patches").generateReplacementPatches_(base, result, p2, ip);
            patchListener(p2, ip);
          }
          return result;
        } else
          die(1, base);
      };
      this.produceWithPatches = (base, recipe) => {
        if (typeof base === "function") {
          return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
        }
        let patches, inversePatches;
        const result = this.produce(base, recipe, (p2, ip) => {
          patches = p2;
          inversePatches = ip;
        });
        return [result, patches, inversePatches];
      };
      if (typeof config2?.autoFreeze === "boolean")
        this.setAutoFreeze(config2.autoFreeze);
      if (typeof config2?.useStrictShallowCopy === "boolean")
        this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
    }
    createDraft(base) {
      if (!isDraftable(base))
        die(8);
      if (isDraft(base))
        base = current(base);
      const scope = enterScope(this);
      const proxy = createProxy(base, void 0);
      proxy[DRAFT_STATE].isManual_ = true;
      leaveScope(scope);
      return proxy;
    }
    finishDraft(draft, patchListener) {
      const state = draft && draft[DRAFT_STATE];
      if (!state || !state.isManual_)
        die(9);
      const { scope_: scope } = state;
      usePatchesInScope(scope, patchListener);
      return processResult(void 0, scope);
    }
    /**
     * Pass true to automatically freeze all copies created by Immer.
     *
     * By default, auto-freezing is enabled.
     */
    setAutoFreeze(value) {
      this.autoFreeze_ = value;
    }
    /**
     * Pass true to enable strict shallow copy.
     *
     * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
     */
    setUseStrictShallowCopy(value) {
      this.useStrictShallowCopy_ = value;
    }
    applyPatches(base, patches) {
      let i;
      for (i = patches.length - 1; i >= 0; i--) {
        const patch = patches[i];
        if (patch.path.length === 0 && patch.op === "replace") {
          base = patch.value;
          break;
        }
      }
      if (i > -1) {
        patches = patches.slice(i + 1);
      }
      const applyPatchesImpl = getPlugin("Patches").applyPatches_;
      if (isDraft(base)) {
        return applyPatchesImpl(base, patches);
      }
      return this.produce(
        base,
        (draft) => applyPatchesImpl(draft, patches)
      );
    }
  };
  function createProxy(value, parent) {
    const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
    const scope = parent ? parent.scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    return draft;
  }
  function current(value) {
    if (!isDraft(value))
      die(10, value);
    return currentImpl(value);
  }
  function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value))
      return value;
    const state = value[DRAFT_STATE];
    let copy2;
    if (state) {
      if (!state.modified_)
        return state.base_;
      state.finalized_ = true;
      copy2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
    } else {
      copy2 = shallowCopy(value, true);
    }
    each(copy2, (key, childValue) => {
      set(copy2, key, currentImpl(childValue));
    });
    if (state) {
      state.finalized_ = false;
    }
    return copy2;
  }
  function enablePatches() {
    const errorOffset = 16;
    if (true) {
      errors.push(
        'Sets cannot have "replace" patches.',
        function(op) {
          return "Unsupported patch operation: " + op;
        },
        function(path) {
          return "Cannot apply patch, path doesn't resolve: " + path;
        },
        "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
      );
    }
    const REPLACE = "replace";
    const ADD = "add";
    const REMOVE = "remove";
    function generatePatches_(state, basePath, patches, inversePatches) {
      switch (state.type_) {
        case 0:
        case 2:
          return generatePatchesFromAssigned(
            state,
            basePath,
            patches,
            inversePatches
          );
        case 1:
          return generateArrayPatches(state, basePath, patches, inversePatches);
        case 3:
          return generateSetPatches(
            state,
            basePath,
            patches,
            inversePatches
          );
      }
    }
    function generateArrayPatches(state, basePath, patches, inversePatches) {
      let { base_, assigned_ } = state;
      let copy_ = state.copy_;
      if (copy_.length < base_.length) {
        ;
        [base_, copy_] = [copy_, base_];
        [patches, inversePatches] = [inversePatches, patches];
      }
      for (let i = 0; i < base_.length; i++) {
        if (assigned_[i] && copy_[i] !== base_[i]) {
          const path = basePath.concat([i]);
          patches.push({
            op: REPLACE,
            path,
            // Need to maybe clone it, as it can in fact be the original value
            // due to the base/copy inversion at the start of this function
            value: clonePatchValueIfNeeded(copy_[i])
          });
          inversePatches.push({
            op: REPLACE,
            path,
            value: clonePatchValueIfNeeded(base_[i])
          });
        }
      }
      for (let i = base_.length; i < copy_.length; i++) {
        const path = basePath.concat([i]);
        patches.push({
          op: ADD,
          path,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: clonePatchValueIfNeeded(copy_[i])
        });
      }
      for (let i = copy_.length - 1; base_.length <= i; --i) {
        const path = basePath.concat([i]);
        inversePatches.push({
          op: REMOVE,
          path
        });
      }
    }
    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
      const { base_, copy_ } = state;
      each(state.assigned_, (key, assignedValue) => {
        const origValue = get(base_, key);
        const value = get(copy_, key);
        const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
        if (origValue === value && op === REPLACE)
          return;
        const path = basePath.concat(key);
        patches.push(op === REMOVE ? { op, path } : { op, path, value });
        inversePatches.push(
          op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }
        );
      });
    }
    function generateSetPatches(state, basePath, patches, inversePatches) {
      let { base_, copy_ } = state;
      let i = 0;
      base_.forEach((value) => {
        if (!copy_.has(value)) {
          const path = basePath.concat([i]);
          patches.push({
            op: REMOVE,
            path,
            value
          });
          inversePatches.unshift({
            op: ADD,
            path,
            value
          });
        }
        i++;
      });
      i = 0;
      copy_.forEach((value) => {
        if (!base_.has(value)) {
          const path = basePath.concat([i]);
          patches.push({
            op: ADD,
            path,
            value
          });
          inversePatches.unshift({
            op: REMOVE,
            path,
            value
          });
        }
        i++;
      });
    }
    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
      patches.push({
        op: REPLACE,
        path: [],
        value: replacement === NOTHING ? void 0 : replacement
      });
      inversePatches.push({
        op: REPLACE,
        path: [],
        value: baseValue
      });
    }
    function applyPatches_(draft, patches) {
      patches.forEach((patch) => {
        const { path, op } = patch;
        let base = draft;
        for (let i = 0; i < path.length - 1; i++) {
          const parentType = getArchtype(base);
          let p2 = path[i];
          if (typeof p2 !== "string" && typeof p2 !== "number") {
            p2 = "" + p2;
          }
          if ((parentType === 0 || parentType === 1) && (p2 === "__proto__" || p2 === "constructor"))
            die(errorOffset + 3);
          if (typeof base === "function" && p2 === "prototype")
            die(errorOffset + 3);
          base = get(base, p2);
          if (typeof base !== "object")
            die(errorOffset + 2, path.join("/"));
        }
        const type = getArchtype(base);
        const value = deepClonePatchValue(patch.value);
        const key = path[path.length - 1];
        switch (op) {
          case REPLACE:
            switch (type) {
              case 2:
                return base.set(key, value);
              case 3:
                die(errorOffset);
              default:
                return base[key] = value;
            }
          case ADD:
            switch (type) {
              case 1:
                return key === "-" ? base.push(value) : base.splice(key, 0, value);
              case 2:
                return base.set(key, value);
              case 3:
                return base.add(value);
              default:
                return base[key] = value;
            }
          case REMOVE:
            switch (type) {
              case 1:
                return base.splice(key, 1);
              case 2:
                return base.delete(key);
              case 3:
                return base.delete(patch.value);
              default:
                return delete base[key];
            }
          default:
            die(errorOffset + 1, op);
        }
      });
      return draft;
    }
    function deepClonePatchValue(obj) {
      if (!isDraftable(obj))
        return obj;
      if (Array.isArray(obj))
        return obj.map(deepClonePatchValue);
      if (isMap(obj))
        return new Map(
          Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])
        );
      if (isSet(obj))
        return new Set(Array.from(obj).map(deepClonePatchValue));
      const cloned = Object.create(getPrototypeOf(obj));
      for (const key in obj)
        cloned[key] = deepClonePatchValue(obj[key]);
      if (has(obj, DRAFTABLE))
        cloned[DRAFTABLE] = obj[DRAFTABLE];
      return cloned;
    }
    function clonePatchValueIfNeeded(obj) {
      if (isDraft(obj)) {
        return deepClonePatchValue(obj);
      } else
        return obj;
    }
    loadPlugin("Patches", {
      applyPatches_,
      generatePatches_,
      generateReplacementPatches_
    });
  }
  var immer = new Immer2();
  var produce = immer.produce;
  var produceWithPatches = immer.produceWithPatches.bind(
    immer
  );
  var setAutoFreeze = immer.setAutoFreeze.bind(immer);
  var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);
  var applyPatches = immer.applyPatches.bind(immer);
  var createDraft = immer.createDraft.bind(immer);
  var finishDraft = immer.finishDraft.bind(immer);

  // node_modules/reselect/dist/reselect.mjs
  var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
    if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
      let isInputSameAsOutput = false;
      try {
        const emptyObject = {};
        if (resultFunc(emptyObject) === emptyObject)
          isInputSameAsOutput = true;
      } catch {
      }
      if (isInputSameAsOutput) {
        let stack = void 0;
        try {
          throw new Error();
        } catch (e) {
          ;
          ({ stack } = e);
        }
        console.warn(
          "The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.",
          { stack }
        );
      }
    }
  };
  var runInputStabilityCheck = (inputSelectorResultsObject, options2, inputSelectorArgs) => {
    const { memoize: memoize2, memoizeOptions } = options2;
    const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
    const createAnEmptyObject = memoize2(() => ({}), ...memoizeOptions);
    const areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);
    if (!areInputSelectorResultsEqual) {
      let stack = void 0;
      try {
        throw new Error();
      } catch (e) {
        ;
        ({ stack } = e);
      }
      console.warn(
        "An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`",
        {
          arguments: inputSelectorArgs,
          firstInputs: inputSelectorResults,
          secondInputs: inputSelectorResultsCopy,
          stack
        }
      );
    }
  };
  var globalDevModeChecks = {
    inputStabilityCheck: "once",
    identityFunctionCheck: "once"
  };
  function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
    if (typeof func !== "function") {
      throw new TypeError(errorMessage);
    }
  }
  function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
    if (typeof object !== "object") {
      throw new TypeError(errorMessage);
    }
  }
  function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
    if (!array.every((item) => typeof item === "function")) {
      const itemTypes = array.map(
        (item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item
      ).join(", ");
      throw new TypeError(`${errorMessage}[${itemTypes}]`);
    }
  }
  var ensureIsArray = (item) => {
    return Array.isArray(item) ? item : [item];
  };
  function getDependencies(createSelectorArgs) {
    const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
    assertIsArrayOfFunctions(
      dependencies,
      `createSelector expects all input-selectors to be functions, but received the following types: `
    );
    return dependencies;
  }
  function collectInputSelectorResults(dependencies, inputSelectorArgs) {
    const inputSelectorResults = [];
    const { length: length2 } = dependencies;
    for (let i = 0; i < length2; i++) {
      inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
    }
    return inputSelectorResults;
  }
  var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
    const { identityFunctionCheck, inputStabilityCheck } = {
      ...globalDevModeChecks,
      ...devModeChecks
    };
    return {
      identityFunctionCheck: {
        shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
        run: runIdentityFunctionCheck
      },
      inputStabilityCheck: {
        shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
        run: runInputStabilityCheck
      }
    };
  };
  var REDUX_PROXY_LABEL = Symbol();
  var proto = Object.getPrototypeOf({});
  var StrongRef = class {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  };
  var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
  var UNTERMINATED = 0;
  var TERMINATED = 1;
  function createCacheNode() {
    return {
      s: UNTERMINATED,
      v: void 0,
      o: null,
      p: null
    };
  }
  function weakMapMemoize(func, options2 = {}) {
    let fnNode = createCacheNode();
    const { resultEqualityCheck } = options2;
    let lastResult;
    let resultsCount = 0;
    function memoized() {
      let cacheNode = fnNode;
      const { length: length2 } = arguments;
      for (let i = 0, l = length2; i < l; i++) {
        const arg = arguments[i];
        if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
          let objectCache = cacheNode.o;
          if (objectCache === null) {
            cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
          }
          const objectNode = objectCache.get(arg);
          if (objectNode === void 0) {
            cacheNode = createCacheNode();
            objectCache.set(arg, cacheNode);
          } else {
            cacheNode = objectNode;
          }
        } else {
          let primitiveCache = cacheNode.p;
          if (primitiveCache === null) {
            cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
          }
          const primitiveNode = primitiveCache.get(arg);
          if (primitiveNode === void 0) {
            cacheNode = createCacheNode();
            primitiveCache.set(arg, cacheNode);
          } else {
            cacheNode = primitiveNode;
          }
        }
      }
      const terminatedNode = cacheNode;
      let result;
      if (cacheNode.s === TERMINATED) {
        result = cacheNode.v;
      } else {
        result = func.apply(null, arguments);
        resultsCount++;
        if (resultEqualityCheck) {
          const lastResultValue = lastResult?.deref?.() ?? lastResult;
          if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
            result = lastResultValue;
            resultsCount !== 0 && resultsCount--;
          }
          const needsWeakRef = typeof result === "object" && result !== null || typeof result === "function";
          lastResult = needsWeakRef ? new Ref(result) : result;
        }
      }
      terminatedNode.s = TERMINATED;
      terminatedNode.v = result;
      return result;
    }
    memoized.clearCache = () => {
      fnNode = createCacheNode();
      memoized.resetResultsCount();
    };
    memoized.resultsCount = () => resultsCount;
    memoized.resetResultsCount = () => {
      resultsCount = 0;
    };
    return memoized;
  }
  function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
    const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
      memoize: memoizeOrOptions,
      memoizeOptions: memoizeOptionsFromArgs
    } : memoizeOrOptions;
    const createSelector2 = (...createSelectorArgs) => {
      let recomputations = 0;
      let dependencyRecomputations = 0;
      let lastResult;
      let directlyPassedOptions = {};
      let resultFunc = createSelectorArgs.pop();
      if (typeof resultFunc === "object") {
        directlyPassedOptions = resultFunc;
        resultFunc = createSelectorArgs.pop();
      }
      assertIsFunction(
        resultFunc,
        `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`
      );
      const combinedOptions = {
        ...createSelectorCreatorOptions,
        ...directlyPassedOptions
      };
      const {
        memoize: memoize2,
        memoizeOptions = [],
        argsMemoize = weakMapMemoize,
        argsMemoizeOptions = [],
        devModeChecks = {}
      } = combinedOptions;
      const finalMemoizeOptions = ensureIsArray(memoizeOptions);
      const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
      const dependencies = getDependencies(createSelectorArgs);
      const memoizedResultFunc = memoize2(function recomputationWrapper() {
        recomputations++;
        return resultFunc.apply(
          null,
          arguments
        );
      }, ...finalMemoizeOptions);
      let firstRun = true;
      const selector = argsMemoize(function dependenciesChecker() {
        dependencyRecomputations++;
        const inputSelectorResults = collectInputSelectorResults(
          dependencies,
          arguments
        );
        lastResult = memoizedResultFunc.apply(null, inputSelectorResults);
        if (true) {
          const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
          if (identityFunctionCheck.shouldRun) {
            identityFunctionCheck.run(
              resultFunc,
              inputSelectorResults,
              lastResult
            );
          }
          if (inputStabilityCheck.shouldRun) {
            const inputSelectorResultsCopy = collectInputSelectorResults(
              dependencies,
              arguments
            );
            inputStabilityCheck.run(
              { inputSelectorResults, inputSelectorResultsCopy },
              { memoize: memoize2, memoizeOptions: finalMemoizeOptions },
              arguments
            );
          }
          if (firstRun)
            firstRun = false;
        }
        return lastResult;
      }, ...finalArgsMemoizeOptions);
      return Object.assign(selector, {
        resultFunc,
        memoizedResultFunc,
        dependencies,
        dependencyRecomputations: () => dependencyRecomputations,
        resetDependencyRecomputations: () => {
          dependencyRecomputations = 0;
        },
        lastResult: () => lastResult,
        recomputations: () => recomputations,
        resetRecomputations: () => {
          recomputations = 0;
        },
        memoize: memoize2,
        argsMemoize
      });
    };
    Object.assign(createSelector2, {
      withTypes: () => createSelector2
    });
    return createSelector2;
  }
  var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
  var createStructuredSelector = Object.assign(
    (inputSelectorsObject, selectorCreator = createSelector) => {
      assertIsObject(
        inputSelectorsObject,
        `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`
      );
      const inputSelectorKeys = Object.keys(inputSelectorsObject);
      const dependencies = inputSelectorKeys.map(
        (key) => inputSelectorsObject[key]
      );
      const structuredSelector = selectorCreator(
        dependencies,
        (...inputSelectorResults) => {
          return inputSelectorResults.reduce((composition, value, index) => {
            composition[inputSelectorKeys[index]] = value;
            return composition;
          }, {});
        }
      );
      return structuredSelector;
    },
    { withTypes: () => createStructuredSelector }
  );

  // node_modules/redux-thunk/dist/redux-thunk.mjs
  function createThunkMiddleware(extraArgument) {
    const middleware2 = ({ dispatch, getState }) => (next2) => (action) => {
      if (typeof action === "function") {
        return action(dispatch, getState, extraArgument);
      }
      return next2(action);
    };
    return middleware2;
  }
  var thunk = createThunkMiddleware();
  var withExtraArgument = createThunkMiddleware;

  // node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs
  var createDraftSafeSelectorCreator = (...args) => {
    const createSelector2 = createSelectorCreator(...args);
    const createDraftSafeSelector2 = Object.assign((...args2) => {
      const selector = createSelector2(...args2);
      const wrappedSelector = (value, ...rest) => selector(isDraft(value) ? current(value) : value, ...rest);
      Object.assign(wrappedSelector, selector);
      return wrappedSelector;
    }, {
      withTypes: () => createDraftSafeSelector2
    });
    return createDraftSafeSelector2;
  };
  var createDraftSafeSelector = /* @__PURE__ */ createDraftSafeSelectorCreator(weakMapMemoize);
  var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
    if (arguments.length === 0) return void 0;
    if (typeof arguments[0] === "object") return compose;
    return compose.apply(null, arguments);
  };
  var devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
    return function(noop32) {
      return noop32;
    };
  };
  var hasMatchFunction = (v) => {
    return v && typeof v.match === "function";
  };
  function createAction(type, prepareAction) {
    function actionCreator(...args) {
      if (prepareAction) {
        let prepared = prepareAction(...args);
        if (!prepared) {
          throw new Error(false ? formatProdErrorMessage(0) : "prepareAction did not return an object");
        }
        return {
          type,
          payload: prepared.payload,
          ..."meta" in prepared && {
            meta: prepared.meta
          },
          ..."error" in prepared && {
            error: prepared.error
          }
        };
      }
      return {
        type,
        payload: args[0]
      };
    }
    actionCreator.toString = () => `${type}`;
    actionCreator.type = type;
    actionCreator.match = (action) => isAction(action) && action.type === type;
    return actionCreator;
  }
  function isActionCreator(action) {
    return typeof action === "function" && "type" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it
    hasMatchFunction(action);
  }
  function isFSA(action) {
    return isAction(action) && Object.keys(action).every(isValidKey);
  }
  function isValidKey(key) {
    return ["type", "payload", "error", "meta"].indexOf(key) > -1;
  }
  function getMessage(type) {
    const splitType = type ? `${type}`.split("/") : [];
    const actionName = splitType[splitType.length - 1] || "actionCreator";
    return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
  }
  function createActionCreatorInvariantMiddleware(options2 = {}) {
    if (false) {
      return () => (next2) => (action) => next2(action);
    }
    const {
      isActionCreator: isActionCreator2 = isActionCreator
    } = options2;
    return () => (next2) => (action) => {
      if (isActionCreator2(action)) {
        console.warn(getMessage(action.type));
      }
      return next2(action);
    };
  }
  function getTimeMeasureUtils(maxDelay, fnName) {
    let elapsed = 0;
    return {
      measureTime(fn) {
        const started = Date.now();
        try {
          return fn();
        } finally {
          const finished = Date.now();
          elapsed += finished - started;
        }
      },
      warnIfExceeded() {
        if (elapsed > maxDelay) {
          console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
        }
      }
    };
  }
  var Tuple = class _Tuple extends Array {
    constructor(...items) {
      super(...items);
      Object.setPrototypeOf(this, _Tuple.prototype);
    }
    static get [Symbol.species]() {
      return _Tuple;
    }
    concat(...arr) {
      return super.concat.apply(this, arr);
    }
    prepend(...arr) {
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new _Tuple(...arr[0].concat(this));
      }
      return new _Tuple(...arr.concat(this));
    }
  };
  function freezeDraftable(val) {
    return isDraftable(val) ? produce(val, () => {
    }) : val;
  }
  function getOrInsertComputed(map2, key, compute) {
    if (map2.has(key)) return map2.get(key);
    return map2.set(key, compute(key)).get(key);
  }
  function isImmutableDefault(value) {
    return typeof value !== "object" || value == null || Object.isFrozen(value);
  }
  function trackForMutations(isImmutable, ignorePaths, obj) {
    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
    return {
      detectMutations() {
        return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
      }
    };
  }
  function trackProperties(isImmutable, ignorePaths = [], obj, path = "", checkedObjects = /* @__PURE__ */ new Set()) {
    const tracked = {
      value: obj
    };
    if (!isImmutable(obj) && !checkedObjects.has(obj)) {
      checkedObjects.add(obj);
      tracked.children = {};
      for (const key in obj) {
        const childPath = path ? path + "." + key : key;
        if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {
          continue;
        }
        tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
      }
    }
    return tracked;
  }
  function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = "") {
    const prevObj = trackedProperty ? trackedProperty.value : void 0;
    const sameRef = prevObj === obj;
    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
      return {
        wasMutated: true,
        path
      };
    }
    if (isImmutable(prevObj) || isImmutable(obj)) {
      return {
        wasMutated: false
      };
    }
    const keysToDetect = {};
    for (let key in trackedProperty.children) {
      keysToDetect[key] = true;
    }
    for (let key in obj) {
      keysToDetect[key] = true;
    }
    const hasIgnoredPaths = ignoredPaths.length > 0;
    for (let key in keysToDetect) {
      const nestedPath = path ? path + "." + key : key;
      if (hasIgnoredPaths) {
        const hasMatches = ignoredPaths.some((ignored) => {
          if (ignored instanceof RegExp) {
            return ignored.test(nestedPath);
          }
          return nestedPath === ignored;
        });
        if (hasMatches) {
          continue;
        }
      }
      const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
      if (result.wasMutated) {
        return result;
      }
    }
    return {
      wasMutated: false
    };
  }
  function createImmutableStateInvariantMiddleware(options2 = {}) {
    if (false) {
      return () => (next2) => (action) => next2(action);
    } else {
      let stringify22 = function(obj, serializer, indent, decycler) {
        return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
      }, getSerialize2 = function(serializer, decycler) {
        let stack = [], keys = [];
        if (!decycler) decycler = function(_, value) {
          if (stack[0] === value) return "[Circular ~]";
          return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
        };
        return function(key, value) {
          if (stack.length > 0) {
            var thisPos = stack.indexOf(this);
            ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
            ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
            if (~stack.indexOf(value)) value = decycler.call(this, key, value);
          } else stack.push(value);
          return serializer == null ? value : serializer.call(this, key, value);
        };
      };
      var stringify2 = stringify22, getSerialize = getSerialize2;
      let {
        isImmutable = isImmutableDefault,
        ignoredPaths,
        warnAfter = 32
      } = options2;
      const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
      return ({
        getState
      }) => {
        let state = getState();
        let tracker = track(state);
        let result;
        return (next2) => (action) => {
          const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
          measureUtils.measureTime(() => {
            state = getState();
            result = tracker.detectMutations();
            tracker = track(state);
            if (result.wasMutated) {
              throw new Error(false ? formatProdErrorMessage(19) : `A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
            }
          });
          const dispatchedAction = next2(action);
          measureUtils.measureTime(() => {
            state = getState();
            result = tracker.detectMutations();
            tracker = track(state);
            if (result.wasMutated) {
              throw new Error(false ? formatProdErrorMessage(20) : `A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify22(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
            }
          });
          measureUtils.warnIfExceeded();
          return dispatchedAction;
        };
      };
    }
  }
  function isPlain(val) {
    const type = typeof val;
    return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject(val);
  }
  function findNonSerializableValue(value, path = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache4) {
    let foundNestedSerializable;
    if (!isSerializable(value)) {
      return {
        keyPath: path || "<root>",
        value
      };
    }
    if (typeof value !== "object" || value === null) {
      return false;
    }
    if (cache4?.has(value)) return false;
    const entries = getEntries != null ? getEntries(value) : Object.entries(value);
    const hasIgnoredPaths = ignoredPaths.length > 0;
    for (const [key, nestedValue] of entries) {
      const nestedPath = path ? path + "." + key : key;
      if (hasIgnoredPaths) {
        const hasMatches = ignoredPaths.some((ignored) => {
          if (ignored instanceof RegExp) {
            return ignored.test(nestedPath);
          }
          return nestedPath === ignored;
        });
        if (hasMatches) {
          continue;
        }
      }
      if (!isSerializable(nestedValue)) {
        return {
          keyPath: nestedPath,
          value: nestedValue
        };
      }
      if (typeof nestedValue === "object") {
        foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache4);
        if (foundNestedSerializable) {
          return foundNestedSerializable;
        }
      }
    }
    if (cache4 && isNestedFrozen(value)) cache4.add(value);
    return false;
  }
  function isNestedFrozen(value) {
    if (!Object.isFrozen(value)) return false;
    for (const nestedValue of Object.values(value)) {
      if (typeof nestedValue !== "object" || nestedValue === null) continue;
      if (!isNestedFrozen(nestedValue)) return false;
    }
    return true;
  }
  function createSerializableStateInvariantMiddleware(options2 = {}) {
    if (false) {
      return () => (next2) => (action) => next2(action);
    } else {
      const {
        isSerializable = isPlain,
        getEntries,
        ignoredActions = [],
        ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"],
        ignoredPaths = [],
        warnAfter = 32,
        ignoreState = false,
        ignoreActions = false,
        disableCache = false
      } = options2;
      const cache4 = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
      return (storeAPI) => (next2) => (action) => {
        if (!isAction(action)) {
          return next2(action);
        }
        const result = next2(action);
        const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
        if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {
          measureUtils.measureTime(() => {
            const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache4);
            if (foundActionNonSerializableValue) {
              const {
                keyPath,
                value
              } = foundActionNonSerializableValue;
              console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
            }
          });
        }
        if (!ignoreState) {
          measureUtils.measureTime(() => {
            const state = storeAPI.getState();
            const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache4);
            if (foundStateNonSerializableValue) {
              const {
                keyPath,
                value
              } = foundStateNonSerializableValue;
              console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
            }
          });
          measureUtils.warnIfExceeded();
        }
        return result;
      };
    }
  }
  function isBoolean(x2) {
    return typeof x2 === "boolean";
  }
  var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options2) {
    const {
      thunk: thunk2 = true,
      immutableCheck = true,
      serializableCheck = true,
      actionCreatorCheck = true
    } = options2 ?? {};
    let middlewareArray = new Tuple();
    if (thunk2) {
      if (isBoolean(thunk2)) {
        middlewareArray.push(thunk);
      } else {
        middlewareArray.push(withExtraArgument(thunk2.extraArgument));
      }
    }
    if (true) {
      if (immutableCheck) {
        let immutableOptions = {};
        if (!isBoolean(immutableCheck)) {
          immutableOptions = immutableCheck;
        }
        middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
      }
      if (serializableCheck) {
        let serializableOptions = {};
        if (!isBoolean(serializableCheck)) {
          serializableOptions = serializableCheck;
        }
        middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
      }
      if (actionCreatorCheck) {
        let actionCreatorOptions = {};
        if (!isBoolean(actionCreatorCheck)) {
          actionCreatorOptions = actionCreatorCheck;
        }
        middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
      }
    }
    return middlewareArray;
  };
  var SHOULD_AUTOBATCH = "RTK_autoBatch";
  var prepareAutoBatched = () => (payload) => ({
    payload,
    meta: {
      [SHOULD_AUTOBATCH]: true
    }
  });
  var createQueueWithTimer = (timeout2) => {
    return (notify) => {
      setTimeout(notify, timeout2);
    };
  };
  var autoBatchEnhancer = (options2 = {
    type: "raf"
  }) => (next2) => (...args) => {
    const store2 = next2(...args);
    let notifying = true;
    let shouldNotifyAtEndOfTick = false;
    let notificationQueued = false;
    const listeners = /* @__PURE__ */ new Set();
    const queueCallback = options2.type === "tick" ? queueMicrotask : options2.type === "raf" ? (
      // requestAnimationFrame won't exist in SSR environments. Fall back to a vague approximation just to keep from erroring.
      typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10)
    ) : options2.type === "callback" ? options2.queueNotification : createQueueWithTimer(options2.timeout);
    const notifyListeners = () => {
      notificationQueued = false;
      if (shouldNotifyAtEndOfTick) {
        shouldNotifyAtEndOfTick = false;
        listeners.forEach((l) => l());
      }
    };
    return Object.assign({}, store2, {
      // Override the base `store.subscribe` method to keep original listeners
      // from running if we're delaying notifications
      subscribe(listener22) {
        const wrappedListener = () => notifying && listener22();
        const unsubscribe = store2.subscribe(wrappedListener);
        listeners.add(listener22);
        return () => {
          unsubscribe();
          listeners.delete(listener22);
        };
      },
      // Override the base `store.dispatch` method so that we can check actions
      // for the `shouldAutoBatch` flag and determine if batching is active
      dispatch(action) {
        try {
          notifying = !action?.meta?.[SHOULD_AUTOBATCH];
          shouldNotifyAtEndOfTick = !notifying;
          if (shouldNotifyAtEndOfTick) {
            if (!notificationQueued) {
              notificationQueued = true;
              queueCallback(notifyListeners);
            }
          }
          return store2.dispatch(action);
        } finally {
          notifying = true;
        }
      }
    });
  };
  var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options2) {
    const {
      autoBatch = true
    } = options2 ?? {};
    let enhancerArray = new Tuple(middlewareEnhancer);
    if (autoBatch) {
      enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
    }
    return enhancerArray;
  };
  function configureStore(options2) {
    const getDefaultMiddleware = buildGetDefaultMiddleware();
    const {
      reducer = void 0,
      middleware: middleware2,
      devTools = true,
      preloadedState = void 0,
      enhancers = void 0
    } = options2 || {};
    let rootReducer;
    if (typeof reducer === "function") {
      rootReducer = reducer;
    } else if (isPlainObject(reducer)) {
      rootReducer = combineReducers(reducer);
    } else {
      throw new Error(false ? formatProdErrorMessage(1) : "`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
    }
    if (middleware2 && typeof middleware2 !== "function") {
      throw new Error(false ? formatProdErrorMessage(2) : "`middleware` field must be a callback");
    }
    let finalMiddleware;
    if (typeof middleware2 === "function") {
      finalMiddleware = middleware2(getDefaultMiddleware);
      if (!Array.isArray(finalMiddleware)) {
        throw new Error(false ? formatProdErrorMessage(3) : "when using a middleware builder function, an array of middleware must be returned");
      }
    } else {
      finalMiddleware = getDefaultMiddleware();
    }
    if (finalMiddleware.some((item) => typeof item !== "function")) {
      throw new Error(false ? formatProdErrorMessage(4) : "each middleware provided to configureStore must be a function");
    }
    let finalCompose = compose;
    if (devTools) {
      finalCompose = composeWithDevTools({
        // Enable capture of stack traces for dispatched Redux actions
        trace: true,
        ...typeof devTools === "object" && devTools
      });
    }
    const middlewareEnhancer = applyMiddleware(...finalMiddleware);
    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
    if (enhancers && typeof enhancers !== "function") {
      throw new Error(false ? formatProdErrorMessage(5) : "`enhancers` field must be a callback");
    }
    let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
    if (!Array.isArray(storeEnhancers)) {
      throw new Error(false ? formatProdErrorMessage(6) : "`enhancers` callback must return an array");
    }
    if (storeEnhancers.some((item) => typeof item !== "function")) {
      throw new Error(false ? formatProdErrorMessage(7) : "each enhancer provided to configureStore must be a function");
    }
    if (finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {
      console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
    }
    const composedEnhancer = finalCompose(...storeEnhancers);
    return createStore(rootReducer, preloadedState, composedEnhancer);
  }
  function executeReducerBuilderCallback(builderCallback) {
    const actionsMap = {};
    const actionMatchers = [];
    let defaultCaseReducer;
    const builder = {
      addCase(typeOrActionCreator, reducer) {
        if (true) {
          if (actionMatchers.length > 0) {
            throw new Error(false ? formatProdErrorMessage(26) : "`builder.addCase` should only be called before calling `builder.addMatcher`");
          }
          if (defaultCaseReducer) {
            throw new Error(false ? formatProdErrorMessage(27) : "`builder.addCase` should only be called before calling `builder.addDefaultCase`");
          }
        }
        const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
        if (!type) {
          throw new Error(false ? formatProdErrorMessage(28) : "`builder.addCase` cannot be called with an empty action type");
        }
        if (type in actionsMap) {
          throw new Error(false ? formatProdErrorMessage(29) : `\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
        }
        actionsMap[type] = reducer;
        return builder;
      },
      addMatcher(matcher, reducer) {
        if (true) {
          if (defaultCaseReducer) {
            throw new Error(false ? formatProdErrorMessage(30) : "`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
          }
        }
        actionMatchers.push({
          matcher,
          reducer
        });
        return builder;
      },
      addDefaultCase(reducer) {
        if (true) {
          if (defaultCaseReducer) {
            throw new Error(false ? formatProdErrorMessage(31) : "`builder.addDefaultCase` can only be called once");
          }
        }
        defaultCaseReducer = reducer;
        return builder;
      }
    };
    builderCallback(builder);
    return [actionsMap, actionMatchers, defaultCaseReducer];
  }
  function isStateFunction(x2) {
    return typeof x2 === "function";
  }
  function createReducer(initialState6, mapOrBuilderCallback) {
    if (true) {
      if (typeof mapOrBuilderCallback === "object") {
        throw new Error(false ? formatProdErrorMessage(8) : "The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
      }
    }
    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
    let getInitialState;
    if (isStateFunction(initialState6)) {
      getInitialState = () => freezeDraftable(initialState6());
    } else {
      const frozenInitialState = freezeDraftable(initialState6);
      getInitialState = () => frozenInitialState;
    }
    function reducer(state = getInitialState(), action) {
      let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({
        matcher
      }) => matcher(action)).map(({
        reducer: reducer2
      }) => reducer2)];
      if (caseReducers.filter((cr) => !!cr).length === 0) {
        caseReducers = [finalDefaultCaseReducer];
      }
      return caseReducers.reduce((previousState, caseReducer) => {
        if (caseReducer) {
          if (isDraft(previousState)) {
            const draft = previousState;
            const result = caseReducer(draft, action);
            if (result === void 0) {
              return previousState;
            }
            return result;
          } else if (!isDraftable(previousState)) {
            const result = caseReducer(previousState, action);
            if (result === void 0) {
              if (previousState === null) {
                return previousState;
              }
              throw Error("A case reducer on a non-draftable value must not return undefined");
            }
            return result;
          } else {
            return produce(previousState, (draft) => {
              return caseReducer(draft, action);
            });
          }
        }
        return previousState;
      }, state);
    }
    reducer.getInitialState = getInitialState;
    return reducer;
  }
  var matches = (matcher, action) => {
    if (hasMatchFunction(matcher)) {
      return matcher.match(action);
    } else {
      return matcher(action);
    }
  };
  function isAnyOf(...matchers) {
    return (action) => {
      return matchers.some((matcher) => matches(matcher, action));
    };
  }
  function isAllOf(...matchers) {
    return (action) => {
      return matchers.every((matcher) => matches(matcher, action));
    };
  }
  function hasExpectedRequestMetadata(action, validStatus) {
    if (!action || !action.meta) return false;
    const hasValidRequestId = typeof action.meta.requestId === "string";
    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
    return hasValidRequestId && hasValidRequestStatus;
  }
  function isAsyncThunkArray(a) {
    return typeof a[0] === "function" && "pending" in a[0] && "fulfilled" in a[0] && "rejected" in a[0];
  }
  function isPending(...asyncThunks) {
    if (asyncThunks.length === 0) {
      return (action) => hasExpectedRequestMetadata(action, ["pending"]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isPending()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.pending));
  }
  function isRejected(...asyncThunks) {
    if (asyncThunks.length === 0) {
      return (action) => hasExpectedRequestMetadata(action, ["rejected"]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isRejected()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.rejected));
  }
  function isRejectedWithValue(...asyncThunks) {
    const hasFlag = (action) => {
      return action && action.meta && action.meta.rejectedWithValue;
    };
    if (asyncThunks.length === 0) {
      return isAllOf(isRejected(...asyncThunks), hasFlag);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isRejectedWithValue()(asyncThunks[0]);
    }
    return isAllOf(isRejected(...asyncThunks), hasFlag);
  }
  function isFulfilled(...asyncThunks) {
    if (asyncThunks.length === 0) {
      return (action) => hasExpectedRequestMetadata(action, ["fulfilled"]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isFulfilled()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.map((asyncThunk) => asyncThunk.fulfilled));
  }
  function isAsyncThunkAction(...asyncThunks) {
    if (asyncThunks.length === 0) {
      return (action) => hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
    }
    if (!isAsyncThunkArray(asyncThunks)) {
      return isAsyncThunkAction()(asyncThunks[0]);
    }
    return isAnyOf(...asyncThunks.flatMap((asyncThunk) => [asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled]));
  }
  var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
  var nanoid = (size = 21) => {
    let id = "";
    let i = size;
    while (i--) {
      id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
  };
  var commonProperties = ["name", "message", "stack", "code"];
  var RejectWithValue = class {
    constructor(payload, meta) {
      /*
      type-only property to distinguish between RejectWithValue and FulfillWithMeta
      does not exist at runtime
      */
      __publicField(this, "_type");
      this.payload = payload;
      this.meta = meta;
    }
  };
  var FulfillWithMeta = class {
    constructor(payload, meta) {
      /*
      type-only property to distinguish between RejectWithValue and FulfillWithMeta
      does not exist at runtime
      */
      __publicField(this, "_type");
      this.payload = payload;
      this.meta = meta;
    }
  };
  var miniSerializeError = (value) => {
    if (typeof value === "object" && value !== null) {
      const simpleError = {};
      for (const property of commonProperties) {
        if (typeof value[property] === "string") {
          simpleError[property] = value[property];
        }
      }
      return simpleError;
    }
    return {
      message: String(value)
    };
  };
  var externalAbortMessage = "External signal was aborted";
  var createAsyncThunk = /* @__PURE__ */ (() => {
    function createAsyncThunk2(typePrefix, payloadCreator, options2) {
      const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
        payload,
        meta: {
          ...meta || {},
          arg,
          requestId,
          requestStatus: "fulfilled"
        }
      }));
      const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
        payload: void 0,
        meta: {
          ...meta || {},
          arg,
          requestId,
          requestStatus: "pending"
        }
      }));
      const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
        payload,
        error: (options2 && options2.serializeError || miniSerializeError)(error || "Rejected"),
        meta: {
          ...meta || {},
          arg,
          requestId,
          rejectedWithValue: !!payload,
          requestStatus: "rejected",
          aborted: error?.name === "AbortError",
          condition: error?.name === "ConditionError"
        }
      }));
      function actionCreator(arg, {
        signal
      } = {}) {
        return (dispatch, getState, extra) => {
          const requestId = options2?.idGenerator ? options2.idGenerator(arg) : nanoid();
          const abortController = new AbortController();
          let abortHandler;
          let abortReason;
          function abort(reason) {
            abortReason = reason;
            abortController.abort();
          }
          if (signal) {
            if (signal.aborted) {
              abort(externalAbortMessage);
            } else {
              signal.addEventListener("abort", () => abort(externalAbortMessage), {
                once: true
              });
            }
          }
          const promise = async function() {
            let finalAction;
            try {
              let conditionResult = options2?.condition?.(arg, {
                getState,
                extra
              });
              if (isThenable(conditionResult)) {
                conditionResult = await conditionResult;
              }
              if (conditionResult === false || abortController.signal.aborted) {
                throw {
                  name: "ConditionError",
                  message: "Aborted due to condition callback returning false."
                };
              }
              const abortedPromise = new Promise((_, reject) => {
                abortHandler = () => {
                  reject({
                    name: "AbortError",
                    message: abortReason || "Aborted"
                  });
                };
                abortController.signal.addEventListener("abort", abortHandler);
              });
              dispatch(pending(requestId, arg, options2?.getPendingMeta?.({
                requestId,
                arg
              }, {
                getState,
                extra
              })));
              finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
                dispatch,
                getState,
                extra,
                requestId,
                signal: abortController.signal,
                abort,
                rejectWithValue: (value, meta) => {
                  return new RejectWithValue(value, meta);
                },
                fulfillWithValue: (value, meta) => {
                  return new FulfillWithMeta(value, meta);
                }
              })).then((result) => {
                if (result instanceof RejectWithValue) {
                  throw result;
                }
                if (result instanceof FulfillWithMeta) {
                  return fulfilled(result.payload, requestId, arg, result.meta);
                }
                return fulfilled(result, requestId, arg);
              })]);
            } catch (err) {
              finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
            } finally {
              if (abortHandler) {
                abortController.signal.removeEventListener("abort", abortHandler);
              }
            }
            const skipDispatch = options2 && !options2.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
            if (!skipDispatch) {
              dispatch(finalAction);
            }
            return finalAction;
          }();
          return Object.assign(promise, {
            abort,
            requestId,
            arg,
            unwrap() {
              return promise.then(unwrapResult);
            }
          });
        };
      }
      return Object.assign(actionCreator, {
        pending,
        rejected,
        fulfilled,
        settled: isAnyOf(rejected, fulfilled),
        typePrefix
      });
    }
    createAsyncThunk2.withTypes = () => createAsyncThunk2;
    return createAsyncThunk2;
  })();
  function unwrapResult(action) {
    if (action.meta && action.meta.rejectedWithValue) {
      throw action.payload;
    }
    if (action.error) {
      throw action.error;
    }
    return action.payload;
  }
  function isThenable(value) {
    return value !== null && typeof value === "object" && typeof value.then === "function";
  }
  var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
  var asyncThunkCreator = {
    [asyncThunkSymbol]: createAsyncThunk
  };
  function getType(slice2, actionKey) {
    return `${slice2}/${actionKey}`;
  }
  function buildCreateSlice({
    creators
  } = {}) {
    const cAT = creators?.asyncThunk?.[asyncThunkSymbol];
    return function createSlice2(options2) {
      const {
        name,
        reducerPath = name
      } = options2;
      if (!name) {
        throw new Error(false ? formatProdErrorMessage(11) : "`name` is a required option for createSlice");
      }
      if (typeof process !== "undefined" && true) {
        if (options2.initialState === void 0) {
          console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
        }
      }
      const reducers = (typeof options2.reducers === "function" ? options2.reducers(buildReducerCreators()) : options2.reducers) || {};
      const reducerNames = Object.keys(reducers);
      const context = {
        sliceCaseReducersByName: {},
        sliceCaseReducersByType: {},
        actionCreators: {},
        sliceMatchers: []
      };
      const contextMethods = {
        addCase(typeOrActionCreator, reducer2) {
          const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
          if (!type) {
            throw new Error(false ? formatProdErrorMessage(12) : "`context.addCase` cannot be called with an empty action type");
          }
          if (type in context.sliceCaseReducersByType) {
            throw new Error(false ? formatProdErrorMessage(13) : "`context.addCase` cannot be called with two reducers for the same action type: " + type);
          }
          context.sliceCaseReducersByType[type] = reducer2;
          return contextMethods;
        },
        addMatcher(matcher, reducer2) {
          context.sliceMatchers.push({
            matcher,
            reducer: reducer2
          });
          return contextMethods;
        },
        exposeAction(name2, actionCreator) {
          context.actionCreators[name2] = actionCreator;
          return contextMethods;
        },
        exposeCaseReducer(name2, reducer2) {
          context.sliceCaseReducersByName[name2] = reducer2;
          return contextMethods;
        }
      };
      reducerNames.forEach((reducerName) => {
        const reducerDefinition = reducers[reducerName];
        const reducerDetails = {
          reducerName,
          type: getType(name, reducerName),
          createNotation: typeof options2.reducers === "function"
        };
        if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {
          handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
        } else {
          handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
        }
      });
      function buildReducer() {
        if (true) {
          if (typeof options2.extraReducers === "object") {
            throw new Error(false ? formatProdErrorMessage(14) : "The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
          }
        }
        const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options2.extraReducers === "function" ? executeReducerBuilderCallback(options2.extraReducers) : [options2.extraReducers];
        const finalCaseReducers = {
          ...extraReducers,
          ...context.sliceCaseReducersByType
        };
        return createReducer(options2.initialState, (builder) => {
          for (let key in finalCaseReducers) {
            builder.addCase(key, finalCaseReducers[key]);
          }
          for (let sM of context.sliceMatchers) {
            builder.addMatcher(sM.matcher, sM.reducer);
          }
          for (let m of actionMatchers) {
            builder.addMatcher(m.matcher, m.reducer);
          }
          if (defaultCaseReducer) {
            builder.addDefaultCase(defaultCaseReducer);
          }
        });
      }
      const selectSelf = (state) => state;
      const injectedSelectorCache = /* @__PURE__ */ new Map();
      let _reducer;
      function reducer(state, action) {
        if (!_reducer) _reducer = buildReducer();
        return _reducer(state, action);
      }
      function getInitialState() {
        if (!_reducer) _reducer = buildReducer();
        return _reducer.getInitialState();
      }
      function makeSelectorProps(reducerPath2, injected = false) {
        function selectSlice(state) {
          let sliceState = state[reducerPath2];
          if (typeof sliceState === "undefined") {
            if (injected) {
              sliceState = getInitialState();
            } else if (true) {
              throw new Error(false ? formatProdErrorMessage(15) : "selectSlice returned undefined for an uninjected slice reducer");
            }
          }
          return sliceState;
        }
        function getSelectors(selectState = selectSelf) {
          const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
          return getOrInsertComputed(selectorCache, selectState, () => {
            const map2 = {};
            for (const [name2, selector] of Object.entries(options2.selectors ?? {})) {
              map2[name2] = wrapSelector(selector, selectState, getInitialState, injected);
            }
            return map2;
          });
        }
        return {
          reducerPath: reducerPath2,
          getSelectors,
          get selectors() {
            return getSelectors(selectSlice);
          },
          selectSlice
        };
      }
      const slice2 = {
        name,
        reducer,
        actions: context.actionCreators,
        caseReducers: context.sliceCaseReducersByName,
        getInitialState,
        ...makeSelectorProps(reducerPath),
        injectInto(injectable, {
          reducerPath: pathOpt,
          ...config2
        } = {}) {
          const newReducerPath = pathOpt ?? reducerPath;
          injectable.inject({
            reducerPath: newReducerPath,
            reducer
          }, config2);
          return {
            ...slice2,
            ...makeSelectorProps(newReducerPath, true)
          };
        }
      };
      return slice2;
    };
  }
  function wrapSelector(selector, selectState, getInitialState, injected) {
    function wrapper(rootState, ...args) {
      let sliceState = selectState(rootState);
      if (typeof sliceState === "undefined") {
        if (injected) {
          sliceState = getInitialState();
        } else if (true) {
          throw new Error(false ? formatProdErrorMessage(16) : "selectState returned undefined for an uninjected slice reducer");
        }
      }
      return selector(sliceState, ...args);
    }
    wrapper.unwrapped = selector;
    return wrapper;
  }
  var createSlice = /* @__PURE__ */ buildCreateSlice();
  function buildReducerCreators() {
    function asyncThunk(payloadCreator, config2) {
      return {
        _reducerDefinitionType: "asyncThunk",
        payloadCreator,
        ...config2
      };
    }
    asyncThunk.withTypes = () => asyncThunk;
    return {
      reducer(caseReducer) {
        return Object.assign({
          // hack so the wrapping function has the same name as the original
          // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
          [caseReducer.name](...args) {
            return caseReducer(...args);
          }
        }[caseReducer.name], {
          _reducerDefinitionType: "reducer"
          /* reducer */
        });
      },
      preparedReducer(prepare, reducer) {
        return {
          _reducerDefinitionType: "reducerWithPrepare",
          prepare,
          reducer
        };
      },
      asyncThunk
    };
  }
  function handleNormalReducerDefinition({
    type,
    reducerName,
    createNotation
  }, maybeReducerWithPrepare, context) {
    let caseReducer;
    let prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {
        throw new Error(false ? formatProdErrorMessage(17) : "Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
      }
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
  }
  function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "asyncThunk";
  }
  function isCaseReducerWithPrepareDefinition(reducerDefinition) {
    return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
  }
  function handleThunkCaseReducerDefinition({
    type,
    reducerName
  }, reducerDefinition, context, cAT) {
    if (!cAT) {
      throw new Error(false ? formatProdErrorMessage(18) : "Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
    }
    const {
      payloadCreator,
      fulfilled,
      pending,
      rejected,
      settled,
      options: options2
    } = reducerDefinition;
    const thunk2 = cAT(type, payloadCreator, options2);
    context.exposeAction(reducerName, thunk2);
    if (fulfilled) {
      context.addCase(thunk2.fulfilled, fulfilled);
    }
    if (pending) {
      context.addCase(thunk2.pending, pending);
    }
    if (rejected) {
      context.addCase(thunk2.rejected, rejected);
    }
    if (settled) {
      context.addMatcher(thunk2.settled, settled);
    }
    context.exposeCaseReducer(reducerName, {
      fulfilled: fulfilled || noop,
      pending: pending || noop,
      rejected: rejected || noop,
      settled: settled || noop
    });
  }
  function noop() {
  }
  function getInitialEntityState() {
    return {
      ids: [],
      entities: {}
    };
  }
  function createInitialStateFactory(stateAdapter) {
    function getInitialState(additionalState = {}, entities) {
      const state = Object.assign(getInitialEntityState(), additionalState);
      return entities ? stateAdapter.setAll(state, entities) : state;
    }
    return {
      getInitialState
    };
  }
  function createSelectorsFactory() {
    function getSelectors(selectState, options2 = {}) {
      const {
        createSelector: createSelector2 = createDraftSafeSelector
      } = options2;
      const selectIds = (state) => state.ids;
      const selectEntities = (state) => state.entities;
      const selectAll = createSelector2(selectIds, selectEntities, (ids, entities) => ids.map((id) => entities[id]));
      const selectId = (_, id) => id;
      const selectById = (entities, id) => entities[id];
      const selectTotal = createSelector2(selectIds, (ids) => ids.length);
      if (!selectState) {
        return {
          selectIds,
          selectEntities,
          selectAll,
          selectTotal,
          selectById: createSelector2(selectEntities, selectId, selectById)
        };
      }
      const selectGlobalizedEntities = createSelector2(selectState, selectEntities);
      return {
        selectIds: createSelector2(selectState, selectIds),
        selectEntities: selectGlobalizedEntities,
        selectAll: createSelector2(selectState, selectAll),
        selectTotal: createSelector2(selectState, selectTotal),
        selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)
      };
    }
    return {
      getSelectors
    };
  }
  var isDraftTyped = isDraft;
  function createSingleArgumentStateOperator(mutator) {
    const operator = createStateOperator((_, state) => mutator(state));
    return function operation(state) {
      return operator(state, void 0);
    };
  }
  function createStateOperator(mutator) {
    return function operation(state, arg) {
      function isPayloadActionArgument(arg2) {
        return isFSA(arg2);
      }
      const runMutator = (draft) => {
        if (isPayloadActionArgument(arg)) {
          mutator(arg.payload, draft);
        } else {
          mutator(arg, draft);
        }
      };
      if (isDraftTyped(state)) {
        runMutator(state);
        return state;
      }
      return produce(state, runMutator);
    };
  }
  function selectIdValue(entity, selectId) {
    const key = selectId(entity);
    if (key === void 0) {
      console.warn("The entity passed to the `selectId` implementation returned undefined.", "You should probably provide your own `selectId` implementation.", "The entity that was passed:", entity, "The `selectId` implementation:", selectId.toString());
    }
    return key;
  }
  function ensureEntitiesArray(entities) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }
    return entities;
  }
  function getCurrent(value) {
    return isDraft(value) ? current(value) : value;
  }
  function splitAddedUpdatedEntities(newEntities, selectId, state) {
    newEntities = ensureEntitiesArray(newEntities);
    const existingIdsArray = getCurrent(state.ids);
    const existingIds = new Set(existingIdsArray);
    const added = [];
    const updated = [];
    for (const entity of newEntities) {
      const id = selectIdValue(entity, selectId);
      if (existingIds.has(id)) {
        updated.push({
          id,
          changes: entity
        });
      } else {
        added.push(entity);
      }
    }
    return [added, updated, existingIdsArray];
  }
  function createUnsortedStateAdapter(selectId) {
    function addOneMutably(entity, state) {
      const key = selectIdValue(entity, selectId);
      if (key in state.entities) {
        return;
      }
      state.ids.push(key);
      state.entities[key] = entity;
    }
    function addManyMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      for (const entity of newEntities) {
        addOneMutably(entity, state);
      }
    }
    function setOneMutably(entity, state) {
      const key = selectIdValue(entity, selectId);
      if (!(key in state.entities)) {
        state.ids.push(key);
      }
      ;
      state.entities[key] = entity;
    }
    function setManyMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      for (const entity of newEntities) {
        setOneMutably(entity, state);
      }
    }
    function setAllMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      state.ids = [];
      state.entities = {};
      addManyMutably(newEntities, state);
    }
    function removeOneMutably(key, state) {
      return removeManyMutably([key], state);
    }
    function removeManyMutably(keys, state) {
      let didMutate = false;
      keys.forEach((key) => {
        if (key in state.entities) {
          delete state.entities[key];
          didMutate = true;
        }
      });
      if (didMutate) {
        state.ids = state.ids.filter((id) => id in state.entities);
      }
    }
    function removeAllMutably(state) {
      Object.assign(state, {
        ids: [],
        entities: {}
      });
    }
    function takeNewKey(keys, update, state) {
      const original3 = state.entities[update.id];
      if (original3 === void 0) {
        return false;
      }
      const updated = Object.assign({}, original3, update.changes);
      const newKey = selectIdValue(updated, selectId);
      const hasNewKey = newKey !== update.id;
      if (hasNewKey) {
        keys[update.id] = newKey;
        delete state.entities[update.id];
      }
      ;
      state.entities[newKey] = updated;
      return hasNewKey;
    }
    function updateOneMutably(update, state) {
      return updateManyMutably([update], state);
    }
    function updateManyMutably(updates, state) {
      const newKeys = {};
      const updatesPerEntity = {};
      updates.forEach((update) => {
        if (update.id in state.entities) {
          updatesPerEntity[update.id] = {
            id: update.id,
            // Spreads ignore falsy values, so this works even if there isn't
            // an existing update already at this key
            changes: {
              ...updatesPerEntity[update.id]?.changes,
              ...update.changes
            }
          };
        }
      });
      updates = Object.values(updatesPerEntity);
      const didMutateEntities = updates.length > 0;
      if (didMutateEntities) {
        const didMutateIds = updates.filter((update) => takeNewKey(newKeys, update, state)).length > 0;
        if (didMutateIds) {
          state.ids = Object.values(state.entities).map((e) => selectIdValue(e, selectId));
        }
      }
    }
    function upsertOneMutably(entity, state) {
      return upsertManyMutably([entity], state);
    }
    function upsertManyMutably(newEntities, state) {
      const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);
      updateManyMutably(updated, state);
      addManyMutably(added, state);
    }
    return {
      removeAll: createSingleArgumentStateOperator(removeAllMutably),
      addOne: createStateOperator(addOneMutably),
      addMany: createStateOperator(addManyMutably),
      setOne: createStateOperator(setOneMutably),
      setMany: createStateOperator(setManyMutably),
      setAll: createStateOperator(setAllMutably),
      updateOne: createStateOperator(updateOneMutably),
      updateMany: createStateOperator(updateManyMutably),
      upsertOne: createStateOperator(upsertOneMutably),
      upsertMany: createStateOperator(upsertManyMutably),
      removeOne: createStateOperator(removeOneMutably),
      removeMany: createStateOperator(removeManyMutably)
    };
  }
  function findInsertIndex(sortedItems, item, comparisonFunction) {
    let lowIndex = 0;
    let highIndex = sortedItems.length;
    while (lowIndex < highIndex) {
      let middleIndex = lowIndex + highIndex >>> 1;
      const currentItem = sortedItems[middleIndex];
      const res = comparisonFunction(item, currentItem);
      if (res >= 0) {
        lowIndex = middleIndex + 1;
      } else {
        highIndex = middleIndex;
      }
    }
    return lowIndex;
  }
  function insert(sortedItems, item, comparisonFunction) {
    const insertAtIndex = findInsertIndex(sortedItems, item, comparisonFunction);
    sortedItems.splice(insertAtIndex, 0, item);
    return sortedItems;
  }
  function createSortedStateAdapter(selectId, comparer) {
    const {
      removeOne,
      removeMany,
      removeAll
    } = createUnsortedStateAdapter(selectId);
    function addOneMutably(entity, state) {
      return addManyMutably([entity], state);
    }
    function addManyMutably(newEntities, state, existingIds) {
      newEntities = ensureEntitiesArray(newEntities);
      const existingKeys = new Set(existingIds ?? getCurrent(state.ids));
      const models = newEntities.filter((model) => !existingKeys.has(selectIdValue(model, selectId)));
      if (models.length !== 0) {
        mergeFunction(state, models);
      }
    }
    function setOneMutably(entity, state) {
      return setManyMutably([entity], state);
    }
    function setManyMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      if (newEntities.length !== 0) {
        for (const item of newEntities) {
          delete state.entities[selectId(item)];
        }
        mergeFunction(state, newEntities);
      }
    }
    function setAllMutably(newEntities, state) {
      newEntities = ensureEntitiesArray(newEntities);
      state.entities = {};
      state.ids = [];
      addManyMutably(newEntities, state, []);
    }
    function updateOneMutably(update, state) {
      return updateManyMutably([update], state);
    }
    function updateManyMutably(updates, state) {
      let appliedUpdates = false;
      let replacedIds = false;
      for (let update of updates) {
        const entity = state.entities[update.id];
        if (!entity) {
          continue;
        }
        appliedUpdates = true;
        Object.assign(entity, update.changes);
        const newId = selectId(entity);
        if (update.id !== newId) {
          replacedIds = true;
          delete state.entities[update.id];
          const oldIndex = state.ids.indexOf(update.id);
          state.ids[oldIndex] = newId;
          state.entities[newId] = entity;
        }
      }
      if (appliedUpdates) {
        mergeFunction(state, [], appliedUpdates, replacedIds);
      }
    }
    function upsertOneMutably(entity, state) {
      return upsertManyMutably([entity], state);
    }
    function upsertManyMutably(newEntities, state) {
      const [added, updated, existingIdsArray] = splitAddedUpdatedEntities(newEntities, selectId, state);
      if (updated.length) {
        updateManyMutably(updated, state);
      }
      if (added.length) {
        addManyMutably(added, state, existingIdsArray);
      }
    }
    function areArraysEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] === b[i]) {
          continue;
        }
        return false;
      }
      return true;
    }
    const mergeFunction = (state, addedItems, appliedUpdates, replacedIds) => {
      const currentEntities = getCurrent(state.entities);
      const currentIds = getCurrent(state.ids);
      const stateEntities = state.entities;
      let ids = currentIds;
      if (replacedIds) {
        ids = new Set(currentIds);
      }
      let sortedEntities = [];
      for (const id of ids) {
        const entity = currentEntities[id];
        if (entity) {
          sortedEntities.push(entity);
        }
      }
      const wasPreviouslyEmpty = sortedEntities.length === 0;
      for (const item of addedItems) {
        stateEntities[selectId(item)] = item;
        if (!wasPreviouslyEmpty) {
          insert(sortedEntities, item, comparer);
        }
      }
      if (wasPreviouslyEmpty) {
        sortedEntities = addedItems.slice().sort(comparer);
      } else if (appliedUpdates) {
        sortedEntities.sort(comparer);
      }
      const newSortedIds = sortedEntities.map(selectId);
      if (!areArraysEqual(currentIds, newSortedIds)) {
        state.ids = newSortedIds;
      }
    };
    return {
      removeOne,
      removeMany,
      removeAll,
      addOne: createStateOperator(addOneMutably),
      updateOne: createStateOperator(updateOneMutably),
      upsertOne: createStateOperator(upsertOneMutably),
      setOne: createStateOperator(setOneMutably),
      setMany: createStateOperator(setManyMutably),
      setAll: createStateOperator(setAllMutably),
      addMany: createStateOperator(addManyMutably),
      updateMany: createStateOperator(updateManyMutably),
      upsertMany: createStateOperator(upsertManyMutably)
    };
  }
  function createEntityAdapter(options2 = {}) {
    const {
      selectId,
      sortComparer
    } = {
      sortComparer: false,
      selectId: (instance) => instance.id,
      ...options2
    };
    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
    const stateFactory = createInitialStateFactory(stateAdapter);
    const selectorsFactory = createSelectorsFactory();
    return {
      selectId,
      sortComparer,
      ...stateFactory,
      ...selectorsFactory,
      ...stateAdapter
    };
  }
  var listener = "listener";
  var completed = "completed";
  var cancelled = "cancelled";
  var taskCancelled = `task-${cancelled}`;
  var taskCompleted = `task-${completed}`;
  var listenerCancelled = `${listener}-${cancelled}`;
  var listenerCompleted = `${listener}-${completed}`;
  var {
    assign
  } = Object;
  var alm = "listenerMiddleware";
  var addListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), {
    withTypes: () => addListener
  });
  var clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);
  var removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), {
    withTypes: () => removeListener
  });
  var ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");

  // node_modules/@reduxjs/toolkit/dist/query/rtk-query.modern.mjs
  var QueryStatus = /* @__PURE__ */ ((QueryStatus2) => {
    QueryStatus2["uninitialized"] = "uninitialized";
    QueryStatus2["pending"] = "pending";
    QueryStatus2["fulfilled"] = "fulfilled";
    QueryStatus2["rejected"] = "rejected";
    return QueryStatus2;
  })(QueryStatus || {});
  function getRequestStatusFlags(status) {
    return {
      status,
      isUninitialized: status === "uninitialized",
      isLoading: status === "pending",
      isSuccess: status === "fulfilled",
      isError: status === "rejected"
      /* rejected */
    };
  }
  var isPlainObject22 = isPlainObject;
  function copyWithStructuralSharing(oldObj, newObj) {
    if (oldObj === newObj || !(isPlainObject22(oldObj) && isPlainObject22(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
      return newObj;
    }
    const newKeys = Object.keys(newObj);
    const oldKeys = Object.keys(oldObj);
    let isSameObject = newKeys.length === oldKeys.length;
    const mergeObj = Array.isArray(newObj) ? [] : {};
    for (const key of newKeys) {
      mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
      if (isSameObject) isSameObject = oldObj[key] === mergeObj[key];
    }
    return isSameObject ? oldObj : mergeObj;
  }
  function countObjectKeys(obj) {
    let count = 0;
    for (const _key in obj) {
      count++;
    }
    return count;
  }
  var flatten = (arr) => [].concat(...arr);
  function isAbsoluteUrl(url2) {
    return new RegExp(`(^|:)//`).test(url2);
  }
  function isDocumentVisible() {
    if (typeof document === "undefined") {
      return true;
    }
    return document.visibilityState !== "hidden";
  }
  function isNotNullish(v) {
    return v != null;
  }
  function isOnline() {
    return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
  }
  var withoutTrailingSlash = (url2) => url2.replace(/\/$/, "");
  var withoutLeadingSlash = (url2) => url2.replace(/^\//, "");
  function joinUrls(base, url2) {
    if (!base) {
      return url2;
    }
    if (!url2) {
      return base;
    }
    if (isAbsoluteUrl(url2)) {
      return url2;
    }
    const delimiter2 = base.endsWith("/") || !url2.startsWith("?") ? "/" : "";
    base = withoutTrailingSlash(base);
    url2 = withoutLeadingSlash(url2);
    return `${base}${delimiter2}${url2}`;
  }
  function getOrInsert(map2, key, value) {
    if (map2.has(key)) return map2.get(key);
    return map2.set(key, value).get(key);
  }
  var defaultFetchFn = (...args) => fetch(...args);
  var defaultValidateStatus = (response) => response.status >= 200 && response.status <= 299;
  var defaultIsJsonContentType = (headers) => (
    /*applicat*/
    /ion\/(vnd\.api\+)?json/.test(headers.get("content-type") || "")
  );
  function stripUndefined(obj) {
    if (!isPlainObject(obj)) {
      return obj;
    }
    const copy2 = {
      ...obj
    };
    for (const [k, v] of Object.entries(copy2)) {
      if (v === void 0) delete copy2[k];
    }
    return copy2;
  }
  function fetchBaseQuery({
    baseUrl: baseUrl2,
    prepareHeaders = (x2) => x2,
    fetchFn = defaultFetchFn,
    paramsSerializer,
    isJsonContentType = defaultIsJsonContentType,
    jsonContentType = "application/json",
    jsonReplacer,
    timeout: defaultTimeout,
    responseHandler: globalResponseHandler,
    validateStatus: globalValidateStatus,
    ...baseFetchOptions
  } = {}) {
    if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
      console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
    }
    return async (arg, api3, extraOptions) => {
      const {
        getState,
        extra,
        endpoint,
        forced,
        type
      } = api3;
      let meta;
      let {
        url: url2,
        headers = new Headers(baseFetchOptions.headers),
        params = void 0,
        responseHandler = globalResponseHandler ?? "json",
        validateStatus = globalValidateStatus ?? defaultValidateStatus,
        timeout: timeout2 = defaultTimeout,
        ...rest
      } = typeof arg == "string" ? {
        url: arg
      } : arg;
      let abortController, signal = api3.signal;
      if (timeout2) {
        abortController = new AbortController();
        api3.signal.addEventListener("abort", abortController.abort);
        signal = abortController.signal;
      }
      let config2 = {
        ...baseFetchOptions,
        signal,
        ...rest
      };
      headers = new Headers(stripUndefined(headers));
      config2.headers = await prepareHeaders(headers, {
        getState,
        arg,
        extra,
        endpoint,
        forced,
        type,
        extraOptions
      }) || headers;
      const isJsonifiable = (body) => typeof body === "object" && (isPlainObject(body) || Array.isArray(body) || typeof body.toJSON === "function");
      if (!config2.headers.has("content-type") && isJsonifiable(config2.body)) {
        config2.headers.set("content-type", jsonContentType);
      }
      if (isJsonifiable(config2.body) && isJsonContentType(config2.headers)) {
        config2.body = JSON.stringify(config2.body, jsonReplacer);
      }
      if (params) {
        const divider = ~url2.indexOf("?") ? "&" : "?";
        const query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
        url2 += divider + query;
      }
      url2 = joinUrls(baseUrl2, url2);
      const request = new Request(url2, config2);
      const requestClone = new Request(url2, config2);
      meta = {
        request: requestClone
      };
      let response, timedOut = false, timeoutId = abortController && setTimeout(() => {
        timedOut = true;
        abortController.abort();
      }, timeout2);
      try {
        response = await fetchFn(request);
      } catch (e) {
        return {
          error: {
            status: timedOut ? "TIMEOUT_ERROR" : "FETCH_ERROR",
            error: String(e)
          },
          meta
        };
      } finally {
        if (timeoutId) clearTimeout(timeoutId);
        abortController?.signal.removeEventListener("abort", abortController.abort);
      }
      const responseClone = response.clone();
      meta.response = responseClone;
      let resultData;
      let responseText = "";
      try {
        let handleResponseError;
        await Promise.all([
          handleResponse(response, responseHandler).then((r2) => resultData = r2, (e) => handleResponseError = e),
          // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182
          // we *have* to "use up" both streams at the same time or they will stop running in node-fetch scenarios
          responseClone.text().then((r2) => responseText = r2, () => {
          })
        ]);
        if (handleResponseError) throw handleResponseError;
      } catch (e) {
        return {
          error: {
            status: "PARSING_ERROR",
            originalStatus: response.status,
            data: responseText,
            error: String(e)
          },
          meta
        };
      }
      return validateStatus(response, resultData) ? {
        data: resultData,
        meta
      } : {
        error: {
          status: response.status,
          data: resultData
        },
        meta
      };
    };
    async function handleResponse(response, responseHandler) {
      if (typeof responseHandler === "function") {
        return responseHandler(response);
      }
      if (responseHandler === "content-type") {
        responseHandler = isJsonContentType(response.headers) ? "json" : "text";
      }
      if (responseHandler === "json") {
        const text2 = await response.text();
        return text2.length ? JSON.parse(text2) : null;
      }
      return response.text();
    }
  }
  var HandledError = class {
    constructor(value, meta = void 0) {
      this.value = value;
      this.meta = meta;
    }
  };
  var onFocus = /* @__PURE__ */ createAction("__rtkq/focused");
  var onFocusLost = /* @__PURE__ */ createAction("__rtkq/unfocused");
  var onOnline = /* @__PURE__ */ createAction("__rtkq/online");
  var onOffline = /* @__PURE__ */ createAction("__rtkq/offline");
  function isQueryDefinition(e) {
    return e.type === "query";
  }
  function isMutationDefinition(e) {
    return e.type === "mutation";
  }
  function isInfiniteQueryDefinition(e) {
    return e.type === "infinitequery";
  }
  function calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {
    if (isFunction(description)) {
      return description(result, error, queryArg, meta).filter(isNotNullish).map(expandTagDescription).map(assertTagTypes);
    }
    if (Array.isArray(description)) {
      return description.map(expandTagDescription).map(assertTagTypes);
    }
    return [];
  }
  function isFunction(t2) {
    return typeof t2 === "function";
  }
  function expandTagDescription(description) {
    return typeof description === "string" ? {
      type: description
    } : description;
  }
  function asSafePromise(promise, fallback) {
    return promise.catch(fallback);
  }
  var forceQueryFnSymbol = Symbol("forceQueryFn");
  var isUpsertQuery = (arg) => typeof arg[forceQueryFnSymbol] === "function";
  function buildInitiate({
    serializeQueryArgs,
    queryThunk,
    infiniteQueryThunk,
    mutationThunk,
    api: api3,
    context
  }) {
    const runningQueries = /* @__PURE__ */ new Map();
    const runningMutations = /* @__PURE__ */ new Map();
    const {
      unsubscribeQueryResult,
      removeMutationResult,
      updateSubscriptionOptions
    } = api3.internalActions;
    return {
      buildInitiateQuery,
      buildInitiateInfiniteQuery,
      buildInitiateMutation,
      getRunningQueryThunk,
      getRunningMutationThunk,
      getRunningQueriesThunk,
      getRunningMutationsThunk
    };
    function getRunningQueryThunk(endpointName, queryArgs) {
      return (dispatch) => {
        const endpointDefinition = context.endpointDefinitions[endpointName];
        const queryCacheKey = serializeQueryArgs({
          queryArgs,
          endpointDefinition,
          endpointName
        });
        return runningQueries.get(dispatch)?.[queryCacheKey];
      };
    }
    function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {
      return (dispatch) => {
        return runningMutations.get(dispatch)?.[fixedCacheKeyOrRequestId];
      };
    }
    function getRunningQueriesThunk() {
      return (dispatch) => Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);
    }
    function getRunningMutationsThunk() {
      return (dispatch) => Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);
    }
    function middlewareWarning(dispatch) {
      if (true) {
        if (middlewareWarning.triggered) return;
        const returnedValue = dispatch(api3.internalActions.internal_getRTKQSubscriptions());
        middlewareWarning.triggered = true;
        if (typeof returnedValue !== "object" || typeof returnedValue?.type === "string") {
          throw new Error(false ? formatProdErrorMessage(34) : `Warning: Middleware for RTK-Query API at reducerPath "${api3.reducerPath}" has not been added to the store.
You must add the middleware for RTK-Query to function correctly!`);
        }
      }
    }
    function buildInitiateAnyQuery(endpointName, endpointDefinition) {
      const queryAction = (arg, {
        subscribe = true,
        forceRefetch,
        subscriptionOptions,
        [forceQueryFnSymbol]: forceQueryFn,
        ...rest
      } = {}) => (dispatch, getState) => {
        const queryCacheKey = serializeQueryArgs({
          queryArgs: arg,
          endpointDefinition,
          endpointName
        });
        let thunk2;
        const commonThunkArgs = {
          ...rest,
          type: "query",
          subscribe,
          forceRefetch,
          subscriptionOptions,
          endpointName,
          originalArgs: arg,
          queryCacheKey,
          [forceQueryFnSymbol]: forceQueryFn
        };
        if (isQueryDefinition(endpointDefinition)) {
          thunk2 = queryThunk(commonThunkArgs);
        } else {
          const {
            direction,
            initialPageParam
          } = rest;
          thunk2 = infiniteQueryThunk({
            ...commonThunkArgs,
            // Supply these even if undefined. This helps with a field existence
            // check over in `buildSlice.ts`
            direction,
            initialPageParam
          });
        }
        const selector = api3.endpoints[endpointName].select(arg);
        const thunkResult = dispatch(thunk2);
        const stateAfter = selector(getState());
        middlewareWarning(dispatch);
        const {
          requestId,
          abort
        } = thunkResult;
        const skippedSynchronously = stateAfter.requestId !== requestId;
        const runningQuery = runningQueries.get(dispatch)?.[queryCacheKey];
        const selectFromState = () => selector(getState());
        const statePromise = Object.assign(forceQueryFn ? (
          // a query has been forced (upsertQueryData)
          // -> we want to resolve it once data has been written with the data that will be written
          thunkResult.then(selectFromState)
        ) : skippedSynchronously && !runningQuery ? (
          // a query has been skipped due to a condition and we do not have any currently running query
          // -> we want to resolve it immediately with the current data
          Promise.resolve(stateAfter)
        ) : (
          // query just started or one is already in flight
          // -> wait for the running query, then resolve with data from after that
          Promise.all([runningQuery, thunkResult]).then(selectFromState)
        ), {
          arg,
          requestId,
          subscriptionOptions,
          queryCacheKey,
          abort,
          async unwrap() {
            const result = await statePromise;
            if (result.isError) {
              throw result.error;
            }
            return result.data;
          },
          refetch: () => dispatch(queryAction(arg, {
            subscribe: false,
            forceRefetch: true
          })),
          unsubscribe() {
            if (subscribe) dispatch(unsubscribeQueryResult({
              queryCacheKey,
              requestId
            }));
          },
          updateSubscriptionOptions(options2) {
            statePromise.subscriptionOptions = options2;
            dispatch(updateSubscriptionOptions({
              endpointName,
              requestId,
              queryCacheKey,
              options: options2
            }));
          }
        });
        if (!runningQuery && !skippedSynchronously && !forceQueryFn) {
          const running = getOrInsert(runningQueries, dispatch, {});
          running[queryCacheKey] = statePromise;
          statePromise.then(() => {
            delete running[queryCacheKey];
            if (!countObjectKeys(running)) {
              runningQueries.delete(dispatch);
            }
          });
        }
        return statePromise;
      };
      return queryAction;
    }
    function buildInitiateQuery(endpointName, endpointDefinition) {
      const queryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
      return queryAction;
    }
    function buildInitiateInfiniteQuery(endpointName, endpointDefinition) {
      const infiniteQueryAction = buildInitiateAnyQuery(endpointName, endpointDefinition);
      return infiniteQueryAction;
    }
    function buildInitiateMutation(endpointName) {
      return (arg, {
        track = true,
        fixedCacheKey
      } = {}) => (dispatch, getState) => {
        const thunk2 = mutationThunk({
          type: "mutation",
          endpointName,
          originalArgs: arg,
          track,
          fixedCacheKey
        });
        const thunkResult = dispatch(thunk2);
        middlewareWarning(dispatch);
        const {
          requestId,
          abort,
          unwrap
        } = thunkResult;
        const returnValuePromise = asSafePromise(thunkResult.unwrap().then((data2) => ({
          data: data2
        })), (error) => ({
          error
        }));
        const reset = () => {
          dispatch(removeMutationResult({
            requestId,
            fixedCacheKey
          }));
        };
        const ret = Object.assign(returnValuePromise, {
          arg: thunkResult.arg,
          requestId,
          abort,
          unwrap,
          reset
        });
        const running = runningMutations.get(dispatch) || {};
        runningMutations.set(dispatch, running);
        running[requestId] = ret;
        ret.then(() => {
          delete running[requestId];
          if (!countObjectKeys(running)) {
            runningMutations.delete(dispatch);
          }
        });
        if (fixedCacheKey) {
          running[fixedCacheKey] = ret;
          ret.then(() => {
            if (running[fixedCacheKey] === ret) {
              delete running[fixedCacheKey];
              if (!countObjectKeys(running)) {
                runningMutations.delete(dispatch);
              }
            }
          });
        }
        return ret;
      };
    }
  }
  function defaultTransformResponse(baseQueryReturnValue) {
    return baseQueryReturnValue;
  }
  var addShouldAutoBatch = (arg = {}) => {
    return {
      ...arg,
      [SHOULD_AUTOBATCH]: true
    };
  };
  function buildThunks({
    reducerPath,
    baseQuery,
    context: {
      endpointDefinitions
    },
    serializeQueryArgs,
    api: api3,
    assertTagType,
    selectors: selectors5
  }) {
    const patchQueryData = (endpointName, arg, patches, updateProvided) => (dispatch, getState) => {
      const endpointDefinition = endpointDefinitions[endpointName];
      const queryCacheKey = serializeQueryArgs({
        queryArgs: arg,
        endpointDefinition,
        endpointName
      });
      dispatch(api3.internalActions.queryResultPatched({
        queryCacheKey,
        patches
      }));
      if (!updateProvided) {
        return;
      }
      const newValue = api3.endpoints[endpointName].select(arg)(
        // Work around TS 4.1 mismatch
        getState()
      );
      const providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, arg, {}, assertTagType);
      dispatch(api3.internalActions.updateProvidedBy({
        queryCacheKey,
        providedTags
      }));
    };
    function addToStart(items, item, max = 0) {
      const newItems = [item, ...items];
      return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
    }
    function addToEnd(items, item, max = 0) {
      const newItems = [...items, item];
      return max && newItems.length > max ? newItems.slice(1) : newItems;
    }
    const updateQueryData = (endpointName, arg, updateRecipe, updateProvided = true) => (dispatch, getState) => {
      const endpointDefinition = api3.endpoints[endpointName];
      const currentState = endpointDefinition.select(arg)(
        // Work around TS 4.1 mismatch
        getState()
      );
      const ret = {
        patches: [],
        inversePatches: [],
        undo: () => dispatch(api3.util.patchQueryData(endpointName, arg, ret.inversePatches, updateProvided))
      };
      if (currentState.status === "uninitialized") {
        return ret;
      }
      let newValue;
      if ("data" in currentState) {
        if (isDraftable(currentState.data)) {
          const [value, patches, inversePatches] = produceWithPatches(currentState.data, updateRecipe);
          ret.patches.push(...patches);
          ret.inversePatches.push(...inversePatches);
          newValue = value;
        } else {
          newValue = updateRecipe(currentState.data);
          ret.patches.push({
            op: "replace",
            path: [],
            value: newValue
          });
          ret.inversePatches.push({
            op: "replace",
            path: [],
            value: currentState.data
          });
        }
      }
      if (ret.patches.length === 0) {
        return ret;
      }
      dispatch(api3.util.patchQueryData(endpointName, arg, ret.patches, updateProvided));
      return ret;
    };
    const upsertQueryData = (endpointName, arg, value) => (dispatch) => {
      const res = dispatch(api3.endpoints[endpointName].initiate(arg, {
        subscribe: false,
        forceRefetch: true,
        [forceQueryFnSymbol]: () => ({
          data: value
        })
      }));
      return res;
    };
    const getTransformCallbackForEndpoint = (endpointDefinition, transformFieldName) => {
      return endpointDefinition.query && endpointDefinition[transformFieldName] ? endpointDefinition[transformFieldName] : defaultTransformResponse;
    };
    const executeEndpoint = async (arg, {
      signal,
      abort,
      rejectWithValue,
      fulfillWithValue,
      dispatch,
      getState,
      extra
    }) => {
      const endpointDefinition = endpointDefinitions[arg.endpointName];
      try {
        let transformResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformResponse");
        const baseQueryApi = {
          signal,
          abort,
          dispatch,
          getState,
          extra,
          endpoint: arg.endpointName,
          type: arg.type,
          forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0,
          queryCacheKey: arg.type === "query" ? arg.queryCacheKey : void 0
        };
        const forceQueryFn = arg.type === "query" ? arg[forceQueryFnSymbol] : void 0;
        let finalQueryReturnValue;
        const fetchPage = async (data2, param, maxPages, previous) => {
          if (param == null && data2.pages.length) {
            return Promise.resolve({
              data: data2
            });
          }
          const finalQueryArg = {
            queryArg: arg.originalArgs,
            pageParam: param
          };
          const pageResponse = await executeRequest(finalQueryArg);
          const addTo = previous ? addToStart : addToEnd;
          return {
            data: {
              pages: addTo(data2.pages, pageResponse.data, maxPages),
              pageParams: addTo(data2.pageParams, param, maxPages)
            }
          };
        };
        async function executeRequest(finalQueryArg) {
          let result;
          const {
            extraOptions
          } = endpointDefinition;
          if (forceQueryFn) {
            result = forceQueryFn();
          } else if (endpointDefinition.query) {
            result = await baseQuery(endpointDefinition.query(finalQueryArg), baseQueryApi, extraOptions);
          } else {
            result = await endpointDefinition.queryFn(finalQueryArg, baseQueryApi, extraOptions, (arg2) => baseQuery(arg2, baseQueryApi, extraOptions));
          }
          if (typeof process !== "undefined" && true) {
            const what = endpointDefinition.query ? "`baseQuery`" : "`queryFn`";
            let err;
            if (!result) {
              err = `${what} did not return anything.`;
            } else if (typeof result !== "object") {
              err = `${what} did not return an object.`;
            } else if (result.error && result.data) {
              err = `${what} returned an object containing both \`error\` and \`result\`.`;
            } else if (result.error === void 0 && result.data === void 0) {
              err = `${what} returned an object containing neither a valid \`error\` and \`result\`. At least one of them should not be \`undefined\``;
            } else {
              for (const key of Object.keys(result)) {
                if (key !== "error" && key !== "data" && key !== "meta") {
                  err = `The object returned by ${what} has the unknown property ${key}.`;
                  break;
                }
              }
            }
            if (err) {
              console.error(`Error encountered handling the endpoint ${arg.endpointName}.
                  ${err}
                  It needs to return an object with either the shape \`{ data: <value> }\` or \`{ error: <value> }\` that may contain an optional \`meta\` property.
                  Object returned was:`, result);
            }
          }
          if (result.error) throw new HandledError(result.error, result.meta);
          const transformedResponse = await transformResponse(result.data, result.meta, finalQueryArg);
          return {
            ...result,
            data: transformedResponse
          };
        }
        if (arg.type === "query" && "infiniteQueryOptions" in endpointDefinition) {
          const {
            infiniteQueryOptions
          } = endpointDefinition;
          const {
            maxPages = Infinity
          } = infiniteQueryOptions;
          let result;
          const blankData = {
            pages: [],
            pageParams: []
          };
          const cachedData = selectors5.selectQueryEntry(getState(), arg.queryCacheKey)?.data;
          const isForcedQueryNeedingRefetch = (
            // arg.forceRefetch
            isForcedQuery(arg, getState()) && !arg.direction
          );
          const existingData = isForcedQueryNeedingRefetch || !cachedData ? blankData : cachedData;
          if ("direction" in arg && arg.direction && existingData.pages.length) {
            const previous = arg.direction === "backward";
            const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
            const param = pageParamFn(infiniteQueryOptions, existingData);
            result = await fetchPage(existingData, param, maxPages, previous);
          } else {
            const {
              initialPageParam = infiniteQueryOptions.initialPageParam
            } = arg;
            const cachedPageParams = cachedData?.pageParams ?? [];
            const firstPageParam = cachedPageParams[0] ?? initialPageParam;
            const totalPages = cachedPageParams.length;
            result = await fetchPage(existingData, firstPageParam, maxPages);
            if (forceQueryFn) {
              result = {
                data: result.data.pages[0]
              };
            }
            for (let i = 1; i < totalPages; i++) {
              const param = getNextPageParam(infiniteQueryOptions, result.data);
              result = await fetchPage(result.data, param, maxPages);
            }
          }
          finalQueryReturnValue = result;
        } else {
          finalQueryReturnValue = await executeRequest(arg.originalArgs);
        }
        return fulfillWithValue(finalQueryReturnValue.data, addShouldAutoBatch({
          fulfilledTimeStamp: Date.now(),
          baseQueryMeta: finalQueryReturnValue.meta
        }));
      } catch (error) {
        let catchedError = error;
        if (catchedError instanceof HandledError) {
          let transformErrorResponse = getTransformCallbackForEndpoint(endpointDefinition, "transformErrorResponse");
          try {
            return rejectWithValue(await transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs), addShouldAutoBatch({
              baseQueryMeta: catchedError.meta
            }));
          } catch (e) {
            catchedError = e;
          }
        }
        if (typeof process !== "undefined" && true) {
          console.error(`An unhandled error occurred processing a request for the endpoint "${arg.endpointName}".
In the case of an unhandled error, no tags will be "provided" or "invalidated".`, catchedError);
        } else {
          console.error(catchedError);
        }
        throw catchedError;
      }
    };
    function isForcedQuery(arg, state) {
      const requestState = selectors5.selectQueryEntry(state, arg.queryCacheKey);
      const baseFetchOnMountOrArgChange = selectors5.selectConfig(state).refetchOnMountOrArgChange;
      const fulfilledVal = requestState?.fulfilledTimeStamp;
      const refetchVal = arg.forceRefetch ?? (arg.subscribe && baseFetchOnMountOrArgChange);
      if (refetchVal) {
        return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
      }
      return false;
    }
    const createQueryThunk = () => {
      const generatedQueryThunk = createAsyncThunk(`${reducerPath}/executeQuery`, executeEndpoint, {
        getPendingMeta({
          arg
        }) {
          const endpointDefinition = endpointDefinitions[arg.endpointName];
          return addShouldAutoBatch({
            startedTimeStamp: Date.now(),
            ...isInfiniteQueryDefinition(endpointDefinition) ? {
              direction: arg.direction
            } : {}
          });
        },
        condition(queryThunkArg, {
          getState
        }) {
          const state = getState();
          const requestState = selectors5.selectQueryEntry(state, queryThunkArg.queryCacheKey);
          const fulfilledVal = requestState?.fulfilledTimeStamp;
          const currentArg = queryThunkArg.originalArgs;
          const previousArg = requestState?.originalArgs;
          const endpointDefinition = endpointDefinitions[queryThunkArg.endpointName];
          const direction = queryThunkArg.direction;
          if (isUpsertQuery(queryThunkArg)) {
            return true;
          }
          if (requestState?.status === "pending") {
            return false;
          }
          if (isForcedQuery(queryThunkArg, state)) {
            return true;
          }
          if (isQueryDefinition(endpointDefinition) && endpointDefinition?.forceRefetch?.({
            currentArg,
            previousArg,
            endpointState: requestState,
            state
          })) {
            return true;
          }
          if (fulfilledVal && !direction) {
            return false;
          }
          return true;
        },
        dispatchConditionRejection: true
      });
      return generatedQueryThunk;
    };
    const queryThunk = createQueryThunk();
    const infiniteQueryThunk = createQueryThunk();
    const mutationThunk = createAsyncThunk(`${reducerPath}/executeMutation`, executeEndpoint, {
      getPendingMeta() {
        return addShouldAutoBatch({
          startedTimeStamp: Date.now()
        });
      }
    });
    const hasTheForce = (options2) => "force" in options2;
    const hasMaxAge = (options2) => "ifOlderThan" in options2;
    const prefetch = (endpointName, arg, options2) => (dispatch, getState) => {
      const force = hasTheForce(options2) && options2.force;
      const maxAge = hasMaxAge(options2) && options2.ifOlderThan;
      const queryAction = (force2 = true) => {
        const options22 = {
          forceRefetch: force2,
          isPrefetch: true
        };
        return api3.endpoints[endpointName].initiate(arg, options22);
      };
      const latestStateValue = api3.endpoints[endpointName].select(arg)(getState());
      if (force) {
        dispatch(queryAction());
      } else if (maxAge) {
        const lastFulfilledTs = latestStateValue?.fulfilledTimeStamp;
        if (!lastFulfilledTs) {
          dispatch(queryAction());
          return;
        }
        const shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
        if (shouldRetrigger) {
          dispatch(queryAction());
        }
      } else {
        dispatch(queryAction(false));
      }
    };
    function matchesEndpoint(endpointName) {
      return (action) => action?.meta?.arg?.endpointName === endpointName;
    }
    function buildMatchThunkActions(thunk2, endpointName) {
      return {
        matchPending: isAllOf(isPending(thunk2), matchesEndpoint(endpointName)),
        matchFulfilled: isAllOf(isFulfilled(thunk2), matchesEndpoint(endpointName)),
        matchRejected: isAllOf(isRejected(thunk2), matchesEndpoint(endpointName))
      };
    }
    return {
      queryThunk,
      mutationThunk,
      infiniteQueryThunk,
      prefetch,
      updateQueryData,
      upsertQueryData,
      patchQueryData,
      buildMatchThunkActions
    };
  }
  function getNextPageParam(options2, {
    pages,
    pageParams
  }) {
    const lastIndex = pages.length - 1;
    return options2.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);
  }
  function getPreviousPageParam(options2, {
    pages,
    pageParams
  }) {
    return options2.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams);
  }
  function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
    return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
  }
  function updateQuerySubstateIfExists(state, queryCacheKey, update) {
    const substate = state[queryCacheKey];
    if (substate) {
      update(substate);
    }
  }
  function getMutationCacheKey(id) {
    return ("arg" in id ? id.arg.fixedCacheKey : id.fixedCacheKey) ?? id.requestId;
  }
  function updateMutationSubstateIfExists(state, id, update) {
    const substate = state[getMutationCacheKey(id)];
    if (substate) {
      update(substate);
    }
  }
  var initialState = {};
  function buildSlice({
    reducerPath,
    queryThunk,
    mutationThunk,
    serializeQueryArgs,
    context: {
      endpointDefinitions: definitions,
      apiUid,
      extractRehydrationInfo,
      hasRehydrationInfo
    },
    assertTagType,
    config: config2
  }) {
    const resetApiState = createAction(`${reducerPath}/resetApiState`);
    function writePendingCacheEntry(draft, arg, upserting, meta) {
      draft[arg.queryCacheKey] ??= {
        status: "uninitialized",
        endpointName: arg.endpointName
      };
      updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
        substate.status = "pending";
        substate.requestId = upserting && substate.requestId ? (
          // for `upsertQuery` **updates**, keep the current `requestId`
          substate.requestId
        ) : (
          // for normal queries or `upsertQuery` **inserts** always update the `requestId`
          meta.requestId
        );
        if (arg.originalArgs !== void 0) {
          substate.originalArgs = arg.originalArgs;
        }
        substate.startedTimeStamp = meta.startedTimeStamp;
        const endpointDefinition = definitions[meta.arg.endpointName];
        if (isInfiniteQueryDefinition(endpointDefinition) && "direction" in arg) {
          ;
          substate.direction = arg.direction;
        }
      });
    }
    function writeFulfilledCacheEntry(draft, meta, payload, upserting) {
      updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, (substate) => {
        if (substate.requestId !== meta.requestId && !upserting) return;
        const {
          merge: merge4
        } = definitions[meta.arg.endpointName];
        substate.status = "fulfilled";
        if (merge4) {
          if (substate.data !== void 0) {
            const {
              fulfilledTimeStamp,
              arg,
              baseQueryMeta,
              requestId
            } = meta;
            let newData = produce(substate.data, (draftSubstateData) => {
              return merge4(draftSubstateData, payload, {
                arg: arg.originalArgs,
                baseQueryMeta,
                fulfilledTimeStamp,
                requestId
              });
            });
            substate.data = newData;
          } else {
            substate.data = payload;
          }
        } else {
          substate.data = definitions[meta.arg.endpointName].structuralSharing ?? true ? copyWithStructuralSharing(isDraft(substate.data) ? original(substate.data) : substate.data, payload) : payload;
        }
        delete substate.error;
        substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
      });
    }
    const querySlice = createSlice({
      name: `${reducerPath}/queries`,
      initialState,
      reducers: {
        removeQueryResult: {
          reducer(draft, {
            payload: {
              queryCacheKey
            }
          }) {
            delete draft[queryCacheKey];
          },
          prepare: prepareAutoBatched()
        },
        cacheEntriesUpserted: {
          reducer(draft, action) {
            for (const entry of action.payload) {
              const {
                queryDescription: arg,
                value
              } = entry;
              writePendingCacheEntry(draft, arg, true, {
                arg,
                requestId: action.meta.requestId,
                startedTimeStamp: action.meta.timestamp
              });
              writeFulfilledCacheEntry(
                draft,
                {
                  arg,
                  requestId: action.meta.requestId,
                  fulfilledTimeStamp: action.meta.timestamp,
                  baseQueryMeta: {}
                },
                value,
                // We know we're upserting here
                true
              );
            }
          },
          prepare: (payload) => {
            const queryDescriptions = payload.map((entry) => {
              const {
                endpointName,
                arg,
                value
              } = entry;
              const endpointDefinition = definitions[endpointName];
              const queryDescription = {
                type: "query",
                endpointName,
                originalArgs: entry.arg,
                queryCacheKey: serializeQueryArgs({
                  queryArgs: arg,
                  endpointDefinition,
                  endpointName
                })
              };
              return {
                queryDescription,
                value
              };
            });
            const result = {
              payload: queryDescriptions,
              meta: {
                [SHOULD_AUTOBATCH]: true,
                requestId: nanoid(),
                timestamp: Date.now()
              }
            };
            return result;
          }
        },
        queryResultPatched: {
          reducer(draft, {
            payload: {
              queryCacheKey,
              patches
            }
          }) {
            updateQuerySubstateIfExists(draft, queryCacheKey, (substate) => {
              substate.data = applyPatches(substate.data, patches.concat());
            });
          },
          prepare: prepareAutoBatched()
        }
      },
      extraReducers(builder) {
        builder.addCase(queryThunk.pending, (draft, {
          meta,
          meta: {
            arg
          }
        }) => {
          const upserting = isUpsertQuery(arg);
          writePendingCacheEntry(draft, arg, upserting, meta);
        }).addCase(queryThunk.fulfilled, (draft, {
          meta,
          payload
        }) => {
          const upserting = isUpsertQuery(meta.arg);
          writeFulfilledCacheEntry(draft, meta, payload, upserting);
        }).addCase(queryThunk.rejected, (draft, {
          meta: {
            condition,
            arg,
            requestId
          },
          error,
          payload
        }) => {
          updateQuerySubstateIfExists(draft, arg.queryCacheKey, (substate) => {
            if (condition) {
            } else {
              if (substate.requestId !== requestId) return;
              substate.status = "rejected";
              substate.error = payload ?? error;
            }
          });
        }).addMatcher(hasRehydrationInfo, (draft, action) => {
          const {
            queries
          } = extractRehydrationInfo(action);
          for (const [key, entry] of Object.entries(queries)) {
            if (
              // do not rehydrate entries that were currently in flight.
              entry?.status === "fulfilled" || entry?.status === "rejected"
            ) {
              draft[key] = entry;
            }
          }
        });
      }
    });
    const mutationSlice = createSlice({
      name: `${reducerPath}/mutations`,
      initialState,
      reducers: {
        removeMutationResult: {
          reducer(draft, {
            payload
          }) {
            const cacheKey = getMutationCacheKey(payload);
            if (cacheKey in draft) {
              delete draft[cacheKey];
            }
          },
          prepare: prepareAutoBatched()
        }
      },
      extraReducers(builder) {
        builder.addCase(mutationThunk.pending, (draft, {
          meta,
          meta: {
            requestId,
            arg,
            startedTimeStamp
          }
        }) => {
          if (!arg.track) return;
          draft[getMutationCacheKey(meta)] = {
            requestId,
            status: "pending",
            endpointName: arg.endpointName,
            startedTimeStamp
          };
        }).addCase(mutationThunk.fulfilled, (draft, {
          payload,
          meta
        }) => {
          if (!meta.arg.track) return;
          updateMutationSubstateIfExists(draft, meta, (substate) => {
            if (substate.requestId !== meta.requestId) return;
            substate.status = "fulfilled";
            substate.data = payload;
            substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
          });
        }).addCase(mutationThunk.rejected, (draft, {
          payload,
          error,
          meta
        }) => {
          if (!meta.arg.track) return;
          updateMutationSubstateIfExists(draft, meta, (substate) => {
            if (substate.requestId !== meta.requestId) return;
            substate.status = "rejected";
            substate.error = payload ?? error;
          });
        }).addMatcher(hasRehydrationInfo, (draft, action) => {
          const {
            mutations
          } = extractRehydrationInfo(action);
          for (const [key, entry] of Object.entries(mutations)) {
            if (
              // do not rehydrate entries that were currently in flight.
              (entry?.status === "fulfilled" || entry?.status === "rejected") && // only rehydrate endpoints that were persisted using a `fixedCacheKey`
              key !== entry?.requestId
            ) {
              draft[key] = entry;
            }
          }
        });
      }
    });
    const invalidationSlice = createSlice({
      name: `${reducerPath}/invalidation`,
      initialState,
      reducers: {
        updateProvidedBy: {
          reducer(draft, action) {
            const {
              queryCacheKey,
              providedTags
            } = action.payload;
            for (const tagTypeSubscriptions of Object.values(draft)) {
              for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {
                const foundAt = idSubscriptions.indexOf(queryCacheKey);
                if (foundAt !== -1) {
                  idSubscriptions.splice(foundAt, 1);
                }
              }
            }
            for (const {
              type,
              id
            } of providedTags) {
              const subscribedQueries = (draft[type] ??= {})[id || "__internal_without_id"] ??= [];
              const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
              if (!alreadySubscribed) {
                subscribedQueries.push(queryCacheKey);
              }
            }
          },
          prepare: prepareAutoBatched()
        }
      },
      extraReducers(builder) {
        builder.addCase(querySlice.actions.removeQueryResult, (draft, {
          payload: {
            queryCacheKey
          }
        }) => {
          for (const tagTypeSubscriptions of Object.values(draft)) {
            for (const idSubscriptions of Object.values(tagTypeSubscriptions)) {
              const foundAt = idSubscriptions.indexOf(queryCacheKey);
              if (foundAt !== -1) {
                idSubscriptions.splice(foundAt, 1);
              }
            }
          }
        }).addMatcher(hasRehydrationInfo, (draft, action) => {
          const {
            provided
          } = extractRehydrationInfo(action);
          for (const [type, incomingTags] of Object.entries(provided)) {
            for (const [id, cacheKeys] of Object.entries(incomingTags)) {
              const subscribedQueries = (draft[type] ??= {})[id || "__internal_without_id"] ??= [];
              for (const queryCacheKey of cacheKeys) {
                const alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                if (!alreadySubscribed) {
                  subscribedQueries.push(queryCacheKey);
                }
              }
            }
          }
        }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), (draft, action) => {
          writeProvidedTagsForQuery(draft, action);
        }).addMatcher(querySlice.actions.cacheEntriesUpserted.match, (draft, action) => {
          for (const {
            queryDescription: arg,
            value
          } of action.payload) {
            const action2 = {
              type: "UNKNOWN",
              payload: value,
              meta: {
                requestStatus: "fulfilled",
                requestId: "UNKNOWN",
                arg
              }
            };
            writeProvidedTagsForQuery(draft, action2);
          }
        });
      }
    });
    function writeProvidedTagsForQuery(draft, action) {
      const providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
      const {
        queryCacheKey
      } = action.meta.arg;
      invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({
        queryCacheKey,
        providedTags
      }));
    }
    const subscriptionSlice = createSlice({
      name: `${reducerPath}/subscriptions`,
      initialState,
      reducers: {
        updateSubscriptionOptions(d, a) {
        },
        unsubscribeQueryResult(d, a) {
        },
        internal_getRTKQSubscriptions() {
        }
      }
    });
    const internalSubscriptionsSlice = createSlice({
      name: `${reducerPath}/internalSubscriptions`,
      initialState,
      reducers: {
        subscriptionsUpdated: {
          reducer(state, action) {
            return applyPatches(state, action.payload);
          },
          prepare: prepareAutoBatched()
        }
      }
    });
    const configSlice = createSlice({
      name: `${reducerPath}/config`,
      initialState: {
        online: isOnline(),
        focused: isDocumentVisible(),
        middlewareRegistered: false,
        ...config2
      },
      reducers: {
        middlewareRegistered(state, {
          payload
        }) {
          state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
        }
      },
      extraReducers: (builder) => {
        builder.addCase(onOnline, (state) => {
          state.online = true;
        }).addCase(onOffline, (state) => {
          state.online = false;
        }).addCase(onFocus, (state) => {
          state.focused = true;
        }).addCase(onFocusLost, (state) => {
          state.focused = false;
        }).addMatcher(hasRehydrationInfo, (draft) => ({
          ...draft
        }));
      }
    });
    const combinedReducer = combineReducers({
      queries: querySlice.reducer,
      mutations: mutationSlice.reducer,
      provided: invalidationSlice.reducer,
      subscriptions: internalSubscriptionsSlice.reducer,
      config: configSlice.reducer
    });
    const reducer = (state, action) => combinedReducer(resetApiState.match(action) ? void 0 : state, action);
    const actions3 = {
      ...configSlice.actions,
      ...querySlice.actions,
      ...subscriptionSlice.actions,
      ...internalSubscriptionsSlice.actions,
      ...mutationSlice.actions,
      ...invalidationSlice.actions,
      resetApiState
    };
    return {
      reducer,
      actions: actions3
    };
  }
  var skipToken = /* @__PURE__ */ Symbol.for("RTKQ/skipToken");
  var initialSubState = {
    status: "uninitialized"
    /* uninitialized */
  };
  var defaultQuerySubState = /* @__PURE__ */ produce(initialSubState, () => {
  });
  var defaultMutationSubState = /* @__PURE__ */ produce(initialSubState, () => {
  });
  function buildSelectors({
    serializeQueryArgs,
    reducerPath,
    createSelector: createSelector2
  }) {
    const selectSkippedQuery = (state) => defaultQuerySubState;
    const selectSkippedMutation = (state) => defaultMutationSubState;
    return {
      buildQuerySelector,
      buildInfiniteQuerySelector,
      buildMutationSelector,
      selectInvalidatedBy,
      selectCachedArgsForQuery,
      selectApiState,
      selectQueries,
      selectMutations,
      selectQueryEntry,
      selectConfig
    };
    function withRequestFlags(substate) {
      return {
        ...substate,
        ...getRequestStatusFlags(substate.status)
      };
    }
    function selectApiState(rootState) {
      const state = rootState[reducerPath];
      if (true) {
        if (!state) {
          if (selectApiState.triggered) return state;
          selectApiState.triggered = true;
          console.error(`Error: No data found at \`state.${reducerPath}\`. Did you forget to add the reducer to the store?`);
        }
      }
      return state;
    }
    function selectQueries(rootState) {
      return selectApiState(rootState)?.queries;
    }
    function selectQueryEntry(rootState, cacheKey) {
      return selectQueries(rootState)?.[cacheKey];
    }
    function selectMutations(rootState) {
      return selectApiState(rootState)?.mutations;
    }
    function selectConfig(rootState) {
      return selectApiState(rootState)?.config;
    }
    function buildAnyQuerySelector(endpointName, endpointDefinition, combiner) {
      return (queryArgs) => {
        if (queryArgs === skipToken) {
          return createSelector2(selectSkippedQuery, combiner);
        }
        const serializedArgs = serializeQueryArgs({
          queryArgs,
          endpointDefinition,
          endpointName
        });
        const selectQuerySubstate = (state) => selectQueryEntry(state, serializedArgs) ?? defaultQuerySubState;
        return createSelector2(selectQuerySubstate, combiner);
      };
    }
    function buildQuerySelector(endpointName, endpointDefinition) {
      return buildAnyQuerySelector(endpointName, endpointDefinition, withRequestFlags);
    }
    function buildInfiniteQuerySelector(endpointName, endpointDefinition) {
      const {
        infiniteQueryOptions
      } = endpointDefinition;
      function withInfiniteQueryResultFlags(substate) {
        const stateWithRequestFlags = {
          ...substate,
          ...getRequestStatusFlags(substate.status)
        };
        const {
          isLoading,
          isError: isError2,
          direction
        } = stateWithRequestFlags;
        const isForward = direction === "forward";
        const isBackward = direction === "backward";
        return {
          ...stateWithRequestFlags,
          hasNextPage: getHasNextPage(infiniteQueryOptions, stateWithRequestFlags.data),
          hasPreviousPage: getHasPreviousPage(infiniteQueryOptions, stateWithRequestFlags.data),
          isFetchingNextPage: isLoading && isForward,
          isFetchingPreviousPage: isLoading && isBackward,
          isFetchNextPageError: isError2 && isForward,
          isFetchPreviousPageError: isError2 && isBackward
        };
      }
      return buildAnyQuerySelector(endpointName, endpointDefinition, withInfiniteQueryResultFlags);
    }
    function buildMutationSelector() {
      return (id) => {
        let mutationId;
        if (typeof id === "object") {
          mutationId = getMutationCacheKey(id) ?? skipToken;
        } else {
          mutationId = id;
        }
        const selectMutationSubstate = (state) => selectApiState(state)?.mutations?.[mutationId] ?? defaultMutationSubState;
        const finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;
        return createSelector2(finalSelectMutationSubstate, withRequestFlags);
      };
    }
    function selectInvalidatedBy(state, tags) {
      const apiState = state[reducerPath];
      const toInvalidate = /* @__PURE__ */ new Set();
      for (const tag of tags.filter(isNotNullish).map(expandTagDescription)) {
        const provided = apiState.provided[tag.type];
        if (!provided) {
          continue;
        }
        let invalidateSubscriptions = (tag.id !== void 0 ? (
          // id given: invalidate all queries that provide this type & id
          provided[tag.id]
        ) : (
          // no id: invalidate all queries that provide this type
          flatten(Object.values(provided))
        )) ?? [];
        for (const invalidate of invalidateSubscriptions) {
          toInvalidate.add(invalidate);
        }
      }
      return flatten(Array.from(toInvalidate.values()).map((queryCacheKey) => {
        const querySubState = apiState.queries[queryCacheKey];
        return querySubState ? [{
          queryCacheKey,
          endpointName: querySubState.endpointName,
          originalArgs: querySubState.originalArgs
        }] : [];
      }));
    }
    function selectCachedArgsForQuery(state, queryName) {
      return Object.values(selectQueries(state)).filter(
        (entry) => entry?.endpointName === queryName && entry.status !== "uninitialized"
        /* uninitialized */
      ).map((entry) => entry.originalArgs);
    }
    function getHasNextPage(options2, data2) {
      if (!data2) return false;
      return getNextPageParam(options2, data2) != null;
    }
    function getHasPreviousPage(options2, data2) {
      if (!data2 || !options2.getPreviousPageParam) return false;
      return getPreviousPageParam(options2, data2) != null;
    }
  }
  var cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
  var defaultSerializeQueryArgs = ({
    endpointName,
    queryArgs
  }) => {
    let serialized = "";
    const cached = cache?.get(queryArgs);
    if (typeof cached === "string") {
      serialized = cached;
    } else {
      const stringified = JSON.stringify(queryArgs, (key, value) => {
        value = typeof value === "bigint" ? {
          $bigint: value.toString()
        } : value;
        value = isPlainObject(value) ? Object.keys(value).sort().reduce((acc, key2) => {
          acc[key2] = value[key2];
          return acc;
        }, {}) : value;
        return value;
      });
      if (isPlainObject(queryArgs)) {
        cache?.set(queryArgs, stringified);
      }
      serialized = stringified;
    }
    return `${endpointName}(${serialized})`;
  };
  function buildCreateApi(...modules) {
    return function baseCreateApi(options2) {
      const extractRehydrationInfo = weakMapMemoize((action) => options2.extractRehydrationInfo?.(action, {
        reducerPath: options2.reducerPath ?? "api"
      }));
      const optionsWithDefaults = {
        reducerPath: "api",
        keepUnusedDataFor: 60,
        refetchOnMountOrArgChange: false,
        refetchOnFocus: false,
        refetchOnReconnect: false,
        invalidationBehavior: "delayed",
        ...options2,
        extractRehydrationInfo,
        serializeQueryArgs(queryArgsApi) {
          let finalSerializeQueryArgs = defaultSerializeQueryArgs;
          if ("serializeQueryArgs" in queryArgsApi.endpointDefinition) {
            const endpointSQA = queryArgsApi.endpointDefinition.serializeQueryArgs;
            finalSerializeQueryArgs = (queryArgsApi2) => {
              const initialResult = endpointSQA(queryArgsApi2);
              if (typeof initialResult === "string") {
                return initialResult;
              } else {
                return defaultSerializeQueryArgs({
                  ...queryArgsApi2,
                  queryArgs: initialResult
                });
              }
            };
          } else if (options2.serializeQueryArgs) {
            finalSerializeQueryArgs = options2.serializeQueryArgs;
          }
          return finalSerializeQueryArgs(queryArgsApi);
        },
        tagTypes: [...options2.tagTypes || []]
      };
      const context = {
        endpointDefinitions: {},
        batch(fn) {
          fn();
        },
        apiUid: nanoid(),
        extractRehydrationInfo,
        hasRehydrationInfo: weakMapMemoize((action) => extractRehydrationInfo(action) != null)
      };
      const api3 = {
        injectEndpoints,
        enhanceEndpoints({
          addTagTypes,
          endpoints
        }) {
          if (addTagTypes) {
            for (const eT of addTagTypes) {
              if (!optionsWithDefaults.tagTypes.includes(eT)) {
                ;
                optionsWithDefaults.tagTypes.push(eT);
              }
            }
          }
          if (endpoints) {
            for (const [endpointName, partialDefinition] of Object.entries(endpoints)) {
              if (typeof partialDefinition === "function") {
                partialDefinition(context.endpointDefinitions[endpointName]);
              } else {
                Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);
              }
            }
          }
          return api3;
        }
      };
      const initializedModules = modules.map((m) => m.init(api3, optionsWithDefaults, context));
      function injectEndpoints(inject) {
        const evaluatedEndpoints = inject.endpoints({
          query: (x2) => ({
            ...x2,
            type: "query"
            /* query */
          }),
          mutation: (x2) => ({
            ...x2,
            type: "mutation"
            /* mutation */
          }),
          infiniteQuery: (x2) => ({
            ...x2,
            type: "infinitequery"
            /* infinitequery */
          })
        });
        for (const [endpointName, definition] of Object.entries(evaluatedEndpoints)) {
          if (inject.overrideExisting !== true && endpointName in context.endpointDefinitions) {
            if (inject.overrideExisting === "throw") {
              throw new Error(false ? formatProdErrorMessage(39) : `called \`injectEndpoints\` to override already-existing endpointName ${endpointName} without specifying \`overrideExisting: true\``);
            } else if (typeof process !== "undefined" && true) {
              console.error(`called \`injectEndpoints\` to override already-existing endpointName ${endpointName} without specifying \`overrideExisting: true\``);
            }
            continue;
          }
          if (typeof process !== "undefined" && true) {
            if (isInfiniteQueryDefinition(definition)) {
              const {
                infiniteQueryOptions
              } = definition;
              const {
                maxPages,
                getPreviousPageParam: getPreviousPageParam2
              } = infiniteQueryOptions;
              if (typeof maxPages === "number") {
                if (maxPages < 1) {
                  throw new Error(false ? formatProdErrorMessage(40) : `maxPages for endpoint '${endpointName}' must be a number greater than 0`);
                }
                if (typeof getPreviousPageParam2 !== "function") {
                  throw new Error(false ? formatProdErrorMessage(41) : `getPreviousPageParam for endpoint '${endpointName}' must be a function if maxPages is used`);
                }
              }
            }
          }
          context.endpointDefinitions[endpointName] = definition;
          for (const m of initializedModules) {
            m.injectEndpoint(endpointName, definition);
          }
        }
        return api3;
      }
      return api3.injectEndpoints({
        endpoints: options2.endpoints
      });
    };
  }
  function assertCast(v) {
  }
  function safeAssign(target, ...args) {
    return Object.assign(target, ...args);
  }
  var buildBatchedActionsHandler = ({
    api: api3,
    queryThunk,
    internalState
  }) => {
    const subscriptionsPrefix = `${api3.reducerPath}/subscriptions`;
    let previousSubscriptions = null;
    let updateSyncTimer = null;
    const {
      updateSubscriptionOptions,
      unsubscribeQueryResult
    } = api3.internalActions;
    const actuallyMutateSubscriptions = (mutableState, action) => {
      if (updateSubscriptionOptions.match(action)) {
        const {
          queryCacheKey,
          requestId,
          options: options2
        } = action.payload;
        if (mutableState?.[queryCacheKey]?.[requestId]) {
          mutableState[queryCacheKey][requestId] = options2;
        }
        return true;
      }
      if (unsubscribeQueryResult.match(action)) {
        const {
          queryCacheKey,
          requestId
        } = action.payload;
        if (mutableState[queryCacheKey]) {
          delete mutableState[queryCacheKey][requestId];
        }
        return true;
      }
      if (api3.internalActions.removeQueryResult.match(action)) {
        delete mutableState[action.payload.queryCacheKey];
        return true;
      }
      if (queryThunk.pending.match(action)) {
        const {
          meta: {
            arg,
            requestId
          }
        } = action;
        const substate = mutableState[arg.queryCacheKey] ??= {};
        substate[`${requestId}_running`] = {};
        if (arg.subscribe) {
          substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};
        }
        return true;
      }
      let mutated = false;
      if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action)) {
        const state = mutableState[action.meta.arg.queryCacheKey] || {};
        const key = `${action.meta.requestId}_running`;
        mutated ||= !!state[key];
        delete state[key];
      }
      if (queryThunk.rejected.match(action)) {
        const {
          meta: {
            condition,
            arg,
            requestId
          }
        } = action;
        if (condition && arg.subscribe) {
          const substate = mutableState[arg.queryCacheKey] ??= {};
          substate[requestId] = arg.subscriptionOptions ?? substate[requestId] ?? {};
          mutated = true;
        }
      }
      return mutated;
    };
    const getSubscriptions = () => internalState.currentSubscriptions;
    const getSubscriptionCount = (queryCacheKey) => {
      const subscriptions = getSubscriptions();
      const subscriptionsForQueryArg = subscriptions[queryCacheKey] ?? {};
      return countObjectKeys(subscriptionsForQueryArg);
    };
    const isRequestSubscribed = (queryCacheKey, requestId) => {
      const subscriptions = getSubscriptions();
      return !!subscriptions?.[queryCacheKey]?.[requestId];
    };
    const subscriptionSelectors = {
      getSubscriptions,
      getSubscriptionCount,
      isRequestSubscribed
    };
    return (action, mwApi) => {
      if (!previousSubscriptions) {
        previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
      }
      if (api3.util.resetApiState.match(action)) {
        previousSubscriptions = internalState.currentSubscriptions = {};
        updateSyncTimer = null;
        return [true, false];
      }
      if (api3.internalActions.internal_getRTKQSubscriptions.match(action)) {
        return [false, subscriptionSelectors];
      }
      const didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);
      let actionShouldContinue = true;
      if (didMutate) {
        if (!updateSyncTimer) {
          updateSyncTimer = setTimeout(() => {
            const newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
            const [, patches] = produceWithPatches(previousSubscriptions, () => newSubscriptions);
            mwApi.next(api3.internalActions.subscriptionsUpdated(patches));
            previousSubscriptions = newSubscriptions;
            updateSyncTimer = null;
          }, 500);
        }
        const isSubscriptionSliceAction = typeof action.type == "string" && !!action.type.startsWith(subscriptionsPrefix);
        const isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;
        actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;
      }
      return [actionShouldContinue, false];
    };
  };
  function isObjectEmpty(obj) {
    for (const k in obj) {
      return false;
    }
    return true;
  }
  var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
  var buildCacheCollectionHandler = ({
    reducerPath,
    api: api3,
    queryThunk,
    context,
    internalState,
    selectors: {
      selectQueryEntry,
      selectConfig
    }
  }) => {
    const {
      removeQueryResult,
      unsubscribeQueryResult,
      cacheEntriesUpserted
    } = api3.internalActions;
    const canTriggerUnsubscribe = isAnyOf(unsubscribeQueryResult.match, queryThunk.fulfilled, queryThunk.rejected, cacheEntriesUpserted.match);
    function anySubscriptionsRemainingForKey(queryCacheKey) {
      const subscriptions = internalState.currentSubscriptions[queryCacheKey];
      return !!subscriptions && !isObjectEmpty(subscriptions);
    }
    const currentRemovalTimeouts = {};
    const handler = (action, mwApi, internalState2) => {
      const state = mwApi.getState();
      const config2 = selectConfig(state);
      if (canTriggerUnsubscribe(action)) {
        let queryCacheKeys;
        if (cacheEntriesUpserted.match(action)) {
          queryCacheKeys = action.payload.map((entry) => entry.queryDescription.queryCacheKey);
        } else {
          const {
            queryCacheKey
          } = unsubscribeQueryResult.match(action) ? action.payload : action.meta.arg;
          queryCacheKeys = [queryCacheKey];
        }
        handleUnsubscribeMany(queryCacheKeys, mwApi, config2);
      }
      if (api3.util.resetApiState.match(action)) {
        for (const [key, timeout2] of Object.entries(currentRemovalTimeouts)) {
          if (timeout2) clearTimeout(timeout2);
          delete currentRemovalTimeouts[key];
        }
      }
      if (context.hasRehydrationInfo(action)) {
        const {
          queries
        } = context.extractRehydrationInfo(action);
        handleUnsubscribeMany(Object.keys(queries), mwApi, config2);
      }
    };
    function handleUnsubscribeMany(cacheKeys, api22, config2) {
      const state = api22.getState();
      for (const queryCacheKey of cacheKeys) {
        const entry = selectQueryEntry(state, queryCacheKey);
        handleUnsubscribe(queryCacheKey, entry?.endpointName, api22, config2);
      }
    }
    function handleUnsubscribe(queryCacheKey, endpointName, api22, config2) {
      const endpointDefinition = context.endpointDefinitions[endpointName];
      const keepUnusedDataFor = endpointDefinition?.keepUnusedDataFor ?? config2.keepUnusedDataFor;
      if (keepUnusedDataFor === Infinity) {
        return;
      }
      const finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
      if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
        const currentTimeout = currentRemovalTimeouts[queryCacheKey];
        if (currentTimeout) {
          clearTimeout(currentTimeout);
        }
        currentRemovalTimeouts[queryCacheKey] = setTimeout(() => {
          if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
            api22.dispatch(removeQueryResult({
              queryCacheKey
            }));
          }
          delete currentRemovalTimeouts[queryCacheKey];
        }, finalKeepUnusedDataFor * 1e3);
      }
    }
    return handler;
  };
  var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
  var buildCacheLifecycleHandler = ({
    api: api3,
    reducerPath,
    context,
    queryThunk,
    mutationThunk,
    internalState,
    selectors: {
      selectQueryEntry,
      selectApiState
    }
  }) => {
    const isQueryThunk = isAsyncThunkAction(queryThunk);
    const isMutationThunk = isAsyncThunkAction(mutationThunk);
    const isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);
    const lifecycleMap = {};
    function resolveLifecycleEntry(cacheKey, data2, meta) {
      const lifecycle = lifecycleMap[cacheKey];
      if (lifecycle?.valueResolved) {
        lifecycle.valueResolved({
          data: data2,
          meta
        });
        delete lifecycle.valueResolved;
      }
    }
    function removeLifecycleEntry(cacheKey) {
      const lifecycle = lifecycleMap[cacheKey];
      if (lifecycle) {
        delete lifecycleMap[cacheKey];
        lifecycle.cacheEntryRemoved();
      }
    }
    const handler = (action, mwApi, stateBefore) => {
      const cacheKey = getCacheKey(action);
      function checkForNewCacheKey(endpointName, cacheKey2, requestId, originalArgs) {
        const oldEntry = selectQueryEntry(stateBefore, cacheKey2);
        const newEntry = selectQueryEntry(mwApi.getState(), cacheKey2);
        if (!oldEntry && newEntry) {
          handleNewKey(endpointName, originalArgs, cacheKey2, mwApi, requestId);
        }
      }
      if (queryThunk.pending.match(action)) {
        checkForNewCacheKey(action.meta.arg.endpointName, cacheKey, action.meta.requestId, action.meta.arg.originalArgs);
      } else if (api3.internalActions.cacheEntriesUpserted.match(action)) {
        for (const {
          queryDescription,
          value
        } of action.payload) {
          const {
            endpointName,
            originalArgs,
            queryCacheKey
          } = queryDescription;
          checkForNewCacheKey(endpointName, queryCacheKey, action.meta.requestId, originalArgs);
          resolveLifecycleEntry(queryCacheKey, value, {});
        }
      } else if (mutationThunk.pending.match(action)) {
        const state = mwApi.getState()[reducerPath].mutations[cacheKey];
        if (state) {
          handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
        }
      } else if (isFulfilledThunk(action)) {
        resolveLifecycleEntry(cacheKey, action.payload, action.meta.baseQueryMeta);
      } else if (api3.internalActions.removeQueryResult.match(action) || api3.internalActions.removeMutationResult.match(action)) {
        removeLifecycleEntry(cacheKey);
      } else if (api3.util.resetApiState.match(action)) {
        for (const cacheKey2 of Object.keys(lifecycleMap)) {
          removeLifecycleEntry(cacheKey2);
        }
      }
    };
    function getCacheKey(action) {
      if (isQueryThunk(action)) return action.meta.arg.queryCacheKey;
      if (isMutationThunk(action)) {
        return action.meta.arg.fixedCacheKey ?? action.meta.requestId;
      }
      if (api3.internalActions.removeQueryResult.match(action)) return action.payload.queryCacheKey;
      if (api3.internalActions.removeMutationResult.match(action)) return getMutationCacheKey(action.payload);
      return "";
    }
    function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {
      const endpointDefinition = context.endpointDefinitions[endpointName];
      const onCacheEntryAdded = endpointDefinition?.onCacheEntryAdded;
      if (!onCacheEntryAdded) return;
      const lifecycle = {};
      const cacheEntryRemoved = new Promise((resolve2) => {
        lifecycle.cacheEntryRemoved = resolve2;
      });
      const cacheDataLoaded = Promise.race([new Promise((resolve2) => {
        lifecycle.valueResolved = resolve2;
      }), cacheEntryRemoved.then(() => {
        throw neverResolvedError;
      })]);
      cacheDataLoaded.catch(() => {
      });
      lifecycleMap[queryCacheKey] = lifecycle;
      const selector = api3.endpoints[endpointName].select(endpointDefinition.type === "query" ? originalArgs : queryCacheKey);
      const extra = mwApi.dispatch((_, __, extra2) => extra2);
      const lifecycleApi = {
        ...mwApi,
        getCacheEntry: () => selector(mwApi.getState()),
        requestId,
        extra,
        updateCachedData: endpointDefinition.type === "query" ? (updateRecipe) => mwApi.dispatch(api3.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
        cacheDataLoaded,
        cacheEntryRemoved
      };
      const runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
      Promise.resolve(runningHandler).catch((e) => {
        if (e === neverResolvedError) return;
        throw e;
      });
    }
    return handler;
  };
  var buildDevCheckHandler = ({
    api: api3,
    context: {
      apiUid
    },
    reducerPath
  }) => {
    return (action, mwApi) => {
      if (api3.util.resetApiState.match(action)) {
        mwApi.dispatch(api3.internalActions.middlewareRegistered(apiUid));
      }
      if (typeof process !== "undefined" && true) {
        if (api3.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && mwApi.getState()[reducerPath]?.config?.middlewareRegistered === "conflict") {
          console.warn(`There is a mismatch between slice and middleware for the reducerPath "${reducerPath}".
You can only have one api per reducer path, this will lead to crashes in various situations!${reducerPath === "api" ? `
If you have multiple apis, you *have* to specify the reducerPath option when using createApi!` : ""}`);
        }
      }
    };
  };
  var buildInvalidationByTagsHandler = ({
    reducerPath,
    context,
    context: {
      endpointDefinitions
    },
    mutationThunk,
    queryThunk,
    api: api3,
    assertTagType,
    refetchQuery,
    internalState
  }) => {
    const {
      removeQueryResult
    } = api3.internalActions;
    const isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));
    const isQueryEnd = isAnyOf(isFulfilled(mutationThunk, queryThunk), isRejected(mutationThunk, queryThunk));
    let pendingTagInvalidations = [];
    const handler = (action, mwApi) => {
      if (isThunkActionWithTags(action)) {
        invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
      } else if (isQueryEnd(action)) {
        invalidateTags([], mwApi);
      } else if (api3.util.invalidateTags.match(action)) {
        invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
      }
    };
    function hasPendingRequests(state) {
      const {
        queries,
        mutations
      } = state;
      for (const cacheRecord of [queries, mutations]) {
        for (const key in cacheRecord) {
          if (cacheRecord[key]?.status === "pending") return true;
        }
      }
      return false;
    }
    function invalidateTags(newTags, mwApi) {
      const rootState = mwApi.getState();
      const state = rootState[reducerPath];
      pendingTagInvalidations.push(...newTags);
      if (state.config.invalidationBehavior === "delayed" && hasPendingRequests(state)) {
        return;
      }
      const tags = pendingTagInvalidations;
      pendingTagInvalidations = [];
      if (tags.length === 0) return;
      const toInvalidate = api3.util.selectInvalidatedBy(rootState, tags);
      context.batch(() => {
        const valuesArray = Array.from(toInvalidate.values());
        for (const {
          queryCacheKey
        } of valuesArray) {
          const querySubState = state.queries[queryCacheKey];
          const subscriptionSubState = internalState.currentSubscriptions[queryCacheKey] ?? {};
          if (querySubState) {
            if (countObjectKeys(subscriptionSubState) === 0) {
              mwApi.dispatch(removeQueryResult({
                queryCacheKey
              }));
            } else if (querySubState.status !== "uninitialized") {
              mwApi.dispatch(refetchQuery(querySubState));
            }
          }
        }
      });
    }
    return handler;
  };
  var buildPollingHandler = ({
    reducerPath,
    queryThunk,
    api: api3,
    refetchQuery,
    internalState
  }) => {
    const currentPolls = {};
    const handler = (action, mwApi) => {
      if (api3.internalActions.updateSubscriptionOptions.match(action) || api3.internalActions.unsubscribeQueryResult.match(action)) {
        updatePollingInterval(action.payload, mwApi);
      }
      if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
        updatePollingInterval(action.meta.arg, mwApi);
      }
      if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
        startNextPoll(action.meta.arg, mwApi);
      }
      if (api3.util.resetApiState.match(action)) {
        clearPolls();
      }
    };
    function getCacheEntrySubscriptions(queryCacheKey, api22) {
      const state = api22.getState()[reducerPath];
      const querySubState = state.queries[queryCacheKey];
      const subscriptions = internalState.currentSubscriptions[queryCacheKey];
      if (!querySubState || querySubState.status === "uninitialized") return;
      return subscriptions;
    }
    function startNextPoll({
      queryCacheKey
    }, api22) {
      const state = api22.getState()[reducerPath];
      const querySubState = state.queries[queryCacheKey];
      const subscriptions = internalState.currentSubscriptions[queryCacheKey];
      if (!querySubState || querySubState.status === "uninitialized") return;
      const {
        lowestPollingInterval,
        skipPollingIfUnfocused
      } = findLowestPollingInterval(subscriptions);
      if (!Number.isFinite(lowestPollingInterval)) return;
      const currentPoll = currentPolls[queryCacheKey];
      if (currentPoll?.timeout) {
        clearTimeout(currentPoll.timeout);
        currentPoll.timeout = void 0;
      }
      const nextPollTimestamp = Date.now() + lowestPollingInterval;
      currentPolls[queryCacheKey] = {
        nextPollTimestamp,
        pollingInterval: lowestPollingInterval,
        timeout: setTimeout(() => {
          if (state.config.focused || !skipPollingIfUnfocused) {
            api22.dispatch(refetchQuery(querySubState));
          }
          startNextPoll({
            queryCacheKey
          }, api22);
        }, lowestPollingInterval)
      };
    }
    function updatePollingInterval({
      queryCacheKey
    }, api22) {
      const state = api22.getState()[reducerPath];
      const querySubState = state.queries[queryCacheKey];
      const subscriptions = internalState.currentSubscriptions[queryCacheKey];
      if (!querySubState || querySubState.status === "uninitialized") {
        return;
      }
      const {
        lowestPollingInterval
      } = findLowestPollingInterval(subscriptions);
      if (!Number.isFinite(lowestPollingInterval)) {
        cleanupPollForKey(queryCacheKey);
        return;
      }
      const currentPoll = currentPolls[queryCacheKey];
      const nextPollTimestamp = Date.now() + lowestPollingInterval;
      if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
        startNextPoll({
          queryCacheKey
        }, api22);
      }
    }
    function cleanupPollForKey(key) {
      const existingPoll = currentPolls[key];
      if (existingPoll?.timeout) {
        clearTimeout(existingPoll.timeout);
      }
      delete currentPolls[key];
    }
    function clearPolls() {
      for (const key of Object.keys(currentPolls)) {
        cleanupPollForKey(key);
      }
    }
    function findLowestPollingInterval(subscribers = {}) {
      let skipPollingIfUnfocused = false;
      let lowestPollingInterval = Number.POSITIVE_INFINITY;
      for (let key in subscribers) {
        if (!!subscribers[key].pollingInterval) {
          lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);
          skipPollingIfUnfocused = subscribers[key].skipPollingIfUnfocused || skipPollingIfUnfocused;
        }
      }
      return {
        lowestPollingInterval,
        skipPollingIfUnfocused
      };
    }
    return handler;
  };
  var buildQueryLifecycleHandler = ({
    api: api3,
    context,
    queryThunk,
    mutationThunk
  }) => {
    const isPendingThunk = isPending(queryThunk, mutationThunk);
    const isRejectedThunk = isRejected(queryThunk, mutationThunk);
    const isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);
    const lifecycleMap = {};
    const handler = (action, mwApi) => {
      if (isPendingThunk(action)) {
        const {
          requestId,
          arg: {
            endpointName,
            originalArgs
          }
        } = action.meta;
        const endpointDefinition = context.endpointDefinitions[endpointName];
        const onQueryStarted = endpointDefinition?.onQueryStarted;
        if (onQueryStarted) {
          const lifecycle = {};
          const queryFulfilled = new Promise((resolve2, reject) => {
            lifecycle.resolve = resolve2;
            lifecycle.reject = reject;
          });
          queryFulfilled.catch(() => {
          });
          lifecycleMap[requestId] = lifecycle;
          const selector = api3.endpoints[endpointName].select(endpointDefinition.type === "query" ? originalArgs : requestId);
          const extra = mwApi.dispatch((_, __, extra2) => extra2);
          const lifecycleApi = {
            ...mwApi,
            getCacheEntry: () => selector(mwApi.getState()),
            requestId,
            extra,
            updateCachedData: endpointDefinition.type === "query" ? (updateRecipe) => mwApi.dispatch(api3.util.updateQueryData(endpointName, originalArgs, updateRecipe)) : void 0,
            queryFulfilled
          };
          onQueryStarted(originalArgs, lifecycleApi);
        }
      } else if (isFullfilledThunk(action)) {
        const {
          requestId,
          baseQueryMeta
        } = action.meta;
        lifecycleMap[requestId]?.resolve({
          data: action.payload,
          meta: baseQueryMeta
        });
        delete lifecycleMap[requestId];
      } else if (isRejectedThunk(action)) {
        const {
          requestId,
          rejectedWithValue,
          baseQueryMeta
        } = action.meta;
        lifecycleMap[requestId]?.reject({
          error: action.payload ?? action.error,
          isUnhandledError: !rejectedWithValue,
          meta: baseQueryMeta
        });
        delete lifecycleMap[requestId];
      }
    };
    return handler;
  };
  var buildWindowEventHandler = ({
    reducerPath,
    context,
    api: api3,
    refetchQuery,
    internalState
  }) => {
    const {
      removeQueryResult
    } = api3.internalActions;
    const handler = (action, mwApi) => {
      if (onFocus.match(action)) {
        refetchValidQueries(mwApi, "refetchOnFocus");
      }
      if (onOnline.match(action)) {
        refetchValidQueries(mwApi, "refetchOnReconnect");
      }
    };
    function refetchValidQueries(api22, type) {
      const state = api22.getState()[reducerPath];
      const queries = state.queries;
      const subscriptions = internalState.currentSubscriptions;
      context.batch(() => {
        for (const queryCacheKey of Object.keys(subscriptions)) {
          const querySubState = queries[queryCacheKey];
          const subscriptionSubState = subscriptions[queryCacheKey];
          if (!subscriptionSubState || !querySubState) continue;
          const shouldRefetch = Object.values(subscriptionSubState).some((sub) => sub[type] === true) || Object.values(subscriptionSubState).every((sub) => sub[type] === void 0) && state.config[type];
          if (shouldRefetch) {
            if (countObjectKeys(subscriptionSubState) === 0) {
              api22.dispatch(removeQueryResult({
                queryCacheKey
              }));
            } else if (querySubState.status !== "uninitialized") {
              api22.dispatch(refetchQuery(querySubState));
            }
          }
        }
      });
    }
    return handler;
  };
  function buildMiddleware(input) {
    const {
      reducerPath,
      queryThunk,
      api: api3,
      context
    } = input;
    const {
      apiUid
    } = context;
    const actions3 = {
      invalidateTags: createAction(`${reducerPath}/invalidateTags`)
    };
    const isThisApiSliceAction = (action) => action.type.startsWith(`${reducerPath}/`);
    const handlerBuilders = [buildDevCheckHandler, buildCacheCollectionHandler, buildInvalidationByTagsHandler, buildPollingHandler, buildCacheLifecycleHandler, buildQueryLifecycleHandler];
    const middleware2 = (mwApi) => {
      let initialized2 = false;
      const internalState = {
        currentSubscriptions: {}
      };
      const builderArgs = {
        ...input,
        internalState,
        refetchQuery,
        isThisApiSliceAction
      };
      const handlers = handlerBuilders.map((build2) => build2(builderArgs));
      const batchedActionsHandler = buildBatchedActionsHandler(builderArgs);
      const windowEventsHandler = buildWindowEventHandler(builderArgs);
      return (next2) => {
        return (action) => {
          if (!isAction(action)) {
            return next2(action);
          }
          if (!initialized2) {
            initialized2 = true;
            mwApi.dispatch(api3.internalActions.middlewareRegistered(apiUid));
          }
          const mwApiWithNext = {
            ...mwApi,
            next: next2
          };
          const stateBefore = mwApi.getState();
          const [actionShouldContinue, internalProbeResult] = batchedActionsHandler(action, mwApiWithNext, stateBefore);
          let res;
          if (actionShouldContinue) {
            res = next2(action);
          } else {
            res = internalProbeResult;
          }
          if (!!mwApi.getState()[reducerPath]) {
            windowEventsHandler(action, mwApiWithNext, stateBefore);
            if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {
              for (const handler of handlers) {
                handler(action, mwApiWithNext, stateBefore);
              }
            }
          }
          return res;
        };
      };
    };
    return {
      middleware: middleware2,
      actions: actions3
    };
    function refetchQuery(querySubState) {
      return input.api.endpoints[querySubState.endpointName].initiate(querySubState.originalArgs, {
        subscribe: false,
        forceRefetch: true
      });
    }
  }
  var coreModuleName = /* @__PURE__ */ Symbol();
  var coreModule = ({
    createSelector: createSelector2 = createSelector
  } = {}) => ({
    name: coreModuleName,
    init(api3, {
      baseQuery,
      tagTypes,
      reducerPath,
      serializeQueryArgs,
      keepUnusedDataFor,
      refetchOnMountOrArgChange,
      refetchOnFocus,
      refetchOnReconnect,
      invalidationBehavior
    }, context) {
      enablePatches();
      assertCast(serializeQueryArgs);
      const assertTagType = (tag) => {
        if (typeof process !== "undefined" && true) {
          if (!tagTypes.includes(tag.type)) {
            console.error(`Tag type '${tag.type}' was used, but not specified in \`tagTypes\`!`);
          }
        }
        return tag;
      };
      Object.assign(api3, {
        reducerPath,
        endpoints: {},
        internalActions: {
          onOnline,
          onOffline,
          onFocus,
          onFocusLost
        },
        util: {}
      });
      const selectors5 = buildSelectors({
        serializeQueryArgs,
        reducerPath,
        createSelector: createSelector2
      });
      const {
        selectInvalidatedBy,
        selectCachedArgsForQuery,
        buildQuerySelector,
        buildInfiniteQuerySelector,
        buildMutationSelector
      } = selectors5;
      safeAssign(api3.util, {
        selectInvalidatedBy,
        selectCachedArgsForQuery
      });
      const {
        queryThunk,
        infiniteQueryThunk,
        mutationThunk,
        patchQueryData,
        updateQueryData,
        upsertQueryData,
        prefetch,
        buildMatchThunkActions
      } = buildThunks({
        baseQuery,
        reducerPath,
        context,
        api: api3,
        serializeQueryArgs,
        assertTagType,
        selectors: selectors5
      });
      const {
        reducer,
        actions: sliceActions
      } = buildSlice({
        context,
        queryThunk,
        infiniteQueryThunk,
        mutationThunk,
        serializeQueryArgs,
        reducerPath,
        assertTagType,
        config: {
          refetchOnFocus,
          refetchOnReconnect,
          refetchOnMountOrArgChange,
          keepUnusedDataFor,
          reducerPath,
          invalidationBehavior
        }
      });
      safeAssign(api3.util, {
        patchQueryData,
        updateQueryData,
        upsertQueryData,
        prefetch,
        resetApiState: sliceActions.resetApiState,
        upsertQueryEntries: sliceActions.cacheEntriesUpserted
      });
      safeAssign(api3.internalActions, sliceActions);
      const {
        middleware: middleware2,
        actions: middlewareActions
      } = buildMiddleware({
        reducerPath,
        context,
        queryThunk,
        mutationThunk,
        infiniteQueryThunk,
        api: api3,
        assertTagType,
        selectors: selectors5
      });
      safeAssign(api3.util, middlewareActions);
      safeAssign(api3, {
        reducer,
        middleware: middleware2
      });
      const {
        buildInitiateQuery,
        buildInitiateInfiniteQuery,
        buildInitiateMutation,
        getRunningMutationThunk,
        getRunningMutationsThunk,
        getRunningQueriesThunk,
        getRunningQueryThunk
      } = buildInitiate({
        queryThunk,
        mutationThunk,
        infiniteQueryThunk,
        api: api3,
        serializeQueryArgs,
        context
      });
      safeAssign(api3.util, {
        getRunningMutationThunk,
        getRunningMutationsThunk,
        getRunningQueryThunk,
        getRunningQueriesThunk
      });
      return {
        name: coreModuleName,
        injectEndpoint(endpointName, definition) {
          const anyApi = api3;
          const endpoint = anyApi.endpoints[endpointName] ??= {};
          if (isQueryDefinition(definition)) {
            safeAssign(endpoint, {
              name: endpointName,
              select: buildQuerySelector(endpointName, definition),
              initiate: buildInitiateQuery(endpointName, definition)
            }, buildMatchThunkActions(queryThunk, endpointName));
          }
          if (isMutationDefinition(definition)) {
            safeAssign(endpoint, {
              name: endpointName,
              select: buildMutationSelector(),
              initiate: buildInitiateMutation(endpointName)
            }, buildMatchThunkActions(mutationThunk, endpointName));
          }
          if (isInfiniteQueryDefinition(definition)) {
            safeAssign(endpoint, {
              name: endpointName,
              select: buildInfiniteQuerySelector(endpointName, definition),
              initiate: buildInitiateInfiniteQuery(endpointName, definition)
            }, buildMatchThunkActions(queryThunk, endpointName));
          }
        }
      };
    }
  });
  var createApi = /* @__PURE__ */ buildCreateApi(coreModule());

  // node_modules/@reduxjs/toolkit/dist/query/react/rtk-query-react.modern.mjs
  var import_react = __toESM(require_react(), 1);
  var import_react2 = __toESM(require_react(), 1);
  var import_react3 = __toESM(require_react(), 1);
  var import_react4 = __toESM(require_react(), 1);
  var import_react5 = __toESM(require_react(), 1);
  var React14 = __toESM(require_react(), 1);
  function capitalize(str) {
    return str.replace(str[0], str[0].toUpperCase());
  }
  function countObjectKeys2(obj) {
    let count = 0;
    for (const _key in obj) {
      count++;
    }
    return count;
  }
  function isQueryDefinition2(e) {
    return e.type === "query";
  }
  function isMutationDefinition2(e) {
    return e.type === "mutation";
  }
  function isInfiniteQueryDefinition2(e) {
    return e.type === "infinitequery";
  }
  function safeAssign2(target, ...args) {
    return Object.assign(target, ...args);
  }
  var UNINITIALIZED_VALUE = Symbol();
  function useStableQueryArgs(queryArgs, serialize3, endpointDefinition, endpointName) {
    const incoming = (0, import_react2.useMemo)(() => ({
      queryArgs,
      serialized: typeof queryArgs == "object" ? serialize3({
        queryArgs,
        endpointDefinition,
        endpointName
      }) : queryArgs
    }), [queryArgs, serialize3, endpointDefinition, endpointName]);
    const cache4 = (0, import_react2.useRef)(incoming);
    (0, import_react2.useEffect)(() => {
      if (cache4.current.serialized !== incoming.serialized) {
        cache4.current = incoming;
      }
    }, [incoming]);
    return cache4.current.serialized === incoming.serialized ? cache4.current.queryArgs : queryArgs;
  }
  function useShallowStableValue(value) {
    const cache4 = (0, import_react3.useRef)(value);
    (0, import_react3.useEffect)(() => {
      if (!shallowEqual(cache4.current, value)) {
        cache4.current = value;
      }
    }, [value]);
    return shallowEqual(cache4.current, value) ? cache4.current : value;
  }
  var canUseDOM2 = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
  var isDOM2 = /* @__PURE__ */ canUseDOM2();
  var isRunningInReactNative2 = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
  var isReactNative2 = /* @__PURE__ */ isRunningInReactNative2();
  var getUseIsomorphicLayoutEffect2 = () => isDOM2 || isReactNative2 ? import_react.useLayoutEffect : import_react.useEffect;
  var useIsomorphicLayoutEffect3 = /* @__PURE__ */ getUseIsomorphicLayoutEffect2();
  var noPendingQueryStateSelector = (selected) => {
    if (selected.isUninitialized) {
      return {
        ...selected,
        isUninitialized: false,
        isFetching: true,
        isLoading: selected.data !== void 0 ? false : true,
        status: QueryStatus.pending
      };
    }
    return selected;
  };
  function pick(obj, ...keys) {
    const ret = {};
    keys.forEach((key) => {
      ret[key] = obj[key];
    });
    return ret;
  }
  var COMMON_HOOK_DEBUG_FIELDS = ["data", "status", "isLoading", "isSuccess", "isError", "error"];
  function buildHooks({
    api: api3,
    moduleOptions: {
      batch: batch2,
      hooks: {
        useDispatch: useDispatch2,
        useSelector: useSelector2,
        useStore: useStore2
      },
      unstable__sideEffectsInRender,
      createSelector: createSelector2
    },
    serializeQueryArgs,
    context
  }) {
    const usePossiblyImmediateEffect = unstable__sideEffectsInRender ? (cb) => cb() : import_react.useEffect;
    return {
      buildQueryHooks,
      buildInfiniteQueryHooks,
      buildMutationHook,
      usePrefetch
    };
    function queryStatePreSelector(currentState, lastResult, queryArgs) {
      if (lastResult?.endpointName && currentState.isUninitialized) {
        const {
          endpointName
        } = lastResult;
        const endpointDefinition = context.endpointDefinitions[endpointName];
        if (queryArgs !== skipToken && serializeQueryArgs({
          queryArgs: lastResult.originalArgs,
          endpointDefinition,
          endpointName
        }) === serializeQueryArgs({
          queryArgs,
          endpointDefinition,
          endpointName
        })) lastResult = void 0;
      }
      let data2 = currentState.isSuccess ? currentState.data : lastResult?.data;
      if (data2 === void 0) data2 = currentState.data;
      const hasData = data2 !== void 0;
      const isFetching = currentState.isLoading;
      const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
      const isSuccess = currentState.isSuccess || hasData && (isFetching && !lastResult?.isError || currentState.isUninitialized);
      return {
        ...currentState,
        data: data2,
        currentData: currentState.data,
        isFetching,
        isLoading,
        isSuccess
      };
    }
    function infiniteQueryStatePreSelector(currentState, lastResult, queryArgs) {
      if (lastResult?.endpointName && currentState.isUninitialized) {
        const {
          endpointName
        } = lastResult;
        const endpointDefinition = context.endpointDefinitions[endpointName];
        if (serializeQueryArgs({
          queryArgs: lastResult.originalArgs,
          endpointDefinition,
          endpointName
        }) === serializeQueryArgs({
          queryArgs,
          endpointDefinition,
          endpointName
        })) lastResult = void 0;
      }
      let data2 = currentState.isSuccess ? currentState.data : lastResult?.data;
      if (data2 === void 0) data2 = currentState.data;
      const hasData = data2 !== void 0;
      const isFetching = currentState.isLoading;
      const isLoading = (!lastResult || lastResult.isLoading || lastResult.isUninitialized) && !hasData && isFetching;
      const isSuccess = currentState.isSuccess || isFetching && hasData;
      return {
        ...currentState,
        data: data2,
        currentData: currentState.data,
        isFetching,
        isLoading,
        isSuccess
      };
    }
    function usePrefetch(endpointName, defaultOptions) {
      const dispatch = useDispatch2();
      const stableDefaultOptions = useShallowStableValue(defaultOptions);
      return (0, import_react.useCallback)((arg, options2) => dispatch(api3.util.prefetch(endpointName, arg, {
        ...stableDefaultOptions,
        ...options2
      })), [endpointName, dispatch, stableDefaultOptions]);
    }
    function useQuerySubscriptionCommonImpl(endpointName, arg, {
      refetchOnReconnect,
      refetchOnFocus,
      refetchOnMountOrArgChange,
      skip: skip2 = false,
      pollingInterval = 0,
      skipPollingIfUnfocused = false,
      ...rest
    } = {}) {
      const {
        initiate
      } = api3.endpoints[endpointName];
      const dispatch = useDispatch2();
      const subscriptionSelectorsRef = (0, import_react.useRef)(void 0);
      if (!subscriptionSelectorsRef.current) {
        const returnedValue = dispatch(api3.internalActions.internal_getRTKQSubscriptions());
        if (true) {
          if (typeof returnedValue !== "object" || typeof returnedValue?.type === "string") {
            throw new Error(false ? formatProdErrorMessage(37) : `Warning: Middleware for RTK-Query API at reducerPath "${api3.reducerPath}" has not been added to the store.
    You must add the middleware for RTK-Query to function correctly!`);
          }
        }
        subscriptionSelectorsRef.current = returnedValue;
      }
      const stableArg = useStableQueryArgs(
        skip2 ? skipToken : arg,
        // Even if the user provided a per-endpoint `serializeQueryArgs` with
        // a consistent return value, _here_ we want to use the default behavior
        // so we can tell if _anything_ actually changed. Otherwise, we can end up
        // with a case where the query args did change but the serialization doesn't,
        // and then we never try to initiate a refetch.
        defaultSerializeQueryArgs,
        context.endpointDefinitions[endpointName],
        endpointName
      );
      const stableSubscriptionOptions = useShallowStableValue({
        refetchOnReconnect,
        refetchOnFocus,
        pollingInterval,
        skipPollingIfUnfocused
      });
      const lastRenderHadSubscription = (0, import_react.useRef)(false);
      const initialPageParam = rest.initialPageParam;
      const stableInitialPageParam = useShallowStableValue(initialPageParam);
      const promiseRef = (0, import_react.useRef)(void 0);
      let {
        queryCacheKey,
        requestId
      } = promiseRef.current || {};
      let currentRenderHasSubscription = false;
      if (queryCacheKey && requestId) {
        currentRenderHasSubscription = subscriptionSelectorsRef.current.isRequestSubscribed(queryCacheKey, requestId);
      }
      const subscriptionRemoved = !currentRenderHasSubscription && lastRenderHadSubscription.current;
      usePossiblyImmediateEffect(() => {
        lastRenderHadSubscription.current = currentRenderHasSubscription;
      });
      usePossiblyImmediateEffect(() => {
        if (subscriptionRemoved) {
          promiseRef.current = void 0;
        }
      }, [subscriptionRemoved]);
      usePossiblyImmediateEffect(() => {
        const lastPromise = promiseRef.current;
        if (typeof process !== "undefined" && false) {
          console.log(subscriptionRemoved);
        }
        if (stableArg === skipToken) {
          lastPromise?.unsubscribe();
          promiseRef.current = void 0;
          return;
        }
        const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;
        if (!lastPromise || lastPromise.arg !== stableArg) {
          lastPromise?.unsubscribe();
          const promise = dispatch(initiate(stableArg, {
            subscriptionOptions: stableSubscriptionOptions,
            forceRefetch: refetchOnMountOrArgChange,
            ...isInfiniteQueryDefinition2(context.endpointDefinitions[endpointName]) ? {
              initialPageParam: stableInitialPageParam
            } : {}
          }));
          promiseRef.current = promise;
        } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {
          lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);
        }
      }, [dispatch, initiate, refetchOnMountOrArgChange, stableArg, stableSubscriptionOptions, subscriptionRemoved, stableInitialPageParam, endpointName]);
      return [promiseRef, dispatch, initiate, stableSubscriptionOptions];
    }
    function buildUseQueryState(endpointName, preSelector) {
      const useQueryState = (arg, {
        skip: skip2 = false,
        selectFromResult
      } = {}) => {
        const {
          select
        } = api3.endpoints[endpointName];
        const stableArg = useStableQueryArgs(skip2 ? skipToken : arg, serializeQueryArgs, context.endpointDefinitions[endpointName], endpointName);
        const lastValue = (0, import_react.useRef)(void 0);
        const selectDefaultResult = (0, import_react.useMemo)(() => (
          // Normally ts-ignores are bad and should be avoided, but we're
          // already casting this selector to be `Selector<any>` anyway,
          // so the inconsistencies don't matter here
          // @ts-ignore
          createSelector2([
            // @ts-ignore
            select(stableArg),
            (_, lastResult) => lastResult,
            (_) => stableArg
          ], preSelector, {
            memoizeOptions: {
              resultEqualityCheck: shallowEqual
            }
          })
        ), [select, stableArg]);
        const querySelector = (0, import_react.useMemo)(() => selectFromResult ? createSelector2([selectDefaultResult], selectFromResult, {
          devModeChecks: {
            identityFunctionCheck: "never"
          }
        }) : selectDefaultResult, [selectDefaultResult, selectFromResult]);
        const currentState = useSelector2((state) => querySelector(state, lastValue.current), shallowEqual);
        const store2 = useStore2();
        const newLastValue = selectDefaultResult(store2.getState(), lastValue.current);
        useIsomorphicLayoutEffect3(() => {
          lastValue.current = newLastValue;
        }, [newLastValue]);
        return currentState;
      };
      return useQueryState;
    }
    function usePromiseRefUnsubscribeOnUnmount(promiseRef) {
      (0, import_react.useEffect)(() => {
        return () => {
          promiseRef.current?.unsubscribe?.();
          promiseRef.current = void 0;
        };
      }, [promiseRef]);
    }
    function refetchOrErrorIfUnmounted(promiseRef) {
      if (!promiseRef.current) throw new Error(false ? formatProdErrorMessage(38) : "Cannot refetch a query that has not been started yet.");
      return promiseRef.current.refetch();
    }
    function buildQueryHooks(endpointName) {
      const useQuerySubscription = (arg, options2 = {}) => {
        const [promiseRef] = useQuerySubscriptionCommonImpl(endpointName, arg, options2);
        usePromiseRefUnsubscribeOnUnmount(promiseRef);
        return (0, import_react.useMemo)(() => ({
          /**
           * A method to manually refetch data for the query
           */
          refetch: () => refetchOrErrorIfUnmounted(promiseRef)
        }), [promiseRef]);
      };
      const useLazyQuerySubscription = ({
        refetchOnReconnect,
        refetchOnFocus,
        pollingInterval = 0,
        skipPollingIfUnfocused = false
      } = {}) => {
        const {
          initiate
        } = api3.endpoints[endpointName];
        const dispatch = useDispatch2();
        const [arg, setArg] = (0, import_react.useState)(UNINITIALIZED_VALUE);
        const promiseRef = (0, import_react.useRef)(void 0);
        const stableSubscriptionOptions = useShallowStableValue({
          refetchOnReconnect,
          refetchOnFocus,
          pollingInterval,
          skipPollingIfUnfocused
        });
        usePossiblyImmediateEffect(() => {
          const lastSubscriptionOptions = promiseRef.current?.subscriptionOptions;
          if (stableSubscriptionOptions !== lastSubscriptionOptions) {
            promiseRef.current?.updateSubscriptionOptions(stableSubscriptionOptions);
          }
        }, [stableSubscriptionOptions]);
        const subscriptionOptionsRef = (0, import_react.useRef)(stableSubscriptionOptions);
        usePossiblyImmediateEffect(() => {
          subscriptionOptionsRef.current = stableSubscriptionOptions;
        }, [stableSubscriptionOptions]);
        const trigger = (0, import_react.useCallback)(function(arg2, preferCacheValue = false) {
          let promise;
          batch2(() => {
            promiseRef.current?.unsubscribe();
            promiseRef.current = promise = dispatch(initiate(arg2, {
              subscriptionOptions: subscriptionOptionsRef.current,
              forceRefetch: !preferCacheValue
            }));
            setArg(arg2);
          });
          return promise;
        }, [dispatch, initiate]);
        const reset = (0, import_react.useCallback)(() => {
          if (promiseRef.current?.queryCacheKey) {
            dispatch(api3.internalActions.removeQueryResult({
              queryCacheKey: promiseRef.current?.queryCacheKey
            }));
          }
        }, [dispatch]);
        (0, import_react.useEffect)(() => {
          return () => {
            promiseRef?.current?.unsubscribe();
          };
        }, []);
        (0, import_react.useEffect)(() => {
          if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {
            trigger(arg, true);
          }
        }, [arg, trigger]);
        return (0, import_react.useMemo)(() => [trigger, arg, {
          reset
        }], [trigger, arg, reset]);
      };
      const useQueryState = buildUseQueryState(endpointName, queryStatePreSelector);
      return {
        useQueryState,
        useQuerySubscription,
        useLazyQuerySubscription,
        useLazyQuery(options2) {
          const [trigger, arg, {
            reset
          }] = useLazyQuerySubscription(options2);
          const queryStateResults = useQueryState(arg, {
            ...options2,
            skip: arg === UNINITIALIZED_VALUE
          });
          const info = (0, import_react.useMemo)(() => ({
            lastArg: arg
          }), [arg]);
          return (0, import_react.useMemo)(() => [trigger, {
            ...queryStateResults,
            reset
          }, info], [trigger, queryStateResults, reset, info]);
        },
        useQuery(arg, options2) {
          const querySubscriptionResults = useQuerySubscription(arg, options2);
          const queryStateResults = useQueryState(arg, {
            selectFromResult: arg === skipToken || options2?.skip ? void 0 : noPendingQueryStateSelector,
            ...options2
          });
          const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS);
          (0, import_react.useDebugValue)(debugValue);
          return (0, import_react.useMemo)(() => ({
            ...queryStateResults,
            ...querySubscriptionResults
          }), [queryStateResults, querySubscriptionResults]);
        }
      };
    }
    function buildInfiniteQueryHooks(endpointName) {
      const useInfiniteQuerySubscription = (arg, options2 = {}) => {
        const [promiseRef, dispatch, initiate, stableSubscriptionOptions] = useQuerySubscriptionCommonImpl(endpointName, arg, options2);
        const subscriptionOptionsRef = (0, import_react.useRef)(stableSubscriptionOptions);
        usePossiblyImmediateEffect(() => {
          subscriptionOptionsRef.current = stableSubscriptionOptions;
        }, [stableSubscriptionOptions]);
        const trigger = (0, import_react.useCallback)(function(arg2, direction) {
          let promise;
          batch2(() => {
            promiseRef.current?.unsubscribe();
            promiseRef.current = promise = dispatch(initiate(arg2, {
              subscriptionOptions: subscriptionOptionsRef.current,
              direction
            }));
          });
          return promise;
        }, [promiseRef, dispatch, initiate]);
        usePromiseRefUnsubscribeOnUnmount(promiseRef);
        return (0, import_react.useMemo)(() => {
          const fetchNextPage = () => {
            return trigger(arg, "forward");
          };
          const fetchPreviousPage = () => {
            return trigger(arg, "backward");
          };
          return {
            trigger,
            /**
             * A method to manually refetch data for the query
             */
            refetch: () => refetchOrErrorIfUnmounted(promiseRef),
            fetchNextPage,
            fetchPreviousPage
          };
        }, [promiseRef, trigger, arg]);
      };
      const useInfiniteQueryState = buildUseQueryState(endpointName, infiniteQueryStatePreSelector);
      return {
        useInfiniteQueryState,
        useInfiniteQuerySubscription,
        useInfiniteQuery(arg, options2) {
          const {
            refetch,
            fetchNextPage,
            fetchPreviousPage
          } = useInfiniteQuerySubscription(arg, options2);
          const queryStateResults = useInfiniteQueryState(arg, {
            selectFromResult: arg === skipToken || options2?.skip ? void 0 : noPendingQueryStateSelector,
            ...options2
          });
          const debugValue = pick(queryStateResults, ...COMMON_HOOK_DEBUG_FIELDS, "hasNextPage", "hasPreviousPage");
          (0, import_react.useDebugValue)(debugValue);
          return (0, import_react.useMemo)(() => ({
            ...queryStateResults,
            fetchNextPage,
            fetchPreviousPage,
            refetch
          }), [queryStateResults, fetchNextPage, fetchPreviousPage, refetch]);
        }
      };
    }
    function buildMutationHook(name) {
      return ({
        selectFromResult,
        fixedCacheKey
      } = {}) => {
        const {
          select,
          initiate
        } = api3.endpoints[name];
        const dispatch = useDispatch2();
        const [promise, setPromise] = (0, import_react.useState)();
        (0, import_react.useEffect)(() => () => {
          if (!promise?.arg.fixedCacheKey) {
            promise?.reset();
          }
        }, [promise]);
        const triggerMutation = (0, import_react.useCallback)(function(arg) {
          const promise2 = dispatch(initiate(arg, {
            fixedCacheKey
          }));
          setPromise(promise2);
          return promise2;
        }, [dispatch, initiate, fixedCacheKey]);
        const {
          requestId
        } = promise || {};
        const selectDefaultResult = (0, import_react.useMemo)(() => select({
          fixedCacheKey,
          requestId: promise?.requestId
        }), [fixedCacheKey, promise, select]);
        const mutationSelector = (0, import_react.useMemo)(() => selectFromResult ? createSelector2([selectDefaultResult], selectFromResult) : selectDefaultResult, [selectFromResult, selectDefaultResult]);
        const currentState = useSelector2(mutationSelector, shallowEqual);
        const originalArgs = fixedCacheKey == null ? promise?.arg.originalArgs : void 0;
        const reset = (0, import_react.useCallback)(() => {
          batch2(() => {
            if (promise) {
              setPromise(void 0);
            }
            if (fixedCacheKey) {
              dispatch(api3.internalActions.removeMutationResult({
                requestId,
                fixedCacheKey
              }));
            }
          });
        }, [dispatch, fixedCacheKey, promise, requestId]);
        const debugValue = pick(currentState, ...COMMON_HOOK_DEBUG_FIELDS, "endpointName");
        (0, import_react.useDebugValue)(debugValue);
        const finalState = (0, import_react.useMemo)(() => ({
          ...currentState,
          originalArgs,
          reset
        }), [currentState, originalArgs, reset]);
        return (0, import_react.useMemo)(() => [triggerMutation, finalState], [triggerMutation, finalState]);
      };
    }
  }
  var reactHooksModuleName = /* @__PURE__ */ Symbol();
  var reactHooksModule = ({
    batch: batch2 = batch,
    hooks = {
      useDispatch,
      useSelector,
      useStore
    },
    createSelector: createSelector2 = createSelector,
    unstable__sideEffectsInRender = false,
    ...rest
  } = {}) => {
    if (true) {
      const hookNames = ["useDispatch", "useSelector", "useStore"];
      let warned = false;
      for (const hookName of hookNames) {
        if (countObjectKeys2(rest) > 0) {
          if (rest[hookName]) {
            if (!warned) {
              console.warn("As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`");
              warned = true;
            }
          }
          hooks[hookName] = rest[hookName];
        }
        if (typeof hooks[hookName] !== "function") {
          throw new Error(false ? formatProdErrorMessage(36) : `When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(", ")}.
Hook ${hookName} was either not provided or not a function.`);
        }
      }
    }
    return {
      name: reactHooksModuleName,
      init(api3, {
        serializeQueryArgs
      }, context) {
        const anyApi = api3;
        const {
          buildQueryHooks,
          buildInfiniteQueryHooks,
          buildMutationHook,
          usePrefetch
        } = buildHooks({
          api: api3,
          moduleOptions: {
            batch: batch2,
            hooks,
            unstable__sideEffectsInRender,
            createSelector: createSelector2
          },
          serializeQueryArgs,
          context
        });
        safeAssign2(anyApi, {
          usePrefetch
        });
        safeAssign2(context, {
          batch: batch2
        });
        return {
          injectEndpoint(endpointName, definition) {
            if (isQueryDefinition2(definition)) {
              const {
                useQuery,
                useLazyQuery,
                useLazyQuerySubscription,
                useQueryState,
                useQuerySubscription
              } = buildQueryHooks(endpointName);
              safeAssign2(anyApi.endpoints[endpointName], {
                useQuery,
                useLazyQuery,
                useLazyQuerySubscription,
                useQueryState,
                useQuerySubscription
              });
              api3[`use${capitalize(endpointName)}Query`] = useQuery;
              api3[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;
            }
            if (isMutationDefinition2(definition)) {
              const useMutation = buildMutationHook(endpointName);
              safeAssign2(anyApi.endpoints[endpointName], {
                useMutation
              });
              api3[`use${capitalize(endpointName)}Mutation`] = useMutation;
            } else if (isInfiniteQueryDefinition2(definition)) {
              const {
                useInfiniteQuery,
                useInfiniteQuerySubscription,
                useInfiniteQueryState
              } = buildInfiniteQueryHooks(endpointName);
              safeAssign2(anyApi.endpoints[endpointName], {
                useInfiniteQuery,
                useInfiniteQuerySubscription,
                useInfiniteQueryState
              });
              api3[`use${capitalize(endpointName)}InfiniteQuery`] = useInfiniteQuery;
            }
          }
        };
      }
    };
  };
  var createApi2 = /* @__PURE__ */ buildCreateApi(coreModule(), reactHooksModule());

  // assets/scripts/lib/error.ts
  var networkError = "It looks like you lost your internet connection. Please reload this page and try again.";
  var notFoundError = "Some data requested by this page could not be loaded.";
  var serverError = "Something went wrong on the server.";
  var isErrorWithMessage = (error) => typeof error === "object" && error !== null && "message" in error && typeof error.message === "string";
  var toErrorWithMessage = (maybeError) => {
    if (isErrorWithMessage(maybeError)) return maybeError;
    try {
      return new Error(JSON.stringify(maybeError));
    } catch (e) {
      console.error(e);
      return new Error(String(maybeError));
    }
  };
  var toErrorObject = (error) => JSON.parse(JSON.stringify(error, Object.getOwnPropertyNames(error)));
  var looksLikeJSON = (message) => message.startsWith('{"');
  var getError = (maybeError) => {
    const errorObject = toErrorObject(toErrorWithMessage(maybeError));
    const error = {
      message: errorObject.message,
      status: errorObject.status
    };
    if (!error.status && "originalStatus" in maybeError) {
      error.status = maybeError.originalStatus;
    }
    if (looksLikeJSON(error.message)) {
      const messageObject = JSON.parse(error.message);
      if ("error" in messageObject) {
        error.message = messageObject.error;
      }
    }
    if (error.message.includes("NetworkError")) {
      error.customMessage = networkError;
    } else if (error.status === 500) {
      error.customMessage = serverError;
    } else if (error.status === 404) {
      error.customMessage = notFoundError;
    }
    return error;
  };

  // assets/scripts/lib/sorting.ts
  var sortQuarterAscendingTypeDecending = (a, b) => a.quarter - b.quarter || b.type.localeCompare(a.type);

  // assets/scripts/selectors.ts
  var getEntities = (state) => state.entities;
  var getIncidents = (state) => state.incidents;
  var getPeople = (state) => state.people;
  var getSources = (state) => state.sources;
  var getStats = (state) => state.stats;
  var getUI = (state) => state.ui;
  var getEntitiesLeaderboard = createSelector(getEntities, (entities) => entities.leaderboard);
  var getEntitiesPagination = createSelector(getEntities, (entities) => entities.pagination);
  var getEntitiesPageIds = createSelector(getEntities, (entities) => entities.pageIds);
  var getIncidentsPagination = createSelector(getIncidents, (incidents) => incidents.pagination);
  var getIncidentsPageIds = createSelector(getIncidents, (incidents) => incidents.pageIds);
  var getIncidentFirst = createSelector(getIncidents, (incidents) => incidents.first);
  var getIncidentLast = createSelector(getIncidents, (incidents) => incidents.last);
  var getIncidentTotal = createSelector(getIncidents, (incidents) => incidents.total);
  var getPeopleLeaderboard = createSelector(getPeople, (people) => people.leaderboard);
  var getPeoplePagination = createSelector(getPeople, (people) => people.pagination);
  var getPeoplePageIds = createSelector(getPeople, (people) => people.pageIds);
  var getSourcesStats = createSelector(getStats, (stats) => stats.sources);
  var getSourcesChartIds = createSelector(
    getSourcesStats,
    (stats) => stats.map((value) => value.id)
  );
  var getSourcesChartLabels = createSelector(
    getSourcesStats,
    (stats) => stats.map((value) => value.label)
  );
  var getSourcesChartData = createSelector(
    getSourcesStats,
    (stats) => stats.map((value) => value.total)
  );
  var getSourcesDataForChart = createSelector(
    [getSourcesChartLabels, getSourcesChartData],
    (labels, data2) => ({ labels, data: data2 })
  );
  var getSourcesByYear = createSelector(
    getSources,
    (sources) => {
      const sourcesByYear = Object.values(sources.entities).reduce((byYear, item) => {
        if (!(item.year in byYear)) {
          byYear[item.year] = {
            year: item.year,
            items: []
          };
        }
        byYear[item.year].items.push(item);
        byYear[item.year].items.sort(sortQuarterAscendingTypeDecending);
        return byYear;
      }, {});
      return Object.values(sourcesByYear);
    }
  );
  var getIndexedTotals = (sourceIds, values) => values.map((value) => value.id).reduce((indexed, id) => {
    const match2 = values.find((value) => value.id === id);
    indexed[id] = sourceIds.map((sourceId) => {
      const data2 = match2.stats.find((stat) => stat.dataSourceId === sourceId);
      return data2 ? data2.total : null;
    });
    return indexed;
  }, {});
  var getEntitiesStats = createSelector(getStats, (stats) => stats.entities);
  var getEntitiesChartData = createSelector(
    [getSourcesChartIds, getEntitiesStats],
    getIndexedTotals
  );
  var getPeopleStats = createSelector(getStats, (stats) => stats.people);
  var getPeopleChartData = createSelector(
    [getSourcesChartIds, getPeopleStats],
    getIndexedTotals
  );
  var getDescription = createSelector(getUI, (ui) => ui.description);
  var getPageTitle = createSelector(getUI, (ui) => ui.pageTitle);
  var getErrors = createSelector(getUI, (ui) => ui.errors);
  var getMessages = createSelector(getUI, (ui) => ui.messages);
  var getSection = createSelector(getUI, (ui) => ui.section);
  var getWarnings = createSelector(getUI, (ui) => ui.warnings);

  // assets/scripts/reducers/entities.ts
  var adapters = {
    adaptOne: (entity) => {
      if (entity.incidents) {
        const {
          filters,
          pagination,
          records,
          stats
        } = entity.incidents;
        const ids = records ? { ids: records.map((record) => record.id) } : void 0;
        return {
          ...entity,
          incidents: {
            filters,
            pagination,
            stats,
            ...ids
          }
        };
      }
      return entity;
    },
    getIds: (entities) => entities.map((entity) => entity.id),
    getIncidents: (entity) => entity.incidents?.records ?? []
  };
  var adapter = createEntityAdapter();
  var selectors = adapter.getSelectors(getEntities);
  var leaderboardSet = {
    ids: [],
    labels: {
      links: {
        more: ""
      },
      subtitle: "",
      table: {
        title: ""
      },
      title: ""
    }
  };
  var initialState2 = {
    leaderboard: {
      all: leaderboardSet
    },
    pageIds: [],
    pagination: null
  };
  var entitiesSlice = createSlice({
    name: "entities",
    initialState: adapter.getInitialState(initialState2),
    reducers: {
      set: (state, action) => {
        adapter.upsertOne(state, action.payload);
      },
      setAll: (state, action) => {
        adapter.upsertMany(state, action.payload);
      },
      setPageIds: (state, action) => {
        state.pageIds = action.payload;
      },
      setPagination: (state, action) => {
        state.pagination = { ...action.payload };
      },
      setLeaderboard: (state, action) => {
        state.leaderboard = action.payload;
      }
    }
  });
  var {
    set: set2,
    setAll,
    setLeaderboard,
    setPageIds,
    setPagination
  } = entitiesSlice.actions;
  var entities_default = entitiesSlice.reducer;

  // assets/scripts/reducers/incidents.ts
  var adapters2 = {
    adaptOne: (incident) => incident,
    getIds: (people) => people.map((incident) => incident.id)
  };
  var adapter2 = createEntityAdapter();
  var selectors2 = adapter2.getSelectors(getIncidents);
  var incidentsSlice = createSlice({
    name: "incidents",
    initialState: adapter2.getInitialState({
      pageIds: [],
      pagination: null,
      first: null,
      last: null,
      total: 0
    }),
    reducers: {
      set: (state, action) => {
        adapter2.upsertOne(state, action.payload);
      },
      setAll: (state, action) => {
        adapter2.upsertMany(state, action.payload);
      },
      setPageIds: (state, action) => {
        state.pageIds = action.payload;
      },
      setPagination: (state, action) => {
        state.pagination = { ...action.payload };
      },
      setFirst(state, action) {
        state.first = action.payload;
        adapter2.upsertOne(state, action.payload);
      },
      setLast(state, action) {
        state.last = action.payload;
        adapter2.upsertOne(state, action.payload);
      },
      setTotal(state, action) {
        state.total = action.payload;
      }
    }
  });
  var {
    set: set3,
    setAll: setAll2,
    setFirst,
    setLast,
    setPageIds: setPageIds2,
    setPagination: setPagination2,
    setTotal
  } = incidentsSlice.actions;
  var incidents_default = incidentsSlice.reducer;

  // assets/scripts/reducers/people.ts
  var adapters3 = {
    adaptOne: (person) => {
      if (person.incidents) {
        const {
          filters,
          pagination,
          records,
          stats
        } = person.incidents;
        const ids = records ? { ids: records.map((record) => record.id) } : void 0;
        return {
          ...person,
          incidents: {
            filters,
            pagination,
            stats,
            ...ids
          }
        };
      }
      return person;
    },
    getIds: (people) => people.map((person) => person.id),
    getIncidents: (person) => person.incidents?.records ?? []
  };
  var adapter3 = createEntityAdapter();
  var selectors3 = adapter3.getSelectors(getPeople);
  var leaderboardSet2 = {
    ids: [],
    labels: {
      links: {
        more: ""
      },
      subtitle: "",
      table: {
        title: ""
      },
      title: ""
    }
  };
  var initialState3 = {
    leaderboard: {
      lobbyists: leaderboardSet2,
      officials: leaderboardSet2
    },
    pageIds: [],
    pagination: null
  };
  var peopleSlice = createSlice({
    name: "people",
    initialState: adapter3.getInitialState(initialState3),
    reducers: {
      set: (state, action) => {
        adapter3.upsertOne(state, action.payload);
      },
      setAll: (state, action) => {
        adapter3.upsertMany(state, action.payload);
      },
      setPageIds: (state, action) => {
        state.pageIds = action.payload;
      },
      setPagination: (state, action) => {
        state.pagination = { ...action.payload };
      },
      setLeaderboard: (state, action) => {
        state.leaderboard = action.payload;
      }
    }
  });
  var {
    set: set4,
    setAll: setAll3,
    setLeaderboard: setLeaderboard2,
    setPageIds: setPageIds3,
    setPagination: setPagination3
  } = peopleSlice.actions;
  var people_default = peopleSlice.reducer;

  // node_modules/map-obj/index.js
  var isObject = (value) => typeof value === "object" && value !== null;
  var isObjectCustom = (value) => isObject(value) && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
  var mapObjectSkip = Symbol("mapObjectSkip");
  var _mapObject = (object, mapper, options2, isSeen = /* @__PURE__ */ new WeakMap()) => {
    options2 = {
      deep: false,
      target: {},
      ...options2
    };
    if (isSeen.has(object)) {
      return isSeen.get(object);
    }
    isSeen.set(object, options2.target);
    const { target } = options2;
    delete options2.target;
    const mapArray = (array) => array.map((element) => isObjectCustom(element) ? _mapObject(element, mapper, options2, isSeen) : element);
    if (Array.isArray(object)) {
      return mapArray(object);
    }
    for (const [key, value] of Object.entries(object)) {
      const mapResult = mapper(key, value, object);
      if (mapResult === mapObjectSkip) {
        continue;
      }
      let [newKey, newValue, { shouldRecurse = true } = {}] = mapResult;
      if (newKey === "__proto__") {
        continue;
      }
      if (options2.deep && shouldRecurse && isObjectCustom(newValue)) {
        newValue = Array.isArray(newValue) ? mapArray(newValue) : _mapObject(newValue, mapper, options2, isSeen);
      }
      target[newKey] = newValue;
    }
    return target;
  };
  function mapObject(object, mapper, options2) {
    if (!isObject(object)) {
      throw new TypeError(`Expected an object, got \`${object}\` (${typeof object})`);
    }
    return _mapObject(object, mapper, options2);
  }

  // node_modules/camelcase/index.js
  var UPPERCASE = /[\p{Lu}]/u;
  var LOWERCASE = /[\p{Ll}]/u;
  var LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu;
  var IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u;
  var SEPARATORS = /[_.\- ]+/;
  var LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source);
  var SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu");
  var NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu");
  var preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase2) => {
    let isLastCharLower = false;
    let isLastCharUpper = false;
    let isLastLastCharUpper = false;
    let isLastLastCharPreserved = false;
    for (let index = 0; index < string.length; index++) {
      const character2 = string[index];
      isLastLastCharPreserved = index > 2 ? string[index - 3] === "-" : true;
      if (isLastCharLower && UPPERCASE.test(character2)) {
        string = string.slice(0, index) + "-" + string.slice(index);
        isLastCharLower = false;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = true;
        index++;
      } else if (isLastCharUpper && isLastLastCharUpper && LOWERCASE.test(character2) && (!isLastLastCharPreserved || preserveConsecutiveUppercase2)) {
        string = string.slice(0, index - 1) + "-" + string.slice(index - 1);
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = false;
        isLastCharLower = true;
      } else {
        isLastCharLower = toLowerCase(character2) === character2 && toUpperCase(character2) !== character2;
        isLastLastCharUpper = isLastCharUpper;
        isLastCharUpper = toUpperCase(character2) === character2 && toLowerCase(character2) !== character2;
      }
    }
    return string;
  };
  var preserveConsecutiveUppercase = (input, toLowerCase) => {
    LEADING_CAPITAL.lastIndex = 0;
    return input.replaceAll(LEADING_CAPITAL, (match2) => toLowerCase(match2));
  };
  var postProcess = (input, toUpperCase) => {
    SEPARATORS_AND_IDENTIFIER.lastIndex = 0;
    NUMBERS_AND_IDENTIFIER.lastIndex = 0;
    return input.replaceAll(NUMBERS_AND_IDENTIFIER, (match2, pattern, offset) => ["_", "-"].includes(input.charAt(offset + match2.length)) ? match2 : toUpperCase(match2)).replaceAll(SEPARATORS_AND_IDENTIFIER, (_, identifier2) => toUpperCase(identifier2));
  };
  function camelCase(input, options2) {
    if (!(typeof input === "string" || Array.isArray(input))) {
      throw new TypeError("Expected the input to be `string | string[]`");
    }
    options2 = {
      pascalCase: false,
      preserveConsecutiveUppercase: false,
      ...options2
    };
    if (Array.isArray(input)) {
      input = input.map((x2) => x2.trim()).filter((x2) => x2.length).join("-");
    } else {
      input = input.trim();
    }
    if (input.length === 0) {
      return "";
    }
    const toLowerCase = options2.locale === false ? (string) => string.toLowerCase() : (string) => string.toLocaleLowerCase(options2.locale);
    const toUpperCase = options2.locale === false ? (string) => string.toUpperCase() : (string) => string.toLocaleUpperCase(options2.locale);
    if (input.length === 1) {
      if (SEPARATORS.test(input)) {
        return "";
      }
      return options2.pascalCase ? toUpperCase(input) : toLowerCase(input);
    }
    const hasUpperCase = input !== toLowerCase(input);
    if (hasUpperCase) {
      input = preserveCamelCase(input, toLowerCase, toUpperCase, options2.preserveConsecutiveUppercase);
    }
    input = input.replace(LEADING_SEPARATORS, "");
    input = options2.preserveConsecutiveUppercase ? preserveConsecutiveUppercase(input, toLowerCase) : toLowerCase(input);
    if (options2.pascalCase) {
      input = toUpperCase(input.charAt(0)) + input.slice(1);
    }
    return postProcess(input, toUpperCase);
  }

  // node_modules/quick-lru/index.js
  var QuickLRU = class extends Map {
    constructor(options2 = {}) {
      super();
      if (!(options2.maxSize && options2.maxSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      if (typeof options2.maxAge === "number" && options2.maxAge === 0) {
        throw new TypeError("`maxAge` must be a number greater than 0");
      }
      this.maxSize = options2.maxSize;
      this.maxAge = options2.maxAge || Number.POSITIVE_INFINITY;
      this.onEviction = options2.onEviction;
      this.cache = /* @__PURE__ */ new Map();
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    // TODO: Use private class methods when targeting Node.js 16.
    _emitEvictions(cache4) {
      if (typeof this.onEviction !== "function") {
        return;
      }
      for (const [key, item] of cache4) {
        this.onEviction(key, item.value);
      }
    }
    _deleteIfExpired(key, item) {
      if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
        if (typeof this.onEviction === "function") {
          this.onEviction(key, item.value);
        }
        return this.delete(key);
      }
      return false;
    }
    _getOrDeleteIfExpired(key, item) {
      const deleted = this._deleteIfExpired(key, item);
      if (deleted === false) {
        return item.value;
      }
    }
    _getItemValue(key, item) {
      return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
    }
    _peek(key, cache4) {
      const item = cache4.get(key);
      return this._getItemValue(key, item);
    }
    _set(key, value) {
      this.cache.set(key, value);
      this._size++;
      if (this._size >= this.maxSize) {
        this._size = 0;
        this._emitEvictions(this.oldCache);
        this.oldCache = this.cache;
        this.cache = /* @__PURE__ */ new Map();
      }
    }
    _moveToRecent(key, item) {
      this.oldCache.delete(key);
      this._set(key, item);
    }
    *_entriesAscending() {
      for (const item of this.oldCache) {
        const [key, value] = item;
        if (!this.cache.has(key)) {
          const deleted = this._deleteIfExpired(key, value);
          if (deleted === false) {
            yield item;
          }
        }
      }
      for (const item of this.cache) {
        const [key, value] = item;
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    get(key) {
      if (this.cache.has(key)) {
        const item = this.cache.get(key);
        return this._getItemValue(key, item);
      }
      if (this.oldCache.has(key)) {
        const item = this.oldCache.get(key);
        if (this._deleteIfExpired(key, item) === false) {
          this._moveToRecent(key, item);
          return item.value;
        }
      }
    }
    set(key, value, { maxAge = this.maxAge } = {}) {
      const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
      if (this.cache.has(key)) {
        this.cache.set(key, {
          value,
          expiry
        });
      } else {
        this._set(key, { value, expiry });
      }
      return this;
    }
    has(key) {
      if (this.cache.has(key)) {
        return !this._deleteIfExpired(key, this.cache.get(key));
      }
      if (this.oldCache.has(key)) {
        return !this._deleteIfExpired(key, this.oldCache.get(key));
      }
      return false;
    }
    peek(key) {
      if (this.cache.has(key)) {
        return this._peek(key, this.cache);
      }
      if (this.oldCache.has(key)) {
        return this._peek(key, this.oldCache);
      }
    }
    delete(key) {
      const deleted = this.cache.delete(key);
      if (deleted) {
        this._size--;
      }
      return this.oldCache.delete(key) || deleted;
    }
    clear() {
      this.cache.clear();
      this.oldCache.clear();
      this._size = 0;
    }
    resize(newSize) {
      if (!(newSize && newSize > 0)) {
        throw new TypeError("`maxSize` must be a number greater than 0");
      }
      const items = [...this._entriesAscending()];
      const removeCount = items.length - newSize;
      if (removeCount < 0) {
        this.cache = new Map(items);
        this.oldCache = /* @__PURE__ */ new Map();
        this._size = items.length;
      } else {
        if (removeCount > 0) {
          this._emitEvictions(items.slice(0, removeCount));
        }
        this.oldCache = new Map(items.slice(removeCount));
        this.cache = /* @__PURE__ */ new Map();
        this._size = 0;
      }
      this.maxSize = newSize;
    }
    *keys() {
      for (const [key] of this) {
        yield key;
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    *[Symbol.iterator]() {
      for (const item of this.cache) {
        const [key, value] = item;
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      for (const item of this.oldCache) {
        const [key, value] = item;
        if (!this.cache.has(key)) {
          const deleted = this._deleteIfExpired(key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesDescending() {
      let items = [...this.cache];
      for (let i = items.length - 1; i >= 0; --i) {
        const item = items[i];
        const [key, value] = item;
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
      items = [...this.oldCache];
      for (let i = items.length - 1; i >= 0; --i) {
        const item = items[i];
        const [key, value] = item;
        if (!this.cache.has(key)) {
          const deleted = this._deleteIfExpired(key, value);
          if (deleted === false) {
            yield [key, value.value];
          }
        }
      }
    }
    *entriesAscending() {
      for (const [key, value] of this._entriesAscending()) {
        yield [key, value.value];
      }
    }
    get size() {
      if (!this._size) {
        return this.oldCache.size;
      }
      let oldCacheSize = 0;
      for (const key of this.oldCache.keys()) {
        if (!this.cache.has(key)) {
          oldCacheSize++;
        }
      }
      return Math.min(this._size + oldCacheSize, this.maxSize);
    }
    entries() {
      return this.entriesAscending();
    }
    forEach(callbackFunction, thisArgument = this) {
      for (const [key, value] of this.entriesAscending()) {
        callbackFunction.call(thisArgument, value, key, this);
      }
    }
    get [Symbol.toStringTag]() {
      return JSON.stringify([...this.entriesAscending()]);
    }
  };

  // node_modules/camelcase-keys/index.js
  var has2 = (array, key) => array.some((element) => {
    if (typeof element === "string") {
      return element === key;
    }
    element.lastIndex = 0;
    return element.test(key);
  });
  var cache2 = new QuickLRU({ maxSize: 1e5 });
  var isObject2 = (value) => typeof value === "object" && value !== null && !(value instanceof RegExp) && !(value instanceof Error) && !(value instanceof Date);
  var transform = (input, options2 = {}) => {
    if (!isObject2(input)) {
      return input;
    }
    const {
      exclude,
      pascalCase = false,
      stopPaths,
      deep = false,
      preserveConsecutiveUppercase: preserveConsecutiveUppercase2 = false
    } = options2;
    const stopPathsSet = new Set(stopPaths);
    const makeMapper = (parentPath) => (key, value) => {
      if (deep && isObject2(value)) {
        const path = parentPath === void 0 ? key : `${parentPath}.${key}`;
        if (!stopPathsSet.has(path)) {
          value = mapObject(value, makeMapper(path));
        }
      }
      if (!(exclude && has2(exclude, key))) {
        const cacheKey = pascalCase ? `${key}_` : key;
        if (cache2.has(cacheKey)) {
          key = cache2.get(cacheKey);
        } else {
          const returnValue = camelCase(key, { pascalCase, locale: false, preserveConsecutiveUppercase: preserveConsecutiveUppercase2 });
          if (key.length < 100) {
            cache2.set(cacheKey, returnValue);
          }
          key = returnValue;
        }
      }
      return [key, value];
    };
    return mapObject(input, makeMapper(void 0));
  };
  function camelcaseKeys(input, options2) {
    if (Array.isArray(input)) {
      return Object.keys(input).map((key) => transform(input[key], options2));
    }
    return transform(input, options2);
  }

  // assets/scripts/reducers/sources.ts
  var adapters4 = {
    adaptOne: (source) => {
      if (source.incidents) {
        const {
          filters,
          pagination,
          records,
          stats
        } = source.incidents;
        const ids = records ? { ids: records.map((record) => record.id) } : void 0;
        return {
          ...camelcaseKeys(source, { deep: false }),
          incidents: {
            filters,
            pagination,
            stats,
            ...ids
          }
        };
      }
      return source;
    },
    getIds: (sources) => sources.map((source) => source.id),
    getIncidents: (source) => source.incidents?.records ?? []
  };
  var adapter4 = createEntityAdapter();
  var selectors4 = adapter4.getSelectors(getSources);
  var sourcesSlice = createSlice({
    name: "sources",
    initialState: adapter4.getInitialState({
      pageIds: [],
      pagination: null
    }),
    reducers: {
      set: (state, action) => {
        adapter4.upsertOne(state, action.payload);
      },
      setAll: (state, action) => {
        adapter4.upsertMany(state, action.payload);
      },
      setPageIds: (state, action) => {
        state.pageIds = action.payload;
      },
      setPagination: (state, action) => {
        state.pagination = { ...action.payload };
      }
    }
  });
  var { set: set5, setAll: setAll4, setPageIds: setPageIds4, setPagination: setPagination4 } = sourcesSlice.actions;
  var sources_default = sourcesSlice.reducer;

  // assets/scripts/reducers/stats.ts
  var setEntity = createAction("stats/setEntity");
  var setPerson = createAction("stats/setPerson");
  var setSources = createAction("stats/setSources");
  var actions = {
    setEntity,
    setPerson,
    setSources
  };
  var initialState4 = {
    entities: [],
    people: [],
    sources: []
  };
  var statsReducer = createReducer(initialState4, (builder) => {
    builder.addCase(setSources, (state, action) => {
      state.sources = action.payload;
    }).addCase(setEntity, (state, action) => {
      state.entities.push(action.payload);
    }).addCase(setPerson, (state, action) => {
      state.people.push(action.payload);
    });
  });
  var stats_default = statsReducer;

  // assets/scripts/reducers/ui.ts
  var setDescription = createAction("ui/setDescription");
  var setPageTitle = createAction("ui/setPageTitle");
  var clearErrors = createAction("ui/clearErrors");
  var clearMessages = createAction("ui/clearMessages");
  var clearWarnings = createAction("ui/clearWarnings");
  var setError = createAction("ui/setError");
  var setMessage = createAction("ui/setMessage");
  var setPositionY = createAction("ui/setPositionY");
  var setSection = createAction("ui/setSection");
  var setWarning = createAction("ui/setWarning");
  var actions2 = {
    clearErrors,
    clearMessages,
    clearWarnings,
    setDescription,
    setPageTitle,
    setError,
    setMessage,
    setPositionY,
    setSection,
    setWarning
  };
  var initialState5 = {
    description: null,
    pageTitle: null,
    errors: [],
    messages: [],
    positionY: 0,
    section: {},
    warnings: []
  };
  var customMessageExists = (alerts, customMessage) => customMessage && alerts.some((alert) => alert.customMessage === customMessage);
  var uiReducer = createReducer(initialState5, (builder) => {
    builder.addCase(clearErrors, (state) => {
      state.errors = initialState5.errors;
    }).addCase(setError, (state, action) => {
      if (customMessageExists(state.errors, action.payload.customMessage)) {
        return;
      }
      state.errors.push(action.payload);
    }).addCase(clearMessages, (state) => {
      state.messages = initialState5.messages;
    }).addCase(setMessage, (state, action) => {
      if (customMessageExists(state.messages, action.payload.customMessage)) {
        return;
      }
      state.messages.push(action.payload);
    }).addCase(setDescription, (state, action) => {
      state.description = action.payload;
    }).addCase(setPageTitle, (state, action) => {
      state.pageTitle = action.payload;
    }).addCase(setPositionY, (state, action) => {
      state.positionY = action.payload;
    }).addCase(clearWarnings, (state) => {
      state.warnings = initialState5.warnings;
    }).addCase(setSection, (state, action) => {
      state.section = action.payload;
    }).addCase(setWarning, (state, action) => {
      if (customMessageExists(state.warnings, action.payload.customMessage)) {
        return;
      }
      state.warnings.push(action.payload);
    });
  });
  var ui_default = uiReducer;

  // assets/scripts/lib/fetch-from-path.ts
  var getPeopleFromIncidents = (incidents) => incidents.flatMap(
    (incident) => Object.values(incident.attendees).filter((group) => "records" in group).map((group) => group.records).flat().map((attendee) => attendee?.person)
  );
  var getEntitiesFromPerson = (person) => person?.entities ? Object.values(person.entities).flat().map((entry) => entry.entity) : [];
  var getEntitiesFromSource = (source) => source?.entities ? source.entities.flat().map((entry) => entry.entity) : [];
  var handleResult = (result, isPrimary) => {
    const dispatch = store_default.dispatch;
    const { data: data2, meta } = result;
    if (data2) {
      if ("stats" in data2) {
        if ("sources" in data2.stats) {
          dispatch(actions.setSources(data2.stats.sources));
        }
        if ("entity" in data2.stats) {
          dispatch(actions.setEntity(data2.stats.entity));
        }
        if ("person" in data2.stats) {
          dispatch(actions.setPerson(data2.stats.person));
        }
      }
      if ("entity" in data2) {
        const entity = adapters.adaptOne(data2.entity.record);
        const incidents = adapters.getIncidents(data2.entity.record);
        const people = getPeopleFromIncidents(incidents);
        dispatch(set2(entity));
        dispatch(setAll2(incidents));
        dispatch(setAll3(people));
      }
      if ("entities" in data2) {
        dispatch(setAll(data2.entities.records));
        if ("pagination" in data2.entities) {
          const ids = adapters.getIds(data2.entities.records);
          dispatch(setPageIds(ids));
          dispatch(setPagination(data2.entities.pagination));
        }
        if ("leaderboard" in data2.entities) {
          dispatch(setLeaderboard(data2.entities.leaderboard));
        }
      }
      if ("incident" in data2) {
        const incident = adapters2.adaptOne(data2.incident.record);
        const people = getPeopleFromIncidents([incident]);
        dispatch(set3(incident));
        dispatch(setAll3(people));
      }
      if ("incidents" in data2) {
        if ("first" in data2.incidents) {
          dispatch(setFirst(data2.incidents.first));
        }
        if ("last" in data2.incidents) {
          dispatch(setLast(data2.incidents.last));
        }
        if ("total" in data2.incidents) {
          dispatch(setTotal(data2.incidents.total));
        }
        if ("records" in data2.incidents) {
          dispatch(setAll2(data2.incidents.records));
          if ("pagination" in data2.incidents) {
            const ids = adapters2.getIds(data2.incidents.records);
            dispatch(setPageIds2(ids));
            dispatch(setPagination2(data2.incidents.pagination));
          }
        }
      }
      if ("person" in data2) {
        const person = adapters3.adaptOne(data2.person.record);
        const incidents = adapters3.getIncidents(data2.person.record);
        const people = getPeopleFromIncidents(incidents);
        const entities = getEntitiesFromPerson(person);
        dispatch(set4(person));
        dispatch(setAll2(incidents));
        dispatch(setAll3(people));
        dispatch(setAll(entities));
      }
      if ("people" in data2) {
        dispatch(setAll3(data2.people.records));
        if ("pagination" in data2.people) {
          const ids = adapters3.getIds(data2.people.records);
          dispatch(setPageIds3(ids));
          dispatch(setPagination3(data2.people.pagination));
        }
        if ("leaderboard" in data2.people) {
          dispatch(setLeaderboard2(data2.people.leaderboard));
        }
      }
      if ("source" in data2) {
        const source = adapters4.adaptOne(data2.source.record);
        const incidents = adapters4.getIncidents(data2.source.record);
        const people = getPeopleFromIncidents(incidents);
        const entities = getEntitiesFromSource(data2.source.record);
        dispatch(set5(source));
        dispatch(setAll2(incidents));
        dispatch(setAll3(people));
        dispatch(setAll(entities));
      }
      if ("sources" in data2) {
        dispatch(setAll4(data2.sources.records));
        if ("pagination" in data2.sources) {
          const ids = adapters4.getIds(data2.sources.records);
          dispatch(setPageIds4(ids));
          dispatch(setPagination4(data2.sources.pagination));
        }
      }
    }
    if (meta) {
      if (isPrimary) {
        if ("description" in meta) {
          dispatch(actions2.setDescription(meta.description));
        }
        if ("pageTitle" in meta) {
          dispatch(actions2.setPageTitle(meta.pageTitle));
        }
        if ("section" in meta) {
          dispatch(actions2.setSection(meta.section));
        }
      }
      if ("errors" in meta) {
        meta.errors.forEach((error) => {
          dispatch(actions2.setError(error));
        });
      }
      if ("warnings" in meta) {
        meta.warnings.forEach((warning3) => {
          dispatch(actions2.setWarning(warning3));
        });
      }
    }
  };
  var handleError = (error) => {
    const dispatch = store_default.dispatch;
    dispatch(actions2.setError(getError(error)));
  };

  // assets/scripts/services/api.ts
  var url = new URL("/", window.location.toString());
  var baseUrl = url.origin;
  var getQueryPath = (location2) => {
    const url2 = new URL(location2.pathname, baseUrl);
    return url2.pathname + location2.search;
  };
  var getPrimaryRoute = () => ({
    query: getQueryPath,
    transformResponse: (result) => {
      handleResult(result, true);
    },
    transformErrorResponse: handleError
  });
  var getAncillaryRoute = (query) => ({
    query,
    transformResponse: (result) => {
      handleResult(result);
    },
    transformErrorResponse: handleError
  });
  var api = createApi2({
    reducerPath: "api",
    baseQuery: fetchBaseQuery({
      baseUrl,
      credentials: "same-origin",
      prepareHeaders: (headers) => {
        headers.set("Accept", "application/json");
        headers.set("Content-Type", "application/json");
        return headers;
      }
    }),
    endpoints: (builder) => ({
      getOverview: builder.query(getAncillaryRoute(
        () => "overview"
      )),
      getPrimary: builder.query(getPrimaryRoute()),
      getEntityAttendeesById: builder.query(getAncillaryRoute(
        (id) => `entities/${id}/attendees`
      )),
      getEntityStatsById: builder.query(getAncillaryRoute(
        (id) => `entities/${id}/stats`
      )),
      getIncidentById: builder.query(getAncillaryRoute(
        (id) => `incidents/${id}`
      )),
      getPersonAttendeesById: builder.query(getAncillaryRoute(
        (id) => `people/${id}/attendees`
      )),
      getPersonEntitiesById: builder.query(getAncillaryRoute(
        (id) => `people/${id}/entities`
      )),
      getPersonStatsById: builder.query(getAncillaryRoute(
        (id) => `people/${id}/stats`
      )),
      getSourceAttendeesById: builder.query(getAncillaryRoute(
        (id) => `sources/${id}/attendees`
      )),
      getSourceEntitiesById: builder.query(getAncillaryRoute(
        (id) => `sources/${id}/entities`
      )),
      getSourceById: builder.query(getAncillaryRoute(
        (id) => `sources/${id}`
      ))
    })
  });
  var api_default = api;

  // assets/scripts/lib/store.ts
  var store = configureStore({
    reducer: {
      api: api_default.reducer,
      entities: entities_default,
      incidents: incidents_default,
      people: people_default,
      sources: sources_default,
      stats: stats_default,
      ui: ui_default
    },
    middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(api_default.middleware),
    devTools: true
  });
  var store_default = store;

  // assets/scripts/components/alert-error.tsx
  var import_react14 = __toESM(require_react());

  // assets/scripts/components/alert.tsx
  var import_react13 = __toESM(require_react());

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t2 = arguments[e];
        for (var r2 in t2) ({}).hasOwnProperty.call(t2, r2) && (n[r2] = t2[r2]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose(r2, e) {
    if (null == r2) return {};
    var t2 = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (e.includes(n)) continue;
      t2[n] = r2[n];
    }
    return t2;
  }

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(t2, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {
      return t3.__proto__ = e2, t3;
    }, _setPrototypeOf(t2, e);
  }

  // node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
  function _inheritsLoose(t2, o2) {
    t2.prototype = Object.create(o2.prototype), t2.prototype.constructor = t2, _setPrototypeOf(t2, o2);
  }

  // node_modules/react-transition-group/esm/CSSTransition.js
  var import_prop_types3 = __toESM(require_prop_types());

  // node_modules/dom-helpers/esm/hasClass.js
  function hasClass(element, className) {
    if (element.classList) return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }

  // node_modules/dom-helpers/esm/addClass.js
  function addClass(element, className) {
    if (element.classList) element.classList.add(className);
    else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
    else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
  }

  // node_modules/dom-helpers/esm/removeClass.js
  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
  }
  function removeClass(element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else if (typeof element.className === "string") {
      element.className = replaceClassName(element.className, className);
    } else {
      element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
    }
  }

  // node_modules/react-transition-group/esm/CSSTransition.js
  var import_react9 = __toESM(require_react());

  // node_modules/react-transition-group/esm/Transition.js
  var import_prop_types2 = __toESM(require_prop_types());
  var import_react8 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());

  // node_modules/react-transition-group/esm/config.js
  var config_default = {
    disabled: false
  };

  // node_modules/react-transition-group/esm/utils/PropTypes.js
  var import_prop_types = __toESM(require_prop_types());
  var timeoutsShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
    enter: import_prop_types.default.number,
    exit: import_prop_types.default.number,
    appear: import_prop_types.default.number
  }).isRequired]) : null;
  var classNamesShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
    enter: import_prop_types.default.string,
    exit: import_prop_types.default.string,
    active: import_prop_types.default.string
  }), import_prop_types.default.shape({
    enter: import_prop_types.default.string,
    enterDone: import_prop_types.default.string,
    enterActive: import_prop_types.default.string,
    exit: import_prop_types.default.string,
    exitDone: import_prop_types.default.string,
    exitActive: import_prop_types.default.string
  })]) : null;

  // node_modules/react-transition-group/esm/TransitionGroupContext.js
  var import_react7 = __toESM(require_react());
  var TransitionGroupContext_default = import_react7.default.createContext(null);

  // node_modules/react-transition-group/esm/utils/reflow.js
  var forceReflow = function forceReflow2(node2) {
    return node2.scrollTop;
  };

  // node_modules/react-transition-group/esm/Transition.js
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(Transition2, _React$Component);
    function Transition2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout2 = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout2;
      if (timeout2 != null && typeof timeout2 !== "number") {
        exit = timeout2.exit;
        enter = timeout2.enter;
        appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var node2 = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
            if (node2) forceReflow(node2);
          }
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
      if (!mounting && !enter || config_default.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : import_react_dom.default.findDOMNode(this);
      if (!exit || config_default.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback2) {
      callback2 = this.setNextCallback(callback2);
      this.setState(nextState, callback2);
    };
    _proto.setNextCallback = function setNextCallback(callback2) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function(event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback2(event);
        }
      };
      this.nextCallback.cancel = function() {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
      this.setNextCallback(handler);
      var node2 = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
      if (!node2 || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout2 != null) {
        setTimeout(this.nextCallback, timeout2);
      }
    };
    _proto.render = function render2() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ import_react8.default.createElement(TransitionGroupContext_default.Provider, {
          value: null
        }, typeof children === "function" ? children(status, childProps) : import_react8.default.cloneElement(import_react8.default.Children.only(children), childProps))
      );
    };
    return Transition2;
  }(import_react8.default.Component);
  Transition.contextType = TransitionGroupContext_default;
  Transition.propTypes = true ? {
    /**
     * A React reference to DOM element that need to transition:
     * https://stackoverflow.com/a/51127130/4671932
     *
     *   - When `nodeRef` prop is used, `node` is not passed to callback functions
     *      (e.g. `onEnter`) because user already has direct access to the node.
     *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
     *     `nodeRef` need to be provided to `Transition` with changed `key` prop
     *     (see
     *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
     */
    nodeRef: import_prop_types2.default.shape({
      current: typeof Element === "undefined" ? import_prop_types2.default.any : function(propValue, key, componentName, location2, propFullName, secret) {
        var value = propValue[key];
        return import_prop_types2.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location2, propFullName, secret);
      }
    }),
    /**
     * A `function` child can be used instead of a React element. This function is
     * called with the current transition status (`'entering'`, `'entered'`,
     * `'exiting'`, `'exited'`), which can be used to apply context
     * specific props to a component.
     *
     * ```jsx
     * <Transition in={this.state.in} timeout={150}>
     *   {state => (
     *     <MyComponent className={`fade fade-${state}`} />
     *   )}
     * </Transition>
     * ```
     */
    children: import_prop_types2.default.oneOfType([import_prop_types2.default.func.isRequired, import_prop_types2.default.element.isRequired]).isRequired,
    /**
     * Show the component; triggers the enter or exit states
     */
    in: import_prop_types2.default.bool,
    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: import_prop_types2.default.bool,
    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: import_prop_types2.default.bool,
    /**
     * By default the child component does not perform the enter transition when
     * it first mounts, regardless of the value of `in`. If you want this
     * behavior, set both `appear` and `in` to `true`.
     *
     * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
     * > only adds an additional enter transition. However, in the
     * > `<CSSTransition>` component that first enter transition does result in
     * > additional `.appear-*` classes, that way you can choose to style it
     * > differently.
     */
    appear: import_prop_types2.default.bool,
    /**
     * Enable or disable enter transitions.
     */
    enter: import_prop_types2.default.bool,
    /**
     * Enable or disable exit transitions.
     */
    exit: import_prop_types2.default.bool,
    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided.
     *
     * You may specify a single timeout for all transitions:
     *
     * ```jsx
     * timeout={500}
     * ```
     *
     * or individually:
     *
     * ```jsx
     * timeout={{
     *  appear: 500,
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * - `appear` defaults to the value of `enter`
     * - `enter` defaults to `0`
     * - `exit` defaults to `0`
     *
     * @type {number | { enter?: number, exit?: number, appear?: number }}
     */
    timeout: function timeout(props) {
      var pt2 = timeoutsShape;
      if (!props.addEndListener) pt2 = pt2.isRequired;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return pt2.apply(void 0, [props].concat(args));
    },
    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. Timeouts are still used as a fallback if provided.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: import_prop_types2.default.func,
    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: import_prop_types2.default.func,
    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: import_prop_types2.default.func,
    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: import_prop_types2.default.func,
    /**
     * Callback fired before the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: import_prop_types2.default.func,
    /**
     * Callback fired after the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: import_prop_types2.default.func,
    /**
     * Callback fired after the "exited" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: import_prop_types2.default.func
  } : {};
  function noop2() {
  }
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop2,
    onEntering: noop2,
    onEntered: noop2,
    onExit: noop2,
    onExiting: noop2,
    onExited: noop2
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var Transition_default = Transition;

  // node_modules/react-transition-group/esm/CSSTransition.js
  var _addClass = function addClass2(node2, classes) {
    return node2 && classes && classes.split(" ").forEach(function(c) {
      return addClass(node2, c);
    });
  };
  var removeClass2 = function removeClass3(node2, classes) {
    return node2 && classes && classes.split(" ").forEach(function(c) {
      return removeClass(node2, c);
    });
  };
  var CSSTransition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(CSSTransition2, _React$Component);
    function CSSTransition2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };
      _this.onEnter = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
        _this.removeClasses(node2, "exit");
        _this.addClass(node2, appearing ? "appear" : "enter", "base");
        if (_this.props.onEnter) {
          _this.props.onEnter(maybeNode, maybeAppearing);
        }
      };
      _this.onEntering = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
        var type = appearing ? "appear" : "enter";
        _this.addClass(node2, type, "active");
        if (_this.props.onEntering) {
          _this.props.onEntering(maybeNode, maybeAppearing);
        }
      };
      _this.onEntered = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
        var type = appearing ? "appear" : "enter";
        _this.removeClasses(node2, type);
        _this.addClass(node2, type, "done");
        if (_this.props.onEntered) {
          _this.props.onEntered(maybeNode, maybeAppearing);
        }
      };
      _this.onExit = function(maybeNode) {
        var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument4[0];
        _this.removeClasses(node2, "appear");
        _this.removeClasses(node2, "enter");
        _this.addClass(node2, "exit", "base");
        if (_this.props.onExit) {
          _this.props.onExit(maybeNode);
        }
      };
      _this.onExiting = function(maybeNode) {
        var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument5[0];
        _this.addClass(node2, "exit", "active");
        if (_this.props.onExiting) {
          _this.props.onExiting(maybeNode);
        }
      };
      _this.onExited = function(maybeNode) {
        var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument6[0];
        _this.removeClasses(node2, "exit");
        _this.addClass(node2, "exit", "done");
        if (_this.props.onExited) {
          _this.props.onExited(maybeNode);
        }
      };
      _this.resolveArguments = function(maybeNode, maybeAppearing) {
        return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
      };
      _this.getClassNames = function(type) {
        var classNames = _this.props.classNames;
        var isStringClassNames = typeof classNames === "string";
        var prefix2 = isStringClassNames && classNames ? classNames + "-" : "";
        var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames[type];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
        return {
          baseClassName,
          activeClassName,
          doneClassName
        };
      };
      return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass3(node2, type, phase) {
      var className = this.getClassNames(type)[phase + "ClassName"];
      var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
      if (type === "appear" && phase === "done" && doneClassName) {
        className += " " + doneClassName;
      }
      if (phase === "active") {
        if (node2) forceReflow(node2);
      }
      if (className) {
        this.appliedClasses[type][phase] = className;
        _addClass(node2, className);
      }
    };
    _proto.removeClasses = function removeClasses(node2, type) {
      var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type] = {};
      if (baseClassName) {
        removeClass2(node2, baseClassName);
      }
      if (activeClassName) {
        removeClass2(node2, activeClassName);
      }
      if (doneClassName) {
        removeClass2(node2, doneClassName);
      }
    };
    _proto.render = function render2() {
      var _this$props = this.props, _ = _this$props.classNames, props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
      return /* @__PURE__ */ import_react9.default.createElement(Transition_default, _extends({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };
    return CSSTransition2;
  }(import_react9.default.Component);
  CSSTransition.defaultProps = {
    classNames: ""
  };
  CSSTransition.propTypes = true ? _extends({}, Transition_default.propTypes, {
    /**
     * The animation classNames applied to the component as it appears, enters,
     * exits or has finished the transition. A single name can be provided, which
     * will be suffixed for each stage, e.g. `classNames="fade"` applies:
     *
     * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
     * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
     * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
     *
     * A few details to note about how these classes are applied:
     *
     * 1. They are _joined_ with the ones that are already defined on the child
     *    component, so if you want to add some base styles, you can use
     *    `className` without worrying that it will be overridden.
     *
     * 2. If the transition component mounts with `in={false}`, no classes are
     *    applied yet. You might be expecting `*-exit-done`, but if you think
     *    about it, a component cannot finish exiting if it hasn't entered yet.
     *
     * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
     *    allows you to define different behavior for when appearing is done and
     *    when regular entering is done, using selectors like
     *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
     *    an epic entrance animation when element first appears in the DOM using
     *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
     *    simply use `fade-enter-done` for defining both cases.
     *
     * Each individual classNames can also be specified independently like:
     *
     * ```js
     * classNames={{
     *  appear: 'my-appear',
     *  appearActive: 'my-active-appear',
     *  appearDone: 'my-done-appear',
     *  enter: 'my-enter',
     *  enterActive: 'my-active-enter',
     *  enterDone: 'my-done-enter',
     *  exit: 'my-exit',
     *  exitActive: 'my-active-exit',
     *  exitDone: 'my-done-exit',
     * }}
     * ```
     *
     * If you want to set these classes using CSS Modules:
     *
     * ```js
     * import styles from './styles.css';
     * ```
     *
     * you might want to use camelCase in your CSS file, that way could simply
     * spread them instead of listing them one by one:
     *
     * ```js
     * classNames={{ ...styles }}
     * ```
     *
     * @type {string | {
     *  appear?: string,
     *  appearActive?: string,
     *  appearDone?: string,
     *  enter?: string,
     *  enterActive?: string,
     *  enterDone?: string,
     *  exit?: string,
     *  exitActive?: string,
     *  exitDone?: string,
     * }}
     */
    classNames: classNamesShape,
    /**
     * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
     * applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEnter: import_prop_types3.default.func,
    /**
     * A `<Transition>` callback fired immediately after the 'enter-active' or
     * 'appear-active' class is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: import_prop_types3.default.func,
    /**
     * A `<Transition>` callback fired immediately after the 'enter' or
     * 'appear' classes are **removed** and the `done` class is added to the DOM node.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntered: import_prop_types3.default.func,
    /**
     * A `<Transition>` callback fired immediately after the 'exit' class is
     * applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement)
     */
    onExit: import_prop_types3.default.func,
    /**
     * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement)
     */
    onExiting: import_prop_types3.default.func,
    /**
     * A `<Transition>` callback fired immediately after the 'exit' classes
     * are **removed** and the `exit-done` class is added to the DOM node.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement)
     */
    onExited: import_prop_types3.default.func
  }) : {};
  var CSSTransition_default = CSSTransition;

  // assets/scripts/components/alert-portal.tsx
  var import_react11 = __toESM(require_react());
  var import_react_dom2 = __toESM(require_react_dom());

  // assets/scripts/hooks/use-fixed-body-when-has-class.ts
  var import_react10 = __toESM(require_react());
  var useFixedBodyWhenHasClass = (className) => {
    const { positionY } = useSelector(getUI);
    (0, import_react10.useEffect)(() => {
      document.body.classList.add(className);
      document.body.style.position = "fixed";
      if (positionY !== 0) {
        document.body.style.top = positionY + "px";
      }
      return () => {
        document.body.classList.remove(className);
        document.body.style.position = "";
        document.body.style.top = "";
        window.scrollTo(0, positionY * -1);
      };
    }, [positionY]);
  };
  var use_fixed_body_when_has_class_default = useFixedBodyWhenHasClass;

  // assets/scripts/components/alert-portal.tsx
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var hasAlertClass = "has-alert";
  var alertRootId = "alert-root";
  var alertPortalId = "alert-root-portal";
  var Escape = "Escape";
  var AlertPortal = (0, import_react11.forwardRef)(({
    children,
    deactivate,
    isActive
  }, ref) => {
    const elementRef = ref;
    const target = document.getElementById(alertPortalId);
    const handleClick = () => {
      deactivate();
    };
    const handleKeyUp = (e) => {
      if (e.key === Escape && isActive) {
        deactivate();
      }
    };
    (0, import_react11.useEffect)(() => {
      if (isActive) {
        elementRef.current?.focus();
      }
      return () => {
        elementRef.current?.blur();
      };
    }, [elementRef, isActive]);
    use_fixed_body_when_has_class_default(hasAlertClass);
    return (0, import_react_dom2.createPortal)(
      /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(
        "div",
        {
          className: "alert",
          onKeyUp: handleKeyUp,
          ref: elementRef,
          tabIndex: 0,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "alert-overlay" }),
            /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { className: "alert-content", onClick: handleClick, children })
          ]
        }
      ),
      target
    );
  });
  var alert_portal_default = AlertPortal;

  // node_modules/@emotion/sheet/dist/emotion-sheet.esm.js
  var isDevelopment = false;
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
    return void 0;
  }
  function createStyleElement(options2) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options2.key);
    if (options2.nonce !== void 0) {
      tag.setAttribute("nonce", options2.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = /* @__PURE__ */ function() {
    function StyleSheet2(options2) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options2.speedy === void 0 ? !isDevelopment : options2.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options2.nonce;
      this.key = options2.key;
      this.container = options2.container;
      this.prepend = options2.prepend;
      this.insertionPoint = options2.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate2(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert2(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet2 = sheetForTag(tag);
        try {
          sheet2.insertRule(rule, sheet2.cssRules.length);
        } catch (e) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush2() {
      this.tags.forEach(function(tag) {
        var _tag$parentNode;
        return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  }();

  // node_modules/stylis/src/Enum.js
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";

  // node_modules/stylis/src/Utility.js
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign2 = Object.assign;
  function hash(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace2(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin2, end2) {
    return value.slice(begin2, end2);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback2) {
    return array.map(callback2).join("");
  }

  // node_modules/stylis/src/Tokenizer.js
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root, parent, type, props, children, length2) {
    return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root, props) {
    return assign2(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek2() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin2, end2) {
    return substr(characters, begin2, end2);
  }
  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek2())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek2() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        // ] ) " '
        case type:
          return position;
        // " '
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        // (
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        // \
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek2() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index) {
    while (!token(peek2()))
      next();
    return slice(index, position);
  }

  // node_modules/stylis/src/Parser.js
  function compile(value) {
    return dealloc(parse2("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse2(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        // (
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace2(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        // \
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek2()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        // {
        case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset:
              if (ampersand == -1) characters2 = replace2(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace2(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            // @ ;
            case 59:
              characters2 += ";";
            // { rule/at-rule
            default:
              append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset === 0)
                  parse2(characters2, root, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse2(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        // :
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            // &
            case 38:
              ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
              break;
            // ,
            case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            // @
            case 64:
              if (peek2() === 45)
                characters2 += delimit(next());
              atrule = peek2(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            // -
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length2) {
    var post = offset - 1;
    var rule = offset === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k = 0; i < index; ++i)
      for (var x2 = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x2 < size; ++x2)
        if (z = trim(j > 0 ? rule[x2] + " " + y : replace2(y, /&\f/g, rule[x2])))
          props[k++] = z;
    return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root, parent) {
    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root, parent, length2) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }

  // node_modules/stylis/src/Serializer.js
  function serialize2(children, callback2) {
    var output = "";
    var length2 = sizeof(children);
    for (var i = 0; i < length2; i++)
      output += callback2(children[i], i, children, callback2) || "";
    return output;
  }
  function stringify(element, index, children, callback2) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize2(element.children, callback2) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize2(element.children, callback2)) ? element.return = element.value + "{" + children + "}" : "";
  }

  // node_modules/stylis/src/Middleware.js
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback2) {
      var output = "";
      for (var i = 0; i < length2; i++)
        output += collection[i](element, index, children, callback2) || "";
      return output;
    };
  }
  function rulesheet(callback2) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback2(element);
      }
    };
  }

  // node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
  function memoize(fn) {
    var cache4 = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache4[arg] === void 0) cache4[arg] = fn(arg);
      return cache4[arg];
    };
  }

  // node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
  var identifierWithPointTracking = function identifierWithPointTracking2(begin2, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek2();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin2, position);
  };
  var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek2() === 12) {
            points[index] = 1;
          }
          parsed[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed[++index] = peek2() === 58 ? "&\f" : "";
            points[index] = parsed[index].length;
            break;
          }
        // fallthrough
        default:
          parsed[index] += from(character2);
      }
    } while (character2 = next());
    return parsed;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = /* @__PURE__ */ new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) {
      return;
    }
    var value = element.value;
    var parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i = 0, k = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix(value, length2) {
    switch (hash(value, length2)) {
      // color-adjust
      case 5103:
        return WEBKIT + "print-" + value + value;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      // appearance, user-select, transform, hyphens, text-size-adjust
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      // flex, flex-direction
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      // order
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      // align-items
      case 5187:
        return WEBKIT + value + replace2(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      // align-self
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace2(value, /flex-|-self/, "") + value;
      // align-content
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace2(value, /align-content|flex-|-self/, "") + value;
      // flex-shrink
      case 5548:
        return WEBKIT + value + MS + replace2(value, "shrink", "negative") + value;
      // flex-basis
      case 5292:
        return WEBKIT + value + MS + replace2(value, "basis", "preferred-size") + value;
      // flex-grow
      case 6060:
        return WEBKIT + "box-" + replace2(value, "-grow", "") + WEBKIT + value + MS + replace2(value, "grow", "positive") + value;
      // transition
      case 4554:
        return WEBKIT + replace2(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      // cursor
      case 6187:
        return replace2(replace2(replace2(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      // background, background-image
      case 5495:
      case 3959:
        return replace2(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      // justify-content
      case 4968:
        return replace2(replace2(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace2(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (charat(value, length2 + 4) !== 45) break;
          // (f)ill-available, (f)it-content
          case 102:
            return replace2(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          // (s)tretch
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace2(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
      // position: sticky
      case 4949:
        if (charat(value, length2 + 1) !== 115) break;
      // display: (flex|inline-flex)
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          // stic(k)y
          case 107:
            return replace2(value, ":", ":" + WEBKIT) + value;
          // (inline-)?fl(e)x
          case 101:
            return replace2(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      // writing-mode
      case 5936:
        switch (charat(value, length2 + 11)) {
          // vertical-l(r)
          case 114:
            return WEBKIT + value + MS + replace2(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          // vertical-r(l)
          case 108:
            return WEBKIT + value + MS + replace2(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          // horizontal(-)tb
          case 45:
            return WEBKIT + value + MS + replace2(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index, children, callback2) {
    if (element.length > -1) {
      if (!element["return"]) switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize2([copy(element, {
            value: replace2(element.value, "@", "@" + WEBKIT)
          })], callback2);
        case RULESET:
          if (element.length) return combine(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              // :read-(only|write)
              case ":read-only":
              case ":read-write":
                return serialize2([copy(element, {
                  props: [replace2(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], callback2);
              // :placeholder
              case "::placeholder":
                return serialize2([copy(element, {
                  props: [replace2(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy(element, {
                  props: [replace2(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy(element, {
                  props: [replace2(value, /:(plac\w+)/, MS + "input-$1")]
                })], callback2);
            }
            return "";
          });
      }
    }
  };
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options2) {
    var key = options2.key;
    if (key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    {
      container = options2.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles2) {
        return serialize2(compile(styles2), serializer);
      };
      _insert = function insert2(selector, serialized, sheet2, shouldCache) {
        currentSheet = sheet2;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache4.inserted[serialized.name] = true;
        }
      };
    }
    var cache4 = {
      key,
      sheet: new StyleSheet({
        key,
        container,
        nonce: options2.nonce,
        speedy: options2.speedy,
        prepend: options2.prepend,
        insertionPoint: options2.insertionPoint
      }),
      nonce: options2.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache4.sheet.hydrate(nodesToHydrate);
    return cache4;
  };

  // node_modules/@emotion/hash/dist/emotion-hash.esm.js
  function murmur2(str) {
    var h = 0;
    var k, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }

  // node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };

  // node_modules/@emotion/serialize/dist/emotion-serialize.esm.js
  var isDevelopment2 = false;
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes2 = interpolation;
        if (keyframes2.anim === 1) {
          cursor = {
            name: keyframes2.name,
            styles: keyframes2.styles,
            next: cursor
          };
          return keyframes2.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles2 = serializedStyles.styles + ";";
          return styles2;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached = registered[asString];
    return cached !== void 0 ? cached : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
  var cursor;
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles2 = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles2 += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;
      styles2 += asTemplateStringsArr[0];
    }
    for (var i = 1; i < args.length; i++) {
      styles2 += handleInterpolation(mergedProps, registered, args[i]);
      if (stringMode) {
        var templateStringsArr = strings;
        styles2 += templateStringsArr[i];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles2)) !== null) {
      identifierName += "-" + match2[1];
    }
    var name = murmur2(styles2) + identifierName;
    return {
      name,
      styles: styles2,
      next: cursor
    };
  }

  // node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
  var isBrowser2 = true;
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache4, serialized, isStringTag) {
    var className = cache4.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser2 === false) && cache4.registered[className] === void 0
    ) {
      cache4.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache4, serialized, isStringTag) {
    registerStyles(cache4, serialized, isStringTag);
    var className = cache4.key + "-" + serialized.name;
    if (cache4.inserted[serialized.name] === void 0) {
      var current2 = serialized;
      do {
        cache4.insert(serialized === current2 ? "." + className : "", current2, cache4.sheet, true);
        current2 = current2.next;
      } while (current2 !== void 0);
    }
  };

  // node_modules/@emotion/css/create-instance/dist/emotion-css-create-instance.esm.js
  function insertWithoutScoping(cache4, serialized) {
    if (cache4.inserted[serialized.name] === void 0) {
      return cache4.insert("", serialized, cache4.sheet, true);
    }
  }
  function merge(registered, css3, className) {
    var registeredStyles = [];
    var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css3(registeredStyles);
  }
  var createEmotion = function createEmotion2(options2) {
    var cache4 = createCache(options2);
    cache4.sheet.speedy = function(value) {
      this.isSpeedy = value;
    };
    cache4.compat = true;
    var css3 = function css4() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var serialized = serializeStyles(args, cache4.registered, void 0);
      insertStyles(cache4, serialized, false);
      return cache4.key + "-" + serialized.name;
    };
    var keyframes2 = function keyframes3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      var serialized = serializeStyles(args, cache4.registered);
      var animation = "animation-" + serialized.name;
      insertWithoutScoping(cache4, {
        name: serialized.name,
        styles: "@keyframes " + animation + "{" + serialized.styles + "}"
      });
      return animation;
    };
    var injectGlobal2 = function injectGlobal3() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      var serialized = serializeStyles(args, cache4.registered);
      insertWithoutScoping(cache4, serialized);
    };
    var cx2 = function cx3() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return merge(cache4.registered, css3, classnames(args));
    };
    return {
      css: css3,
      cx: cx2,
      injectGlobal: injectGlobal2,
      keyframes: keyframes2,
      hydrate: function hydrate2(ids) {
        ids.forEach(function(key) {
          cache4.inserted[key] = true;
        });
      },
      flush: function flush2() {
        cache4.registered = {};
        cache4.inserted = {};
        cache4.sheet.flush();
      },
      sheet: cache4.sheet,
      cache: cache4,
      getRegisteredStyles: getRegisteredStyles.bind(null, cache4.registered),
      merge: merge.bind(null, cache4.registered, css3)
    };
  };
  var classnames = function classnames2(args) {
    var cls = "";
    for (var i = 0; i < args.length; i++) {
      var arg = args[i];
      if (arg == null) continue;
      var toAdd = void 0;
      switch (typeof arg) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(arg)) {
            toAdd = classnames2(arg);
          } else {
            toAdd = "";
            for (var k in arg) {
              if (arg[k] && k) {
                toAdd && (toAdd += " ");
                toAdd += k;
              }
            }
          }
          break;
        }
        default: {
          toAdd = arg;
        }
      }
      if (toAdd) {
        cls && (cls += " ");
        cls += toAdd;
      }
    }
    return cls;
  };

  // node_modules/@emotion/css/dist/emotion-css.esm.js
  var _createEmotion = createEmotion({
    key: "css"
  });
  var flush = _createEmotion.flush;
  var hydrate = _createEmotion.hydrate;
  var cx = _createEmotion.cx;
  var merge2 = _createEmotion.merge;
  var getRegisteredStyles2 = _createEmotion.getRegisteredStyles;
  var injectGlobal = _createEmotion.injectGlobal;
  var keyframes = _createEmotion.keyframes;
  var css = _createEmotion.css;
  var sheet = _createEmotion.sheet;
  var cache3 = _createEmotion.cache;

  // node_modules/@fortawesome/fontawesome-svg-core/index.mjs
  function _defineProperty(e, r2, t2) {
    return (r2 = _toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
      value: t2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r2] = t2, e;
  }
  function ownKeys(e, r2) {
    var t2 = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread2(e) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
        _defineProperty(e, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e;
  }
  function _toPrimitive(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e = t2[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t2, r2 || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function _toPropertyKey(t2) {
    var i = _toPrimitive(t2, "string");
    return "symbol" == typeof i ? i : i + "";
  }
  var noop3 = () => {
  };
  var _WINDOW = {};
  var _DOCUMENT = {};
  var _MUTATION_OBSERVER = null;
  var _PERFORMANCE = {
    mark: noop3,
    measure: noop3
  };
  try {
    if (typeof window !== "undefined") _WINDOW = window;
    if (typeof document !== "undefined") _DOCUMENT = document;
    if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
    if (typeof performance !== "undefined") _PERFORMANCE = performance;
  } catch (e) {
  }
  var {
    userAgent = ""
  } = _WINDOW.navigator || {};
  var WINDOW = _WINDOW;
  var DOCUMENT = _DOCUMENT;
  var MUTATION_OBSERVER = _MUTATION_OBSERVER;
  var PERFORMANCE = _PERFORMANCE;
  var IS_BROWSER = !!WINDOW.document;
  var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
  var IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
  var p = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/;
  var g = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i;
  var S = {
    classic: {
      fa: "solid",
      fas: "solid",
      "fa-solid": "solid",
      far: "regular",
      "fa-regular": "regular",
      fal: "light",
      "fa-light": "light",
      fat: "thin",
      "fa-thin": "thin",
      fab: "brands",
      "fa-brands": "brands"
    },
    duotone: {
      fa: "solid",
      fad: "solid",
      "fa-solid": "solid",
      "fa-duotone": "solid",
      fadr: "regular",
      "fa-regular": "regular",
      fadl: "light",
      "fa-light": "light",
      fadt: "thin",
      "fa-thin": "thin"
    },
    sharp: {
      fa: "solid",
      fass: "solid",
      "fa-solid": "solid",
      fasr: "regular",
      "fa-regular": "regular",
      fasl: "light",
      "fa-light": "light",
      fast: "thin",
      "fa-thin": "thin"
    },
    "sharp-duotone": {
      fa: "solid",
      fasds: "solid",
      "fa-solid": "solid",
      fasdr: "regular",
      "fa-regular": "regular",
      fasdl: "light",
      "fa-light": "light",
      fasdt: "thin",
      "fa-thin": "thin"
    }
  };
  var A = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  };
  var P = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
  var s = "classic";
  var t = "duotone";
  var r = "sharp";
  var o = "sharp-duotone";
  var L = [s, t, r, o];
  var G = {
    classic: {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    duotone: {
      900: "fad",
      400: "fadr",
      300: "fadl",
      100: "fadt"
    },
    sharp: {
      900: "fass",
      400: "fasr",
      300: "fasl",
      100: "fast"
    },
    "sharp-duotone": {
      900: "fasds",
      400: "fasdr",
      300: "fasdl",
      100: "fasdt"
    }
  };
  var lt = {
    "Font Awesome 6 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 6 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    "Font Awesome 6 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 6 Duotone": {
      900: "fad",
      400: "fadr",
      normal: "fadr",
      300: "fadl",
      100: "fadt"
    },
    "Font Awesome 6 Sharp": {
      900: "fass",
      400: "fasr",
      normal: "fasr",
      300: "fasl",
      100: "fast"
    },
    "Font Awesome 6 Sharp Duotone": {
      900: "fasds",
      400: "fasdr",
      normal: "fasdr",
      300: "fasdl",
      100: "fasdt"
    }
  };
  var pt = /* @__PURE__ */ new Map([["classic", {
    defaultShortPrefixId: "fas",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin", "brands"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp", {
    defaultShortPrefixId: "fass",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["duotone", {
    defaultShortPrefixId: "fad",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp-duotone", {
    defaultShortPrefixId: "fasds",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }]]);
  var xt = {
    classic: {
      solid: "fas",
      regular: "far",
      light: "fal",
      thin: "fat",
      brands: "fab"
    },
    duotone: {
      solid: "fad",
      regular: "fadr",
      light: "fadl",
      thin: "fadt"
    },
    sharp: {
      solid: "fass",
      regular: "fasr",
      light: "fasl",
      thin: "fast"
    },
    "sharp-duotone": {
      solid: "fasds",
      regular: "fasdr",
      light: "fasdl",
      thin: "fasdt"
    }
  };
  var Ft = ["fak", "fa-kit", "fakd", "fa-kit-duotone"];
  var St = {
    kit: {
      fak: "kit",
      "fa-kit": "kit"
    },
    "kit-duotone": {
      fakd: "kit-duotone",
      "fa-kit-duotone": "kit-duotone"
    }
  };
  var At = ["kit"];
  var Ct = {
    kit: {
      "fa-kit": "fak"
    },
    "kit-duotone": {
      "fa-kit-duotone": "fakd"
    }
  };
  var Lt = ["fak", "fakd"];
  var Wt = {
    kit: {
      fak: "fa-kit"
    },
    "kit-duotone": {
      fakd: "fa-kit-duotone"
    }
  };
  var Et = {
    kit: {
      kit: "fak"
    },
    "kit-duotone": {
      "kit-duotone": "fakd"
    }
  };
  var t$1 = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  };
  var r$1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"];
  var bt$1 = ["fak", "fa-kit", "fakd", "fa-kit-duotone"];
  var Yt = {
    "Font Awesome Kit": {
      400: "fak",
      normal: "fak"
    },
    "Font Awesome Kit Duotone": {
      400: "fakd",
      normal: "fakd"
    }
  };
  var ua = {
    classic: {
      "fa-brands": "fab",
      "fa-duotone": "fad",
      "fa-light": "fal",
      "fa-regular": "far",
      "fa-solid": "fas",
      "fa-thin": "fat"
    },
    duotone: {
      "fa-regular": "fadr",
      "fa-light": "fadl",
      "fa-thin": "fadt"
    },
    sharp: {
      "fa-solid": "fass",
      "fa-regular": "fasr",
      "fa-light": "fasl",
      "fa-thin": "fast"
    },
    "sharp-duotone": {
      "fa-solid": "fasds",
      "fa-regular": "fasdr",
      "fa-light": "fasdl",
      "fa-thin": "fasdt"
    }
  };
  var I$1 = {
    classic: ["fas", "far", "fal", "fat", "fad"],
    duotone: ["fadr", "fadl", "fadt"],
    sharp: ["fass", "fasr", "fasl", "fast"],
    "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
  };
  var ga = {
    classic: {
      fab: "fa-brands",
      fad: "fa-duotone",
      fal: "fa-light",
      far: "fa-regular",
      fas: "fa-solid",
      fat: "fa-thin"
    },
    duotone: {
      fadr: "fa-regular",
      fadl: "fa-light",
      fadt: "fa-thin"
    },
    sharp: {
      fass: "fa-solid",
      fasr: "fa-regular",
      fasl: "fa-light",
      fast: "fa-thin"
    },
    "sharp-duotone": {
      fasds: "fa-solid",
      fasdr: "fa-regular",
      fasdl: "fa-light",
      fasdt: "fa-thin"
    }
  };
  var x = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"];
  var Ia = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...r$1, ...x];
  var m$1 = ["solid", "regular", "light", "thin", "duotone", "brands"];
  var c$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  var F$1 = c$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);
  var ma = [...Object.keys(I$1), ...m$1, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", t$1.GROUP, t$1.SWAP_OPACITY, t$1.PRIMARY, t$1.SECONDARY].concat(c$1.map((a) => "".concat(a, "x"))).concat(F$1.map((a) => "w-".concat(a)));
  var wa = {
    "Font Awesome 5 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 5 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal"
    },
    "Font Awesome 5 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 5 Duotone": {
      900: "fad"
    }
  };
  var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
  var UNITS_IN_GRID = 16;
  var DEFAULT_CSS_PREFIX = "fa";
  var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
  var DATA_FA_I2SVG = "data-fa-i2svg";
  var DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
  var DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
  var DATA_PREFIX = "data-prefix";
  var DATA_ICON = "data-icon";
  var HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
  var MUTATION_APPROACH_ASYNC = "async";
  var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
  var PRODUCTION = (() => {
    try {
      return false;
    } catch (e$$1) {
      return false;
    }
  })();
  function familyProxy(obj) {
    return new Proxy(obj, {
      get(target, prop) {
        return prop in target ? target[prop] : target[s];
      }
    });
  }
  var _PREFIX_TO_STYLE = _objectSpread2({}, S);
  _PREFIX_TO_STYLE[s] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    "fa-duotone": "duotone"
  }), S[s]), St["kit"]), St["kit-duotone"]);
  var PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
  var _STYLE_TO_PREFIX = _objectSpread2({}, xt);
  _STYLE_TO_PREFIX[s] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    duotone: "fad"
  }), _STYLE_TO_PREFIX[s]), Et["kit"]), Et["kit-duotone"]);
  var STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
  var _PREFIX_TO_LONG_STYLE = _objectSpread2({}, ga);
  _PREFIX_TO_LONG_STYLE[s] = _objectSpread2(_objectSpread2({}, _PREFIX_TO_LONG_STYLE[s]), Wt["kit"]);
  var PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
  var _LONG_STYLE_TO_PREFIX = _objectSpread2({}, ua);
  _LONG_STYLE_TO_PREFIX[s] = _objectSpread2(_objectSpread2({}, _LONG_STYLE_TO_PREFIX[s]), Ct["kit"]);
  var LONG_STYLE_TO_PREFIX = familyProxy(_LONG_STYLE_TO_PREFIX);
  var ICON_SELECTION_SYNTAX_PATTERN = p;
  var LAYERS_TEXT_CLASSNAME = "fa-layers-text";
  var FONT_FAMILY_PATTERN = g;
  var _FONT_WEIGHT_TO_PREFIX = _objectSpread2({}, G);
  var FONT_WEIGHT_TO_PREFIX = familyProxy(_FONT_WEIGHT_TO_PREFIX);
  var ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
  var DUOTONE_CLASSES = A;
  var RESERVED_CLASSES = [...At, ...ma];
  var initial = WINDOW.FontAwesomeConfig || {};
  function getAttrConfig(attr) {
    var element = DOCUMENT.querySelector("script[" + attr + "]");
    if (element) {
      return element.getAttribute(attr);
    }
  }
  function coerce(val) {
    if (val === "") return true;
    if (val === "false") return false;
    if (val === "true") return true;
    return val;
  }
  if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
    const attrs = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
    attrs.forEach((_ref) => {
      let [attr, key] = _ref;
      const val = coerce(getAttrConfig(attr));
      if (val !== void 0 && val !== null) {
        initial[key] = val;
      }
    });
  }
  var _default = {
    styleDefault: "solid",
    familyDefault: s,
    cssPrefix: DEFAULT_CSS_PREFIX,
    replacementClass: DEFAULT_REPLACEMENT_CLASS,
    autoReplaceSvg: true,
    autoAddCss: true,
    autoA11y: true,
    searchPseudoElements: false,
    observeMutations: true,
    mutateApproach: "async",
    keepOriginalSource: true,
    measurePerformance: false,
    showMissingIcons: true
  };
  if (initial.familyPrefix) {
    initial.cssPrefix = initial.familyPrefix;
  }
  var _config = _objectSpread2(_objectSpread2({}, _default), initial);
  if (!_config.autoReplaceSvg) _config.observeMutations = false;
  var config = {};
  Object.keys(_default).forEach((key) => {
    Object.defineProperty(config, key, {
      enumerable: true,
      set: function(val) {
        _config[key] = val;
        _onChangeCb.forEach((cb) => cb(config));
      },
      get: function() {
        return _config[key];
      }
    });
  });
  Object.defineProperty(config, "familyPrefix", {
    enumerable: true,
    set: function(val) {
      _config.cssPrefix = val;
      _onChangeCb.forEach((cb) => cb(config));
    },
    get: function() {
      return _config.cssPrefix;
    }
  });
  WINDOW.FontAwesomeConfig = config;
  var _onChangeCb = [];
  function onChange(cb) {
    _onChangeCb.push(cb);
    return () => {
      _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
    };
  }
  var d$2 = UNITS_IN_GRID;
  var meaninglessTransform = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: false,
    flipY: false
  };
  function insertCss(css3) {
    if (!css3 || !IS_DOM) {
      return;
    }
    const style = DOCUMENT.createElement("style");
    style.setAttribute("type", "text/css");
    style.innerHTML = css3;
    const headChildren = DOCUMENT.head.childNodes;
    let beforeChild = null;
    for (let i = headChildren.length - 1; i > -1; i--) {
      const child = headChildren[i];
      const tagName = (child.tagName || "").toUpperCase();
      if (["STYLE", "LINK"].indexOf(tagName) > -1) {
        beforeChild = child;
      }
    }
    DOCUMENT.head.insertBefore(style, beforeChild);
    return css3;
  }
  var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  function nextUniqueId() {
    let size = 12;
    let id = "";
    while (size-- > 0) {
      id += idPool[Math.random() * 62 | 0];
    }
    return id;
  }
  function toArray(obj) {
    const array = [];
    for (let i = (obj || []).length >>> 0; i--; ) {
      array[i] = obj[i];
    }
    return array;
  }
  function classArray(node2) {
    if (node2.classList) {
      return toArray(node2.classList);
    } else {
      return (node2.getAttribute("class") || "").split(" ").filter((i) => i);
    }
  }
  function htmlEscape(str) {
    return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function joinAttributes(attributes) {
    return Object.keys(attributes || {}).reduce((acc, attributeName) => {
      return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
    }, "").trim();
  }
  function joinStyles(styles2) {
    return Object.keys(styles2 || {}).reduce((acc, styleName) => {
      return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
    }, "");
  }
  function transformIsMeaningful(transform2) {
    return transform2.size !== meaninglessTransform.size || transform2.x !== meaninglessTransform.x || transform2.y !== meaninglessTransform.y || transform2.rotate !== meaninglessTransform.rotate || transform2.flipX || transform2.flipY;
  }
  function transformForSvg(_ref) {
    let {
      transform: transform2,
      containerWidth,
      iconWidth
    } = _ref;
    const outer = {
      transform: "translate(".concat(containerWidth / 2, " 256)")
    };
    const innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
    const innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
    const innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
    const inner = {
      transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
    };
    const path = {
      transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
    };
    return {
      outer,
      inner,
      path
    };
  }
  function transformForCss(_ref2) {
    let {
      transform: transform2,
      width = UNITS_IN_GRID,
      height = UNITS_IN_GRID,
      startCentered = false
    } = _ref2;
    let val = "";
    if (startCentered && IS_IE) {
      val += "translate(".concat(transform2.x / d$2 - width / 2, "em, ").concat(transform2.y / d$2 - height / 2, "em) ");
    } else if (startCentered) {
      val += "translate(calc(-50% + ".concat(transform2.x / d$2, "em), calc(-50% + ").concat(transform2.y / d$2, "em)) ");
    } else {
      val += "translate(".concat(transform2.x / d$2, "em, ").concat(transform2.y / d$2, "em) ");
    }
    val += "scale(".concat(transform2.size / d$2 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / d$2 * (transform2.flipY ? -1 : 1), ") ");
    val += "rotate(".concat(transform2.rotate, "deg) ");
    return val;
  }
  var baseStyles = ':root, :host {\n  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";\n  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";\n  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";\n  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";\n  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";\n  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";\n  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";\n  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";\n  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";\n  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";\n  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";\n}\n\nsvg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {\n  overflow: visible;\n  box-sizing: content-box;\n}\n\n.svg-inline--fa {\n  display: var(--fa-display, inline-block);\n  height: 1em;\n  overflow: visible;\n  vertical-align: -0.125em;\n}\n.svg-inline--fa.fa-2xs {\n  vertical-align: 0.1em;\n}\n.svg-inline--fa.fa-xs {\n  vertical-align: 0em;\n}\n.svg-inline--fa.fa-sm {\n  vertical-align: -0.0714285705em;\n}\n.svg-inline--fa.fa-lg {\n  vertical-align: -0.2em;\n}\n.svg-inline--fa.fa-xl {\n  vertical-align: -0.25em;\n}\n.svg-inline--fa.fa-2xl {\n  vertical-align: -0.3125em;\n}\n.svg-inline--fa.fa-pull-left {\n  margin-right: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-pull-right {\n  margin-left: var(--fa-pull-margin, 0.3em);\n  width: auto;\n}\n.svg-inline--fa.fa-li {\n  width: var(--fa-li-width, 2em);\n  top: 0.25em;\n}\n.svg-inline--fa.fa-fw {\n  width: var(--fa-fw-width, 1.25em);\n}\n\n.fa-layers svg.svg-inline--fa {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.fa-layers-counter, .fa-layers-text {\n  display: inline-block;\n  position: absolute;\n  text-align: center;\n}\n\n.fa-layers {\n  display: inline-block;\n  height: 1em;\n  position: relative;\n  text-align: center;\n  vertical-align: -0.125em;\n  width: 1em;\n}\n.fa-layers svg.svg-inline--fa {\n  transform-origin: center center;\n}\n\n.fa-layers-text {\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  transform-origin: center center;\n}\n\n.fa-layers-counter {\n  background-color: var(--fa-counter-background-color, #ff253a);\n  border-radius: var(--fa-counter-border-radius, 1em);\n  box-sizing: border-box;\n  color: var(--fa-inverse, #fff);\n  line-height: var(--fa-counter-line-height, 1);\n  max-width: var(--fa-counter-max-width, 5em);\n  min-width: var(--fa-counter-min-width, 1.5em);\n  overflow: hidden;\n  padding: var(--fa-counter-padding, 0.25em 0.5em);\n  right: var(--fa-right, 0);\n  text-overflow: ellipsis;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-counter-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-bottom-right {\n  bottom: var(--fa-bottom, 0);\n  right: var(--fa-right, 0);\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom right;\n}\n\n.fa-layers-bottom-left {\n  bottom: var(--fa-bottom, 0);\n  left: var(--fa-left, 0);\n  right: auto;\n  top: auto;\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: bottom left;\n}\n\n.fa-layers-top-right {\n  top: var(--fa-top, 0);\n  right: var(--fa-right, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top right;\n}\n\n.fa-layers-top-left {\n  left: var(--fa-left, 0);\n  right: auto;\n  top: var(--fa-top, 0);\n  transform: scale(var(--fa-layers-scale, 0.25));\n  transform-origin: top left;\n}\n\n.fa-1x {\n  font-size: 1em;\n}\n\n.fa-2x {\n  font-size: 2em;\n}\n\n.fa-3x {\n  font-size: 3em;\n}\n\n.fa-4x {\n  font-size: 4em;\n}\n\n.fa-5x {\n  font-size: 5em;\n}\n\n.fa-6x {\n  font-size: 6em;\n}\n\n.fa-7x {\n  font-size: 7em;\n}\n\n.fa-8x {\n  font-size: 8em;\n}\n\n.fa-9x {\n  font-size: 9em;\n}\n\n.fa-10x {\n  font-size: 10em;\n}\n\n.fa-2xs {\n  font-size: 0.625em;\n  line-height: 0.1em;\n  vertical-align: 0.225em;\n}\n\n.fa-xs {\n  font-size: 0.75em;\n  line-height: 0.0833333337em;\n  vertical-align: 0.125em;\n}\n\n.fa-sm {\n  font-size: 0.875em;\n  line-height: 0.0714285718em;\n  vertical-align: 0.0535714295em;\n}\n\n.fa-lg {\n  font-size: 1.25em;\n  line-height: 0.05em;\n  vertical-align: -0.075em;\n}\n\n.fa-xl {\n  font-size: 1.5em;\n  line-height: 0.0416666682em;\n  vertical-align: -0.125em;\n}\n\n.fa-2xl {\n  font-size: 2em;\n  line-height: 0.03125em;\n  vertical-align: -0.1875em;\n}\n\n.fa-fw {\n  text-align: center;\n  width: 1.25em;\n}\n\n.fa-ul {\n  list-style-type: none;\n  margin-left: var(--fa-li-margin, 2.5em);\n  padding-left: 0;\n}\n.fa-ul > li {\n  position: relative;\n}\n\n.fa-li {\n  left: calc(-1 * var(--fa-li-width, 2em));\n  position: absolute;\n  text-align: center;\n  width: var(--fa-li-width, 2em);\n  line-height: inherit;\n}\n\n.fa-border {\n  border-color: var(--fa-border-color, #eee);\n  border-radius: var(--fa-border-radius, 0.1em);\n  border-style: var(--fa-border-style, solid);\n  border-width: var(--fa-border-width, 0.08em);\n  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);\n}\n\n.fa-pull-left {\n  float: left;\n  margin-right: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-pull-right {\n  float: right;\n  margin-left: var(--fa-pull-margin, 0.3em);\n}\n\n.fa-beat {\n  animation-name: fa-beat;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-bounce {\n  animation-name: fa-bounce;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));\n}\n\n.fa-fade {\n  animation-name: fa-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-beat-fade {\n  animation-name: fa-beat-fade;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));\n}\n\n.fa-flip {\n  animation-name: fa-flip;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, ease-in-out);\n}\n\n.fa-shake {\n  animation-name: fa-shake;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin {\n  animation-name: fa-spin;\n  animation-delay: var(--fa-animation-delay, 0s);\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 2s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, linear);\n}\n\n.fa-spin-reverse {\n  --fa-animation-direction: reverse;\n}\n\n.fa-pulse,\n.fa-spin-pulse {\n  animation-name: fa-spin;\n  animation-direction: var(--fa-animation-direction, normal);\n  animation-duration: var(--fa-animation-duration, 1s);\n  animation-iteration-count: var(--fa-animation-iteration-count, infinite);\n  animation-timing-function: var(--fa-animation-timing, steps(8));\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .fa-beat,\n.fa-bounce,\n.fa-fade,\n.fa-beat-fade,\n.fa-flip,\n.fa-pulse,\n.fa-shake,\n.fa-spin,\n.fa-spin-pulse {\n    animation-delay: -1ms;\n    animation-duration: 1ms;\n    animation-iteration-count: 1;\n    transition-delay: 0s;\n    transition-duration: 0s;\n  }\n}\n@keyframes fa-beat {\n  0%, 90% {\n    transform: scale(1);\n  }\n  45% {\n    transform: scale(var(--fa-beat-scale, 1.25));\n  }\n}\n@keyframes fa-bounce {\n  0% {\n    transform: scale(1, 1) translateY(0);\n  }\n  10% {\n    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);\n  }\n  30% {\n    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));\n  }\n  50% {\n    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);\n  }\n  57% {\n    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));\n  }\n  64% {\n    transform: scale(1, 1) translateY(0);\n  }\n  100% {\n    transform: scale(1, 1) translateY(0);\n  }\n}\n@keyframes fa-fade {\n  50% {\n    opacity: var(--fa-fade-opacity, 0.4);\n  }\n}\n@keyframes fa-beat-fade {\n  0%, 100% {\n    opacity: var(--fa-beat-fade-opacity, 0.4);\n    transform: scale(1);\n  }\n  50% {\n    opacity: 1;\n    transform: scale(var(--fa-beat-fade-scale, 1.125));\n  }\n}\n@keyframes fa-flip {\n  50% {\n    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));\n  }\n}\n@keyframes fa-shake {\n  0% {\n    transform: rotate(-15deg);\n  }\n  4% {\n    transform: rotate(15deg);\n  }\n  8%, 24% {\n    transform: rotate(-18deg);\n  }\n  12%, 28% {\n    transform: rotate(18deg);\n  }\n  16% {\n    transform: rotate(-22deg);\n  }\n  20% {\n    transform: rotate(22deg);\n  }\n  32% {\n    transform: rotate(-12deg);\n  }\n  36% {\n    transform: rotate(12deg);\n  }\n  40%, 100% {\n    transform: rotate(0deg);\n  }\n}\n@keyframes fa-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.fa-rotate-90 {\n  transform: rotate(90deg);\n}\n\n.fa-rotate-180 {\n  transform: rotate(180deg);\n}\n\n.fa-rotate-270 {\n  transform: rotate(270deg);\n}\n\n.fa-flip-horizontal {\n  transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  transform: scale(1, -1);\n}\n\n.fa-flip-both,\n.fa-flip-horizontal.fa-flip-vertical {\n  transform: scale(-1, -1);\n}\n\n.fa-rotate-by {\n  transform: rotate(var(--fa-rotate-angle, 0));\n}\n\n.fa-stack {\n  display: inline-block;\n  vertical-align: middle;\n  height: 2em;\n  position: relative;\n  width: 2.5em;\n}\n\n.fa-stack-1x,\n.fa-stack-2x {\n  bottom: 0;\n  left: 0;\n  margin: auto;\n  position: absolute;\n  right: 0;\n  top: 0;\n  z-index: var(--fa-stack-z-index, auto);\n}\n\n.svg-inline--fa.fa-stack-1x {\n  height: 1em;\n  width: 1.25em;\n}\n.svg-inline--fa.fa-stack-2x {\n  height: 2em;\n  width: 2.5em;\n}\n\n.fa-inverse {\n  color: var(--fa-inverse, #fff);\n}\n\n.sr-only,\n.fa-sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.sr-only-focusable:not(:focus),\n.fa-sr-only-focusable:not(:focus) {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  white-space: nowrap;\n  border-width: 0;\n}\n\n.svg-inline--fa .fa-primary {\n  fill: var(--fa-primary-color, currentColor);\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa .fa-secondary {\n  fill: var(--fa-secondary-color, currentColor);\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-primary {\n  opacity: var(--fa-secondary-opacity, 0.4);\n}\n\n.svg-inline--fa.fa-swap-opacity .fa-secondary {\n  opacity: var(--fa-primary-opacity, 1);\n}\n\n.svg-inline--fa mask .fa-primary,\n.svg-inline--fa mask .fa-secondary {\n  fill: black;\n}';
  function css2() {
    const dcp = DEFAULT_CSS_PREFIX;
    const drc = DEFAULT_REPLACEMENT_CLASS;
    const fp = config.cssPrefix;
    const rc = config.replacementClass;
    let s2 = baseStyles;
    if (fp !== dcp || rc !== drc) {
      const dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
      const customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
      const rPatt = new RegExp("\\.".concat(drc), "g");
      s2 = s2.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
    }
    return s2;
  }
  var _cssInserted = false;
  function ensureCss() {
    if (config.autoAddCss && !_cssInserted) {
      insertCss(css2());
      _cssInserted = true;
    }
  }
  var InjectCSS = {
    mixout() {
      return {
        dom: {
          css: css2,
          insertCss: ensureCss
        }
      };
    },
    hooks() {
      return {
        beforeDOMElementCreation() {
          ensureCss();
        },
        beforeI2svg() {
          ensureCss();
        }
      };
    }
  };
  var w = WINDOW || {};
  if (!w[NAMESPACE_IDENTIFIER]) w[NAMESPACE_IDENTIFIER] = {};
  if (!w[NAMESPACE_IDENTIFIER].styles) w[NAMESPACE_IDENTIFIER].styles = {};
  if (!w[NAMESPACE_IDENTIFIER].hooks) w[NAMESPACE_IDENTIFIER].hooks = {};
  if (!w[NAMESPACE_IDENTIFIER].shims) w[NAMESPACE_IDENTIFIER].shims = [];
  var namespace = w[NAMESPACE_IDENTIFIER];
  var functions = [];
  var listener2 = function() {
    DOCUMENT.removeEventListener("DOMContentLoaded", listener2);
    loaded = 1;
    functions.map((fn) => fn());
  };
  var loaded = false;
  if (IS_DOM) {
    loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
    if (!loaded) DOCUMENT.addEventListener("DOMContentLoaded", listener2);
  }
  function domready(fn) {
    if (!IS_DOM) return;
    loaded ? setTimeout(fn, 0) : functions.push(fn);
  }
  function toHtml(abstractNodes) {
    const {
      tag,
      attributes = {},
      children = []
    } = abstractNodes;
    if (typeof abstractNodes === "string") {
      return htmlEscape(abstractNodes);
    } else {
      return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
    }
  }
  function iconFromMapping(mapping, prefix2, iconName) {
    if (mapping && mapping[prefix2] && mapping[prefix2][iconName]) {
      return {
        prefix: prefix2,
        iconName,
        icon: mapping[prefix2][iconName]
      };
    }
  }
  var bindInternal4 = function bindInternal42(func, thisContext) {
    return function(a, b, c, d) {
      return func.call(thisContext, a, b, c, d);
    };
  };
  var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
    var keys = Object.keys(subject), length2 = keys.length, iterator = thisContext !== void 0 ? bindInternal4(fn, thisContext) : fn, i, key, result;
    if (initialValue === void 0) {
      i = 1;
      result = subject[keys[0]];
    } else {
      i = 0;
      result = initialValue;
    }
    for (; i < length2; i++) {
      key = keys[i];
      result = iterator(result, subject[key], key, subject);
    }
    return result;
  };
  function ucs2decode(string) {
    const output = [];
    let counter2 = 0;
    const length2 = string.length;
    while (counter2 < length2) {
      const value = string.charCodeAt(counter2++);
      if (value >= 55296 && value <= 56319 && counter2 < length2) {
        const extra = string.charCodeAt(counter2++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter2--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  function toHex(unicode) {
    const decoded = ucs2decode(unicode);
    return decoded.length === 1 ? decoded[0].toString(16) : null;
  }
  function codePointAt(string, index) {
    const size = string.length;
    let first = string.charCodeAt(index);
    let second;
    if (first >= 55296 && first <= 56319 && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 56320 && second <= 57343) {
        return (first - 55296) * 1024 + second - 56320 + 65536;
      }
    }
    return first;
  }
  function normalizeIcons(icons) {
    return Object.keys(icons).reduce((acc, iconName) => {
      const icon2 = icons[iconName];
      const expanded = !!icon2.icon;
      if (expanded) {
        acc[icon2.iconName] = icon2.icon;
      } else {
        acc[iconName] = icon2;
      }
      return acc;
    }, {});
  }
  function defineIcons(prefix2, icons) {
    let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      skipHooks = false
    } = params;
    const normalized = normalizeIcons(icons);
    if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
      namespace.hooks.addPack(prefix2, normalizeIcons(icons));
    } else {
      namespace.styles[prefix2] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix2] || {}), normalized);
    }
    if (prefix2 === "fas") {
      defineIcons("fa", icons);
    }
  }
  var {
    styles,
    shims
  } = namespace;
  var FAMILY_NAMES = Object.keys(PREFIX_TO_LONG_STYLE);
  var PREFIXES_FOR_FAMILY = FAMILY_NAMES.reduce((acc, familyId) => {
    acc[familyId] = Object.keys(PREFIX_TO_LONG_STYLE[familyId]);
    return acc;
  }, {});
  var _defaultUsablePrefix = null;
  var _byUnicode = {};
  var _byLigature = {};
  var _byOldName = {};
  var _byOldUnicode = {};
  var _byAlias = {};
  function isReserved(name) {
    return ~RESERVED_CLASSES.indexOf(name);
  }
  function getIconName(cssPrefix, cls) {
    const parts = cls.split("-");
    const prefix2 = parts[0];
    const iconName = parts.slice(1).join("-");
    if (prefix2 === cssPrefix && iconName !== "" && !isReserved(iconName)) {
      return iconName;
    } else {
      return null;
    }
  }
  var build = () => {
    const lookup = (reducer) => {
      return reduce(styles, (o$$1, style, prefix2) => {
        o$$1[prefix2] = reduce(style, reducer, {});
        return o$$1;
      }, {});
    };
    _byUnicode = lookup((acc, icon2, iconName) => {
      if (icon2[3]) {
        acc[icon2[3]] = iconName;
      }
      if (icon2[2]) {
        const aliases = icon2[2].filter((a$$1) => {
          return typeof a$$1 === "number";
        });
        aliases.forEach((alias) => {
          acc[alias.toString(16)] = iconName;
        });
      }
      return acc;
    });
    _byLigature = lookup((acc, icon2, iconName) => {
      acc[iconName] = iconName;
      if (icon2[2]) {
        const aliases = icon2[2].filter((a$$1) => {
          return typeof a$$1 === "string";
        });
        aliases.forEach((alias) => {
          acc[alias] = iconName;
        });
      }
      return acc;
    });
    _byAlias = lookup((acc, icon2, iconName) => {
      const aliases = icon2[2];
      acc[iconName] = iconName;
      aliases.forEach((alias) => {
        acc[alias] = iconName;
      });
      return acc;
    });
    const hasRegular = "far" in styles || config.autoFetchSvg;
    const shimLookups = reduce(shims, (acc, shim) => {
      const maybeNameMaybeUnicode = shim[0];
      let prefix2 = shim[1];
      const iconName = shim[2];
      if (prefix2 === "far" && !hasRegular) {
        prefix2 = "fas";
      }
      if (typeof maybeNameMaybeUnicode === "string") {
        acc.names[maybeNameMaybeUnicode] = {
          prefix: prefix2,
          iconName
        };
      }
      if (typeof maybeNameMaybeUnicode === "number") {
        acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
          prefix: prefix2,
          iconName
        };
      }
      return acc;
    }, {
      names: {},
      unicodes: {}
    });
    _byOldName = shimLookups.names;
    _byOldUnicode = shimLookups.unicodes;
    _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
      family: config.familyDefault
    });
  };
  onChange((c$$1) => {
    _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
      family: config.familyDefault
    });
  });
  build();
  function byUnicode(prefix2, unicode) {
    return (_byUnicode[prefix2] || {})[unicode];
  }
  function byLigature(prefix2, ligature) {
    return (_byLigature[prefix2] || {})[ligature];
  }
  function byAlias(prefix2, alias) {
    return (_byAlias[prefix2] || {})[alias];
  }
  function byOldName(name) {
    return _byOldName[name] || {
      prefix: null,
      iconName: null
    };
  }
  function byOldUnicode(unicode) {
    const oldUnicode = _byOldUnicode[unicode];
    const newUnicode = byUnicode("fas", unicode);
    return oldUnicode || (newUnicode ? {
      prefix: "fas",
      iconName: newUnicode
    } : null) || {
      prefix: null,
      iconName: null
    };
  }
  function getDefaultUsablePrefix() {
    return _defaultUsablePrefix;
  }
  var emptyCanonicalIcon = () => {
    return {
      prefix: null,
      iconName: null,
      rest: []
    };
  };
  function getFamilyId(values) {
    let family = s;
    const famProps = FAMILY_NAMES.reduce((acc, familyId) => {
      acc[familyId] = "".concat(config.cssPrefix, "-").concat(familyId);
      return acc;
    }, {});
    L.forEach((familyId) => {
      if (values.includes(famProps[familyId]) || values.some((v$$1) => PREFIXES_FOR_FAMILY[familyId].includes(v$$1))) {
        family = familyId;
      }
    });
    return family;
  }
  function getCanonicalPrefix(styleOrPrefix) {
    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      family = s
    } = params;
    const style = PREFIX_TO_STYLE[family][styleOrPrefix];
    if (family === t && !styleOrPrefix) {
      return "fad";
    }
    const prefix2 = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
    const defined2 = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
    const result = prefix2 || defined2 || null;
    return result;
  }
  function moveNonFaClassesToRest(classNames) {
    let rest = [];
    let iconName = null;
    classNames.forEach((cls) => {
      const result = getIconName(config.cssPrefix, cls);
      if (result) {
        iconName = result;
      } else if (cls) {
        rest.push(cls);
      }
    });
    return {
      iconName,
      rest
    };
  }
  function sortedUniqueValues(arr) {
    return arr.sort().filter((value, index, arr2) => {
      return arr2.indexOf(value) === index;
    });
  }
  function getCanonicalIcon(values) {
    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      skipLookups = false
    } = params;
    let givenPrefix = null;
    const faCombinedClasses = Ia.concat(bt$1);
    const faStyleOrFamilyClasses = sortedUniqueValues(values.filter((cls) => faCombinedClasses.includes(cls)));
    const nonStyleOrFamilyClasses = sortedUniqueValues(values.filter((cls) => !Ia.includes(cls)));
    const faStyles = faStyleOrFamilyClasses.filter((cls) => {
      givenPrefix = cls;
      return !P.includes(cls);
    });
    const [styleFromValues = null] = faStyles;
    const family = getFamilyId(faStyleOrFamilyClasses);
    const canonical = _objectSpread2(_objectSpread2({}, moveNonFaClassesToRest(nonStyleOrFamilyClasses)), {}, {
      prefix: getCanonicalPrefix(styleFromValues, {
        family
      })
    });
    return _objectSpread2(_objectSpread2(_objectSpread2({}, canonical), getDefaultCanonicalPrefix({
      values,
      family,
      styles,
      config,
      canonical,
      givenPrefix
    })), applyShimAndAlias(skipLookups, givenPrefix, canonical));
  }
  function applyShimAndAlias(skipLookups, givenPrefix, canonical) {
    let {
      prefix: prefix2,
      iconName
    } = canonical;
    if (skipLookups || !prefix2 || !iconName) {
      return {
        prefix: prefix2,
        iconName
      };
    }
    const shim = givenPrefix === "fa" ? byOldName(iconName) : {};
    const aliasIconName = byAlias(prefix2, iconName);
    iconName = shim.iconName || aliasIconName || iconName;
    prefix2 = shim.prefix || prefix2;
    if (prefix2 === "far" && !styles["far"] && styles["fas"] && !config.autoFetchSvg) {
      prefix2 = "fas";
    }
    return {
      prefix: prefix2,
      iconName
    };
  }
  var newCanonicalFamilies = L.filter((familyId) => {
    return familyId !== s || familyId !== t;
  });
  var newCanonicalStyles = Object.keys(ga).filter((key) => key !== s).map((key) => Object.keys(ga[key])).flat();
  function getDefaultCanonicalPrefix(prefixOptions) {
    const {
      values,
      family,
      canonical,
      givenPrefix = "",
      styles: styles2 = {},
      config: config$$1 = {}
    } = prefixOptions;
    const isDuotoneFamily = family === t;
    const valuesHasDuotone = values.includes("fa-duotone") || values.includes("fad");
    const defaultFamilyIsDuotone = config$$1.familyDefault === "duotone";
    const canonicalPrefixIsDuotone = canonical.prefix === "fad" || canonical.prefix === "fa-duotone";
    if (!isDuotoneFamily && (valuesHasDuotone || defaultFamilyIsDuotone || canonicalPrefixIsDuotone)) {
      canonical.prefix = "fad";
    }
    if (values.includes("fa-brands") || values.includes("fab")) {
      canonical.prefix = "fab";
    }
    if (!canonical.prefix && newCanonicalFamilies.includes(family)) {
      const validPrefix = Object.keys(styles2).find((key) => newCanonicalStyles.includes(key));
      if (validPrefix || config$$1.autoFetchSvg) {
        const defaultPrefix = pt.get(family).defaultShortPrefixId;
        canonical.prefix = defaultPrefix;
        canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
      }
    }
    if (canonical.prefix === "fa" || givenPrefix === "fa") {
      canonical.prefix = getDefaultUsablePrefix() || "fas";
    }
    return canonical;
  }
  var Library = class {
    constructor() {
      this.definitions = {};
    }
    add() {
      for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
        definitions[_key] = arguments[_key];
      }
      const additions = definitions.reduce(this._pullDefinitions, {});
      Object.keys(additions).forEach((key) => {
        this.definitions[key] = _objectSpread2(_objectSpread2({}, this.definitions[key] || {}), additions[key]);
        defineIcons(key, additions[key]);
        const longPrefix = PREFIX_TO_LONG_STYLE[s][key];
        if (longPrefix) defineIcons(longPrefix, additions[key]);
        build();
      });
    }
    reset() {
      this.definitions = {};
    }
    _pullDefinitions(additions, definition) {
      const normalized = definition.prefix && definition.iconName && definition.icon ? {
        0: definition
      } : definition;
      Object.keys(normalized).map((key) => {
        const {
          prefix: prefix2,
          iconName,
          icon: icon2
        } = normalized[key];
        const aliases = icon2[2];
        if (!additions[prefix2]) additions[prefix2] = {};
        if (aliases.length > 0) {
          aliases.forEach((alias) => {
            if (typeof alias === "string") {
              additions[prefix2][alias] = icon2;
            }
          });
        }
        additions[prefix2][iconName] = icon2;
      });
      return additions;
    }
  };
  var _plugins = [];
  var _hooks = {};
  var providers = {};
  var defaultProviderKeys = Object.keys(providers);
  function registerPlugins(nextPlugins, _ref) {
    let {
      mixoutsTo: obj
    } = _ref;
    _plugins = nextPlugins;
    _hooks = {};
    Object.keys(providers).forEach((k) => {
      if (defaultProviderKeys.indexOf(k) === -1) {
        delete providers[k];
      }
    });
    _plugins.forEach((plugin) => {
      const mixout = plugin.mixout ? plugin.mixout() : {};
      Object.keys(mixout).forEach((tk) => {
        if (typeof mixout[tk] === "function") {
          obj[tk] = mixout[tk];
        }
        if (typeof mixout[tk] === "object") {
          Object.keys(mixout[tk]).forEach((sk) => {
            if (!obj[tk]) {
              obj[tk] = {};
            }
            obj[tk][sk] = mixout[tk][sk];
          });
        }
      });
      if (plugin.hooks) {
        const hooks = plugin.hooks();
        Object.keys(hooks).forEach((hook) => {
          if (!_hooks[hook]) {
            _hooks[hook] = [];
          }
          _hooks[hook].push(hooks[hook]);
        });
      }
      if (plugin.provides) {
        plugin.provides(providers);
      }
    });
    return obj;
  }
  function chainHooks(hook, accumulator) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    const hookFns = _hooks[hook] || [];
    hookFns.forEach((hookFn) => {
      accumulator = hookFn.apply(null, [accumulator, ...args]);
    });
    return accumulator;
  }
  function callHooks(hook) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    const hookFns = _hooks[hook] || [];
    hookFns.forEach((hookFn) => {
      hookFn.apply(null, args);
    });
    return void 0;
  }
  function callProvided() {
    const hook = arguments[0];
    const args = Array.prototype.slice.call(arguments, 1);
    return providers[hook] ? providers[hook].apply(null, args) : void 0;
  }
  function findIconDefinition(iconLookup) {
    if (iconLookup.prefix === "fa") {
      iconLookup.prefix = "fas";
    }
    let {
      iconName
    } = iconLookup;
    const prefix2 = iconLookup.prefix || getDefaultUsablePrefix();
    if (!iconName) return;
    iconName = byAlias(prefix2, iconName) || iconName;
    return iconFromMapping(library.definitions, prefix2, iconName) || iconFromMapping(namespace.styles, prefix2, iconName);
  }
  var library = new Library();
  var noAuto = () => {
    config.autoReplaceSvg = false;
    config.observeMutations = false;
    callHooks("noAuto");
  };
  var dom = {
    i2svg: function() {
      let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (IS_DOM) {
        callHooks("beforeI2svg", params);
        callProvided("pseudoElements2svg", params);
        return callProvided("i2svg", params);
      } else {
        return Promise.reject(new Error("Operation requires a DOM of some kind."));
      }
    },
    watch: function() {
      let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        autoReplaceSvgRoot
      } = params;
      if (config.autoReplaceSvg === false) {
        config.autoReplaceSvg = true;
      }
      config.observeMutations = true;
      domready(() => {
        autoReplace({
          autoReplaceSvgRoot
        });
        callHooks("watch", params);
      });
    }
  };
  var parse3 = {
    icon: (icon2) => {
      if (icon2 === null) {
        return null;
      }
      if (typeof icon2 === "object" && icon2.prefix && icon2.iconName) {
        return {
          prefix: icon2.prefix,
          iconName: byAlias(icon2.prefix, icon2.iconName) || icon2.iconName
        };
      }
      if (Array.isArray(icon2) && icon2.length === 2) {
        const iconName = icon2[1].indexOf("fa-") === 0 ? icon2[1].slice(3) : icon2[1];
        const prefix2 = getCanonicalPrefix(icon2[0]);
        return {
          prefix: prefix2,
          iconName: byAlias(prefix2, iconName) || iconName
        };
      }
      if (typeof icon2 === "string" && (icon2.indexOf("".concat(config.cssPrefix, "-")) > -1 || icon2.match(ICON_SELECTION_SYNTAX_PATTERN))) {
        const canonicalIcon = getCanonicalIcon(icon2.split(" "), {
          skipLookups: true
        });
        return {
          prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
          iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
        };
      }
      if (typeof icon2 === "string") {
        const prefix2 = getDefaultUsablePrefix();
        return {
          prefix: prefix2,
          iconName: byAlias(prefix2, icon2) || icon2
        };
      }
    }
  };
  var api2 = {
    noAuto,
    config,
    dom,
    parse: parse3,
    library,
    findIconDefinition,
    toHtml
  };
  var autoReplace = function() {
    let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot = DOCUMENT
    } = params;
    if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api2.dom.i2svg({
      node: autoReplaceSvgRoot
    });
  };
  function domVariants(val, abstractCreator) {
    Object.defineProperty(val, "abstract", {
      get: abstractCreator
    });
    Object.defineProperty(val, "html", {
      get: function() {
        return val.abstract.map((a) => toHtml(a));
      }
    });
    Object.defineProperty(val, "node", {
      get: function() {
        if (!IS_DOM) return;
        const container = DOCUMENT.createElement("div");
        container.innerHTML = val.html;
        return container.children;
      }
    });
    return val;
  }
  function asIcon(_ref) {
    let {
      children,
      main,
      mask,
      attributes,
      styles: styles2,
      transform: transform2
    } = _ref;
    if (transformIsMeaningful(transform2) && main.found && !mask.found) {
      const {
        width,
        height
      } = main;
      const offset = {
        x: width / height / 2,
        y: 0.5
      };
      attributes["style"] = joinStyles(_objectSpread2(_objectSpread2({}, styles2), {}, {
        "transform-origin": "".concat(offset.x + transform2.x / 16, "em ").concat(offset.y + transform2.y / 16, "em")
      }));
    }
    return [{
      tag: "svg",
      attributes,
      children
    }];
  }
  function asSymbol(_ref) {
    let {
      prefix: prefix2,
      iconName,
      children,
      attributes,
      symbol
    } = _ref;
    const id = symbol === true ? "".concat(prefix2, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol;
    return [{
      tag: "svg",
      attributes: {
        style: "display: none;"
      },
      children: [{
        tag: "symbol",
        attributes: _objectSpread2(_objectSpread2({}, attributes), {}, {
          id
        }),
        children
      }]
    }];
  }
  function makeInlineSvgAbstract(params) {
    const {
      icons: {
        main,
        mask
      },
      prefix: prefix2,
      iconName,
      transform: transform2,
      symbol,
      title,
      maskId,
      titleId,
      extra,
      watchable = false
    } = params;
    const {
      width,
      height
    } = mask.found ? mask : main;
    const isUploadedIcon = Lt.includes(prefix2);
    const attrClass = [config.replacementClass, iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ""].filter((c$$1) => extra.classes.indexOf(c$$1) === -1).filter((c$$1) => c$$1 !== "" || !!c$$1).concat(extra.classes).join(" ");
    let content = {
      children: [],
      attributes: _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
        "data-prefix": prefix2,
        "data-icon": iconName,
        "class": attrClass,
        "role": extra.attributes.role || "img",
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": "0 0 ".concat(width, " ").concat(height)
      })
    };
    const uploadedIconWidthStyle = isUploadedIcon && !~extra.classes.indexOf("fa-fw") ? {
      width: "".concat(width / height * 16 * 0.0625, "em")
    } : {};
    if (watchable) {
      content.attributes[DATA_FA_I2SVG] = "";
    }
    if (title) {
      content.children.push({
        tag: "title",
        attributes: {
          id: content.attributes["aria-labelledby"] || "title-".concat(titleId || nextUniqueId())
        },
        children: [title]
      });
      delete content.attributes.title;
    }
    const args = _objectSpread2(_objectSpread2({}, content), {}, {
      prefix: prefix2,
      iconName,
      main,
      mask,
      maskId,
      transform: transform2,
      symbol,
      styles: _objectSpread2(_objectSpread2({}, uploadedIconWidthStyle), extra.styles)
    });
    const {
      children,
      attributes
    } = mask.found && main.found ? callProvided("generateAbstractMask", args) || {
      children: [],
      attributes: {}
    } : callProvided("generateAbstractIcon", args) || {
      children: [],
      attributes: {}
    };
    args.children = children;
    args.attributes = attributes;
    if (symbol) {
      return asSymbol(args);
    } else {
      return asIcon(args);
    }
  }
  function makeLayersTextAbstract(params) {
    const {
      content,
      width,
      height,
      transform: transform2,
      title,
      extra,
      watchable = false
    } = params;
    const attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
      "title": title
    } : {}), {}, {
      "class": extra.classes.join(" ")
    });
    if (watchable) {
      attributes[DATA_FA_I2SVG] = "";
    }
    const styles2 = _objectSpread2({}, extra.styles);
    if (transformIsMeaningful(transform2)) {
      styles2["transform"] = transformForCss({
        transform: transform2,
        startCentered: true,
        width,
        height
      });
      styles2["-webkit-transform"] = styles2["transform"];
    }
    const styleString = joinStyles(styles2);
    if (styleString.length > 0) {
      attributes["style"] = styleString;
    }
    const val = [];
    val.push({
      tag: "span",
      attributes,
      children: [content]
    });
    if (title) {
      val.push({
        tag: "span",
        attributes: {
          class: "sr-only"
        },
        children: [title]
      });
    }
    return val;
  }
  function makeLayersCounterAbstract(params) {
    const {
      content,
      title,
      extra
    } = params;
    const attributes = _objectSpread2(_objectSpread2(_objectSpread2({}, extra.attributes), title ? {
      "title": title
    } : {}), {}, {
      "class": extra.classes.join(" ")
    });
    const styleString = joinStyles(extra.styles);
    if (styleString.length > 0) {
      attributes["style"] = styleString;
    }
    const val = [];
    val.push({
      tag: "span",
      attributes,
      children: [content]
    });
    if (title) {
      val.push({
        tag: "span",
        attributes: {
          class: "sr-only"
        },
        children: [title]
      });
    }
    return val;
  }
  var {
    styles: styles$1
  } = namespace;
  function asFoundIcon(icon2) {
    const width = icon2[0];
    const height = icon2[1];
    const [vectorData] = icon2.slice(4);
    let element = null;
    if (Array.isArray(vectorData)) {
      element = {
        tag: "g",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
        },
        children: [{
          tag: "path",
          attributes: {
            class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
            fill: "currentColor",
            d: vectorData[0]
          }
        }, {
          tag: "path",
          attributes: {
            class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
            fill: "currentColor",
            d: vectorData[1]
          }
        }]
      };
    } else {
      element = {
        tag: "path",
        attributes: {
          fill: "currentColor",
          d: vectorData
        }
      };
    }
    return {
      found: true,
      width,
      height,
      icon: element
    };
  }
  var missingIconResolutionMixin = {
    found: false,
    width: 512,
    height: 512
  };
  function maybeNotifyMissing(iconName, prefix2) {
    if (!PRODUCTION && !config.showMissingIcons && iconName) {
      console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix2, '" is missing.'));
    }
  }
  function findIcon(iconName, prefix2) {
    let givenPrefix = prefix2;
    if (prefix2 === "fa" && config.styleDefault !== null) {
      prefix2 = getDefaultUsablePrefix();
    }
    return new Promise((resolve2, reject) => {
      if (givenPrefix === "fa") {
        const shim = byOldName(iconName) || {};
        iconName = shim.iconName || iconName;
        prefix2 = shim.prefix || prefix2;
      }
      if (iconName && prefix2 && styles$1[prefix2] && styles$1[prefix2][iconName]) {
        const icon2 = styles$1[prefix2][iconName];
        return resolve2(asFoundIcon(icon2));
      }
      maybeNotifyMissing(iconName, prefix2);
      resolve2(_objectSpread2(_objectSpread2({}, missingIconResolutionMixin), {}, {
        icon: config.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
      }));
    });
  }
  var noop$1 = () => {
  };
  var p$2 = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
    mark: noop$1,
    measure: noop$1
  };
  var preamble = 'FA "6.7.2"';
  var begin = (name) => {
    p$2.mark("".concat(preamble, " ").concat(name, " begins"));
    return () => end(name);
  };
  var end = (name) => {
    p$2.mark("".concat(preamble, " ").concat(name, " ends"));
    p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
  };
  var perf = {
    begin,
    end
  };
  var noop$2 = () => {
  };
  function isWatched(node2) {
    const i2svg = node2.getAttribute ? node2.getAttribute(DATA_FA_I2SVG) : null;
    return typeof i2svg === "string";
  }
  function hasPrefixAndIcon(node2) {
    const prefix2 = node2.getAttribute ? node2.getAttribute(DATA_PREFIX) : null;
    const icon2 = node2.getAttribute ? node2.getAttribute(DATA_ICON) : null;
    return prefix2 && icon2;
  }
  function hasBeenReplaced(node2) {
    return node2 && node2.classList && node2.classList.contains && node2.classList.contains(config.replacementClass);
  }
  function getMutator() {
    if (config.autoReplaceSvg === true) {
      return mutators.replace;
    }
    const mutator = mutators[config.autoReplaceSvg];
    return mutator || mutators.replace;
  }
  function createElementNS(tag) {
    return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
  }
  function createElement14(tag) {
    return DOCUMENT.createElement(tag);
  }
  function convertSVG(abstractObj) {
    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      ceFn = abstractObj.tag === "svg" ? createElementNS : createElement14
    } = params;
    if (typeof abstractObj === "string") {
      return DOCUMENT.createTextNode(abstractObj);
    }
    const tag = ceFn(abstractObj.tag);
    Object.keys(abstractObj.attributes || []).forEach(function(key) {
      tag.setAttribute(key, abstractObj.attributes[key]);
    });
    const children = abstractObj.children || [];
    children.forEach(function(child) {
      tag.appendChild(convertSVG(child, {
        ceFn
      }));
    });
    return tag;
  }
  function nodeAsComment(node2) {
    let comment2 = " ".concat(node2.outerHTML, " ");
    comment2 = "".concat(comment2, "Font Awesome fontawesome.com ");
    return comment2;
  }
  var mutators = {
    replace: function(mutation) {
      const node2 = mutation[0];
      if (node2.parentNode) {
        mutation[1].forEach((abstract2) => {
          node2.parentNode.insertBefore(convertSVG(abstract2), node2);
        });
        if (node2.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
          let comment2 = DOCUMENT.createComment(nodeAsComment(node2));
          node2.parentNode.replaceChild(comment2, node2);
        } else {
          node2.remove();
        }
      }
    },
    nest: function(mutation) {
      const node2 = mutation[0];
      const abstract2 = mutation[1];
      if (~classArray(node2).indexOf(config.replacementClass)) {
        return mutators.replace(mutation);
      }
      const forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
      delete abstract2[0].attributes.id;
      if (abstract2[0].attributes.class) {
        const splitClasses = abstract2[0].attributes.class.split(" ").reduce((acc, cls) => {
          if (cls === config.replacementClass || cls.match(forSvg)) {
            acc.toSvg.push(cls);
          } else {
            acc.toNode.push(cls);
          }
          return acc;
        }, {
          toNode: [],
          toSvg: []
        });
        abstract2[0].attributes.class = splitClasses.toSvg.join(" ");
        if (splitClasses.toNode.length === 0) {
          node2.removeAttribute("class");
        } else {
          node2.setAttribute("class", splitClasses.toNode.join(" "));
        }
      }
      const newInnerHTML = abstract2.map((a) => toHtml(a)).join("\n");
      node2.setAttribute(DATA_FA_I2SVG, "");
      node2.innerHTML = newInnerHTML;
    }
  };
  function performOperationSync(op) {
    op();
  }
  function perform(mutations, callback2) {
    const callbackFunction = typeof callback2 === "function" ? callback2 : noop$2;
    if (mutations.length === 0) {
      callbackFunction();
    } else {
      let frame = performOperationSync;
      if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
        frame = WINDOW.requestAnimationFrame || performOperationSync;
      }
      frame(() => {
        const mutator = getMutator();
        const mark = perf.begin("mutate");
        mutations.map(mutator);
        mark();
        callbackFunction();
      });
    }
  }
  var disabled = false;
  function disableObservation() {
    disabled = true;
  }
  function enableObservation() {
    disabled = false;
  }
  var mo = null;
  function observe(options2) {
    if (!MUTATION_OBSERVER) {
      return;
    }
    if (!config.observeMutations) {
      return;
    }
    const {
      treeCallback = noop$2,
      nodeCallback = noop$2,
      pseudoElementsCallback = noop$2,
      observeMutationsRoot = DOCUMENT
    } = options2;
    mo = new MUTATION_OBSERVER((objects) => {
      if (disabled) return;
      const defaultPrefix = getDefaultUsablePrefix();
      toArray(objects).forEach((mutationRecord) => {
        if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
          if (config.searchPseudoElements) {
            pseudoElementsCallback(mutationRecord.target);
          }
          treeCallback(mutationRecord.target);
        }
        if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config.searchPseudoElements) {
          pseudoElementsCallback(mutationRecord.target.parentNode);
        }
        if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
          if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
            const {
              prefix: prefix2,
              iconName
            } = getCanonicalIcon(classArray(mutationRecord.target));
            mutationRecord.target.setAttribute(DATA_PREFIX, prefix2 || defaultPrefix);
            if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
          } else if (hasBeenReplaced(mutationRecord.target)) {
            nodeCallback(mutationRecord.target);
          }
        }
      });
    });
    if (!IS_DOM) return;
    mo.observe(observeMutationsRoot, {
      childList: true,
      attributes: true,
      characterData: true,
      subtree: true
    });
  }
  function disconnect() {
    if (!mo) return;
    mo.disconnect();
  }
  function styleParser(node2) {
    const style = node2.getAttribute("style");
    let val = [];
    if (style) {
      val = style.split(";").reduce((acc, style2) => {
        const styles2 = style2.split(":");
        const prop = styles2[0];
        const value = styles2.slice(1);
        if (prop && value.length > 0) {
          acc[prop] = value.join(":").trim();
        }
        return acc;
      }, {});
    }
    return val;
  }
  function classParser(node2) {
    const existingPrefix = node2.getAttribute("data-prefix");
    const existingIconName = node2.getAttribute("data-icon");
    const innerText = node2.innerText !== void 0 ? node2.innerText.trim() : "";
    let val = getCanonicalIcon(classArray(node2));
    if (!val.prefix) {
      val.prefix = getDefaultUsablePrefix();
    }
    if (existingPrefix && existingIconName) {
      val.prefix = existingPrefix;
      val.iconName = existingIconName;
    }
    if (val.iconName && val.prefix) {
      return val;
    }
    if (val.prefix && innerText.length > 0) {
      val.iconName = byLigature(val.prefix, node2.innerText) || byUnicode(val.prefix, toHex(node2.innerText));
    }
    if (!val.iconName && config.autoFetchSvg && node2.firstChild && node2.firstChild.nodeType === Node.TEXT_NODE) {
      val.iconName = node2.firstChild.data;
    }
    return val;
  }
  function attributesParser(node2) {
    const extraAttributes = toArray(node2.attributes).reduce((acc, attr) => {
      if (acc.name !== "class" && acc.name !== "style") {
        acc[attr.name] = attr.value;
      }
      return acc;
    }, {});
    const title = node2.getAttribute("title");
    const titleId = node2.getAttribute("data-fa-title-id");
    if (config.autoA11y) {
      if (title) {
        extraAttributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
      } else {
        extraAttributes["aria-hidden"] = "true";
        extraAttributes["focusable"] = "false";
      }
    }
    return extraAttributes;
  }
  function blankMeta() {
    return {
      iconName: null,
      title: null,
      titleId: null,
      prefix: null,
      transform: meaninglessTransform,
      symbol: false,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      extra: {
        classes: [],
        styles: {},
        attributes: {}
      }
    };
  }
  function parseMeta(node2) {
    let parser = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      styleParser: true
    };
    const {
      iconName,
      prefix: prefix2,
      rest: extraClasses
    } = classParser(node2);
    const extraAttributes = attributesParser(node2);
    const pluginMeta = chainHooks("parseNodeAttributes", {}, node2);
    let extraStyles = parser.styleParser ? styleParser(node2) : [];
    return _objectSpread2({
      iconName,
      title: node2.getAttribute("title"),
      titleId: node2.getAttribute("data-fa-title-id"),
      prefix: prefix2,
      transform: meaninglessTransform,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      symbol: false,
      extra: {
        classes: extraClasses,
        styles: extraStyles,
        attributes: extraAttributes
      }
    }, pluginMeta);
  }
  var {
    styles: styles$2
  } = namespace;
  function generateMutation(node2) {
    const nodeMeta = config.autoReplaceSvg === "nest" ? parseMeta(node2, {
      styleParser: false
    }) : parseMeta(node2);
    if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
      return callProvided("generateLayersText", node2, nodeMeta);
    } else {
      return callProvided("generateSvgReplacementMutation", node2, nodeMeta);
    }
  }
  function getKnownPrefixes() {
    return [...Ft, ...Ia];
  }
  function onTree(root) {
    let callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!IS_DOM) return Promise.resolve();
    const htmlClassList = DOCUMENT.documentElement.classList;
    const hclAdd = (suffix) => htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
    const hclRemove = (suffix) => htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
    const prefixes = config.autoFetchSvg ? getKnownPrefixes() : P.concat(Object.keys(styles$2));
    if (!prefixes.includes("fa")) {
      prefixes.push("fa");
    }
    const prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes.map((p$$1) => ".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])"))).join(", ");
    if (prefixesDomQuery.length === 0) {
      return Promise.resolve();
    }
    let candidates = [];
    try {
      candidates = toArray(root.querySelectorAll(prefixesDomQuery));
    } catch (e$$1) {
    }
    if (candidates.length > 0) {
      hclAdd("pending");
      hclRemove("complete");
    } else {
      return Promise.resolve();
    }
    const mark = perf.begin("onTree");
    const mutations = candidates.reduce((acc, node2) => {
      try {
        const mutation = generateMutation(node2);
        if (mutation) {
          acc.push(mutation);
        }
      } catch (e$$1) {
        if (!PRODUCTION) {
          if (e$$1.name === "MissingIcon") {
            console.error(e$$1);
          }
        }
      }
      return acc;
    }, []);
    return new Promise((resolve2, reject) => {
      Promise.all(mutations).then((resolvedMutations) => {
        perform(resolvedMutations, () => {
          hclAdd("active");
          hclAdd("complete");
          hclRemove("pending");
          if (typeof callback2 === "function") callback2();
          mark();
          resolve2();
        });
      }).catch((e$$1) => {
        mark();
        reject(e$$1);
      });
    });
  }
  function onNode(node2) {
    let callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    generateMutation(node2).then((mutation) => {
      if (mutation) {
        perform([mutation], callback2);
      }
    });
  }
  function resolveIcons(next2) {
    return function(maybeIconDefinition) {
      let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
      let {
        mask
      } = params;
      if (mask) {
        mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
      }
      return next2(iconDefinition, _objectSpread2(_objectSpread2({}, params), {}, {
        mask
      }));
    };
  }
  var render = function(iconDefinition) {
    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      transform: transform2 = meaninglessTransform,
      symbol = false,
      mask = null,
      maskId = null,
      title = null,
      titleId = null,
      classes = [],
      attributes = {},
      styles: styles2 = {}
    } = params;
    if (!iconDefinition) return;
    const {
      prefix: prefix2,
      iconName,
      icon: icon2
    } = iconDefinition;
    return domVariants(_objectSpread2({
      type: "icon"
    }, iconDefinition), () => {
      callHooks("beforeDOMElementCreation", {
        iconDefinition,
        params
      });
      if (config.autoA11y) {
        if (title) {
          attributes["aria-labelledby"] = "".concat(config.replacementClass, "-title-").concat(titleId || nextUniqueId());
        } else {
          attributes["aria-hidden"] = "true";
          attributes["focusable"] = "false";
        }
      }
      return makeInlineSvgAbstract({
        icons: {
          main: asFoundIcon(icon2),
          mask: mask ? asFoundIcon(mask.icon) : {
            found: false,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix: prefix2,
        iconName,
        transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform2),
        symbol,
        title,
        maskId,
        titleId,
        extra: {
          attributes,
          styles: styles2,
          classes
        }
      });
    });
  };
  var ReplaceElements = {
    mixout() {
      return {
        icon: resolveIcons(render)
      };
    },
    hooks() {
      return {
        mutationObserverCallbacks(accumulator) {
          accumulator.treeCallback = onTree;
          accumulator.nodeCallback = onNode;
          return accumulator;
        }
      };
    },
    provides(providers$$1) {
      providers$$1.i2svg = function(params) {
        const {
          node: node2 = DOCUMENT,
          callback: callback2 = () => {
          }
        } = params;
        return onTree(node2, callback2);
      };
      providers$$1.generateSvgReplacementMutation = function(node2, nodeMeta) {
        const {
          iconName,
          title,
          titleId,
          prefix: prefix2,
          transform: transform2,
          symbol,
          mask,
          maskId,
          extra
        } = nodeMeta;
        return new Promise((resolve2, reject) => {
          Promise.all([findIcon(iconName, prefix2), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
            found: false,
            width: 512,
            height: 512,
            icon: {}
          })]).then((_ref) => {
            let [main, mask2] = _ref;
            resolve2([node2, makeInlineSvgAbstract({
              icons: {
                main,
                mask: mask2
              },
              prefix: prefix2,
              iconName,
              transform: transform2,
              symbol,
              maskId,
              title,
              titleId,
              extra,
              watchable: true
            })]);
          }).catch(reject);
        });
      };
      providers$$1.generateAbstractIcon = function(_ref2) {
        let {
          children,
          attributes,
          main,
          transform: transform2,
          styles: styles2
        } = _ref2;
        const styleString = joinStyles(styles2);
        if (styleString.length > 0) {
          attributes["style"] = styleString;
        }
        let nextChild;
        if (transformIsMeaningful(transform2)) {
          nextChild = callProvided("generateAbstractTransformGrouping", {
            main,
            transform: transform2,
            containerWidth: main.width,
            iconWidth: main.width
          });
        }
        children.push(nextChild || main.icon);
        return {
          children,
          attributes
        };
      };
    }
  };
  var Layers = {
    mixout() {
      return {
        layer(assembler) {
          let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const {
            classes = []
          } = params;
          return domVariants({
            type: "layer"
          }, () => {
            callHooks("beforeDOMElementCreation", {
              assembler,
              params
            });
            let children = [];
            assembler((args) => {
              Array.isArray(args) ? args.map((a) => {
                children = children.concat(a.abstract);
              }) : children = children.concat(args.abstract);
            });
            return [{
              tag: "span",
              attributes: {
                class: ["".concat(config.cssPrefix, "-layers"), ...classes].join(" ")
              },
              children
            }];
          });
        }
      };
    }
  };
  var LayersCounter = {
    mixout() {
      return {
        counter(content) {
          let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const {
            title = null,
            classes = [],
            attributes = {},
            styles: styles2 = {}
          } = params;
          return domVariants({
            type: "counter",
            content
          }, () => {
            callHooks("beforeDOMElementCreation", {
              content,
              params
            });
            return makeLayersCounterAbstract({
              content: content.toString(),
              title,
              extra: {
                attributes,
                styles: styles2,
                classes: ["".concat(config.cssPrefix, "-layers-counter"), ...classes]
              }
            });
          });
        }
      };
    }
  };
  var LayersText = {
    mixout() {
      return {
        text(content) {
          let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const {
            transform: transform2 = meaninglessTransform,
            title = null,
            classes = [],
            attributes = {},
            styles: styles2 = {}
          } = params;
          return domVariants({
            type: "text",
            content
          }, () => {
            callHooks("beforeDOMElementCreation", {
              content,
              params
            });
            return makeLayersTextAbstract({
              content,
              transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform2),
              title,
              extra: {
                attributes,
                styles: styles2,
                classes: ["".concat(config.cssPrefix, "-layers-text"), ...classes]
              }
            });
          });
        }
      };
    },
    provides(providers$$1) {
      providers$$1.generateLayersText = function(node2, nodeMeta) {
        const {
          title,
          transform: transform2,
          extra
        } = nodeMeta;
        let width = null;
        let height = null;
        if (IS_IE) {
          const computedFontSize = parseInt(getComputedStyle(node2).fontSize, 10);
          const boundingClientRect = node2.getBoundingClientRect();
          width = boundingClientRect.width / computedFontSize;
          height = boundingClientRect.height / computedFontSize;
        }
        if (config.autoA11y && !title) {
          extra.attributes["aria-hidden"] = "true";
        }
        return Promise.resolve([node2, makeLayersTextAbstract({
          content: node2.innerHTML,
          width,
          height,
          transform: transform2,
          title,
          extra,
          watchable: true
        })]);
      };
    }
  };
  var CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
  var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
  var _FONT_FAMILY_WEIGHT_TO_PREFIX = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    FontAwesome: {
      normal: "fas",
      400: "fas"
    }
  }), lt), wa), Yt);
  var FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, key) => {
    acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
    return acc;
  }, {});
  var FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce((acc, fontFamily) => {
    const weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
    acc[fontFamily] = weights[900] || [...Object.entries(weights)][0][1];
    return acc;
  }, {});
  function hexValueFromContent(content) {
    const cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
    const codePoint = codePointAt(cleaned, 0);
    const isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
    const isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
    return {
      value: isDoubled ? toHex(cleaned[0]) : toHex(cleaned),
      isSecondary: isPrependTen || isDoubled
    };
  }
  function getPrefix(fontFamily, fontWeight) {
    const fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, "").toLowerCase();
    const fontWeightInteger = parseInt(fontWeight);
    const fontWeightSanitized = isNaN(fontWeightInteger) ? "normal" : fontWeightInteger;
    return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
  }
  function replaceForPosition(node2, position2) {
    const pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position2.replace(":", "-"));
    return new Promise((resolve2, reject) => {
      if (node2.getAttribute(pendingAttribute) !== null) {
        return resolve2();
      }
      const children = toArray(node2.children);
      const alreadyProcessedPseudoElement = children.filter((c$$1) => c$$1.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position2)[0];
      const styles2 = WINDOW.getComputedStyle(node2, position2);
      const fontFamily = styles2.getPropertyValue("font-family");
      const fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
      const fontWeight = styles2.getPropertyValue("font-weight");
      const content = styles2.getPropertyValue("content");
      if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
        node2.removeChild(alreadyProcessedPseudoElement);
        return resolve2();
      } else if (fontFamilyMatch && content !== "none" && content !== "") {
        const content2 = styles2.getPropertyValue("content");
        let prefix2 = getPrefix(fontFamily, fontWeight);
        const {
          value: hexValue,
          isSecondary
        } = hexValueFromContent(content2);
        const isV4 = fontFamilyMatch[0].startsWith("FontAwesome");
        let iconName = byUnicode(prefix2, hexValue);
        let iconIdentifier = iconName;
        if (isV4) {
          const iconName4 = byOldUnicode(hexValue);
          if (iconName4.iconName && iconName4.prefix) {
            iconName = iconName4.iconName;
            prefix2 = iconName4.prefix;
          }
        }
        if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix2 || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
          node2.setAttribute(pendingAttribute, iconIdentifier);
          if (alreadyProcessedPseudoElement) {
            node2.removeChild(alreadyProcessedPseudoElement);
          }
          const meta = blankMeta();
          const {
            extra
          } = meta;
          extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position2;
          findIcon(iconName, prefix2).then((main) => {
            const abstract2 = makeInlineSvgAbstract(_objectSpread2(_objectSpread2({}, meta), {}, {
              icons: {
                main,
                mask: emptyCanonicalIcon()
              },
              prefix: prefix2,
              iconName: iconIdentifier,
              extra,
              watchable: true
            }));
            const element = DOCUMENT.createElementNS("http://www.w3.org/2000/svg", "svg");
            if (position2 === "::before") {
              node2.insertBefore(element, node2.firstChild);
            } else {
              node2.appendChild(element);
            }
            element.outerHTML = abstract2.map((a$$1) => toHtml(a$$1)).join("\n");
            node2.removeAttribute(pendingAttribute);
            resolve2();
          }).catch(reject);
        } else {
          resolve2();
        }
      } else {
        resolve2();
      }
    });
  }
  function replace3(node2) {
    return Promise.all([replaceForPosition(node2, "::before"), replaceForPosition(node2, "::after")]);
  }
  function processable(node2) {
    return node2.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node2.tagName.toUpperCase()) && !node2.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node2.parentNode || node2.parentNode.tagName !== "svg");
  }
  function searchPseudoElements(root) {
    if (!IS_DOM) return;
    return new Promise((resolve2, reject) => {
      const operations = toArray(root.querySelectorAll("*")).filter(processable).map(replace3);
      const end2 = perf.begin("searchPseudoElements");
      disableObservation();
      Promise.all(operations).then(() => {
        end2();
        enableObservation();
        resolve2();
      }).catch(() => {
        end2();
        enableObservation();
        reject();
      });
    });
  }
  var PseudoElements = {
    hooks() {
      return {
        mutationObserverCallbacks(accumulator) {
          accumulator.pseudoElementsCallback = searchPseudoElements;
          return accumulator;
        }
      };
    },
    provides(providers2) {
      providers2.pseudoElements2svg = function(params) {
        const {
          node: node2 = DOCUMENT
        } = params;
        if (config.searchPseudoElements) {
          searchPseudoElements(node2);
        }
      };
    }
  };
  var _unwatched = false;
  var MutationObserver$1 = {
    mixout() {
      return {
        dom: {
          unwatch() {
            disableObservation();
            _unwatched = true;
          }
        }
      };
    },
    hooks() {
      return {
        bootstrap() {
          observe(chainHooks("mutationObserverCallbacks", {}));
        },
        noAuto() {
          disconnect();
        },
        watch(params) {
          const {
            observeMutationsRoot
          } = params;
          if (_unwatched) {
            enableObservation();
          } else {
            observe(chainHooks("mutationObserverCallbacks", {
              observeMutationsRoot
            }));
          }
        }
      };
    }
  };
  var parseTransformString = (transformString) => {
    let transform2 = {
      size: 16,
      x: 0,
      y: 0,
      flipX: false,
      flipY: false,
      rotate: 0
    };
    return transformString.toLowerCase().split(" ").reduce((acc, n) => {
      const parts = n.toLowerCase().split("-");
      const first = parts[0];
      let rest = parts.slice(1).join("-");
      if (first && rest === "h") {
        acc.flipX = true;
        return acc;
      }
      if (first && rest === "v") {
        acc.flipY = true;
        return acc;
      }
      rest = parseFloat(rest);
      if (isNaN(rest)) {
        return acc;
      }
      switch (first) {
        case "grow":
          acc.size = acc.size + rest;
          break;
        case "shrink":
          acc.size = acc.size - rest;
          break;
        case "left":
          acc.x = acc.x - rest;
          break;
        case "right":
          acc.x = acc.x + rest;
          break;
        case "up":
          acc.y = acc.y - rest;
          break;
        case "down":
          acc.y = acc.y + rest;
          break;
        case "rotate":
          acc.rotate = acc.rotate + rest;
          break;
      }
      return acc;
    }, transform2);
  };
  var PowerTransforms = {
    mixout() {
      return {
        parse: {
          transform: (transformString) => {
            return parseTransformString(transformString);
          }
        }
      };
    },
    hooks() {
      return {
        parseNodeAttributes(accumulator, node2) {
          const transformString = node2.getAttribute("data-fa-transform");
          if (transformString) {
            accumulator.transform = parseTransformString(transformString);
          }
          return accumulator;
        }
      };
    },
    provides(providers2) {
      providers2.generateAbstractTransformGrouping = function(_ref) {
        let {
          main,
          transform: transform2,
          containerWidth,
          iconWidth
        } = _ref;
        const outer = {
          transform: "translate(".concat(containerWidth / 2, " 256)")
        };
        const innerTranslate = "translate(".concat(transform2.x * 32, ", ").concat(transform2.y * 32, ") ");
        const innerScale = "scale(".concat(transform2.size / 16 * (transform2.flipX ? -1 : 1), ", ").concat(transform2.size / 16 * (transform2.flipY ? -1 : 1), ") ");
        const innerRotate = "rotate(".concat(transform2.rotate, " 0 0)");
        const inner = {
          transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
        };
        const path = {
          transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
        };
        const operations = {
          outer,
          inner,
          path
        };
        return {
          tag: "g",
          attributes: _objectSpread2({}, operations.outer),
          children: [{
            tag: "g",
            attributes: _objectSpread2({}, operations.inner),
            children: [{
              tag: main.icon.tag,
              children: main.icon.children,
              attributes: _objectSpread2(_objectSpread2({}, main.icon.attributes), operations.path)
            }]
          }]
        };
      };
    }
  };
  var ALL_SPACE = {
    x: 0,
    y: 0,
    width: "100%",
    height: "100%"
  };
  function fillBlack(abstract2) {
    let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (abstract2.attributes && (abstract2.attributes.fill || force)) {
      abstract2.attributes.fill = "black";
    }
    return abstract2;
  }
  function deGroup(abstract2) {
    if (abstract2.tag === "g") {
      return abstract2.children;
    } else {
      return [abstract2];
    }
  }
  var Masks = {
    hooks() {
      return {
        parseNodeAttributes(accumulator, node2) {
          const maskData = node2.getAttribute("data-fa-mask");
          const mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map((i) => i.trim()));
          if (!mask.prefix) {
            mask.prefix = getDefaultUsablePrefix();
          }
          accumulator.mask = mask;
          accumulator.maskId = node2.getAttribute("data-fa-mask-id");
          return accumulator;
        }
      };
    },
    provides(providers2) {
      providers2.generateAbstractMask = function(_ref) {
        let {
          children,
          attributes,
          main,
          mask,
          maskId: explicitMaskId,
          transform: transform2
        } = _ref;
        const {
          width: mainWidth,
          icon: mainPath
        } = main;
        const {
          width: maskWidth,
          icon: maskPath
        } = mask;
        const trans = transformForSvg({
          transform: transform2,
          containerWidth: maskWidth,
          iconWidth: mainWidth
        });
        const maskRect = {
          tag: "rect",
          attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
            fill: "white"
          })
        };
        const maskInnerGroupChildrenMixin = mainPath.children ? {
          children: mainPath.children.map(fillBlack)
        } : {};
        const maskInnerGroup = {
          tag: "g",
          attributes: _objectSpread2({}, trans.inner),
          children: [fillBlack(_objectSpread2({
            tag: mainPath.tag,
            attributes: _objectSpread2(_objectSpread2({}, mainPath.attributes), trans.path)
          }, maskInnerGroupChildrenMixin))]
        };
        const maskOuterGroup = {
          tag: "g",
          attributes: _objectSpread2({}, trans.outer),
          children: [maskInnerGroup]
        };
        const maskId = "mask-".concat(explicitMaskId || nextUniqueId());
        const clipId = "clip-".concat(explicitMaskId || nextUniqueId());
        const maskTag = {
          tag: "mask",
          attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
            id: maskId,
            maskUnits: "userSpaceOnUse",
            maskContentUnits: "userSpaceOnUse"
          }),
          children: [maskRect, maskOuterGroup]
        };
        const defs = {
          tag: "defs",
          children: [{
            tag: "clipPath",
            attributes: {
              id: clipId
            },
            children: deGroup(maskPath)
          }, maskTag]
        };
        children.push(defs, {
          tag: "rect",
          attributes: _objectSpread2({
            fill: "currentColor",
            "clip-path": "url(#".concat(clipId, ")"),
            mask: "url(#".concat(maskId, ")")
          }, ALL_SPACE)
        });
        return {
          children,
          attributes
        };
      };
    }
  };
  var MissingIconIndicator = {
    provides(providers2) {
      let reduceMotion = false;
      if (WINDOW.matchMedia) {
        reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
      }
      providers2.missingIconAbstract = function() {
        const gChildren = [];
        const FILL = {
          fill: "currentColor"
        };
        const ANIMATION_BASE = {
          attributeType: "XML",
          repeatCount: "indefinite",
          dur: "2s"
        };
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
          })
        });
        const OPACITY_ANIMATE = _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
          attributeName: "opacity"
        });
        const dot = {
          tag: "circle",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            cx: "256",
            cy: "364",
            r: "28"
          }),
          children: []
        };
        if (!reduceMotion) {
          dot.children.push({
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
              attributeName: "r",
              values: "28;14;28;28;14;28;"
            })
          }, {
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: "1;0;1;1;0;1;"
            })
          });
        }
        gChildren.push(dot);
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            opacity: "1",
            d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
          }),
          children: reduceMotion ? [] : [{
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: "1;0;0;0;0;1;"
            })
          }]
        });
        if (!reduceMotion) {
          gChildren.push({
            tag: "path",
            attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
              opacity: "0",
              d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
            }),
            children: [{
              tag: "animate",
              attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
                values: "0;0;1;1;0;0;"
              })
            }]
          });
        }
        return {
          tag: "g",
          attributes: {
            "class": "missing"
          },
          children: gChildren
        };
      };
    }
  };
  var SvgSymbols = {
    hooks() {
      return {
        parseNodeAttributes(accumulator, node2) {
          const symbolData = node2.getAttribute("data-fa-symbol");
          const symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
          accumulator["symbol"] = symbol;
          return accumulator;
        }
      };
    }
  };
  var plugins2 = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
  registerPlugins(plugins2, {
    mixoutsTo: api2
  });
  var noAuto$1 = api2.noAuto;
  var config$1 = api2.config;
  var library$1 = api2.library;
  var dom$1 = api2.dom;
  var parse$1 = api2.parse;
  var findIconDefinition$1 = api2.findIconDefinition;
  var toHtml$1 = api2.toHtml;
  var icon = api2.icon;
  var layer = api2.layer;
  var text = api2.text;
  var counter = api2.counter;

  // node_modules/@fortawesome/react-fontawesome/index.es.js
  var import_prop_types4 = __toESM(require_prop_types());
  var import_react12 = __toESM(require_react());
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread22(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutPropertiesLoose2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose2(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2) return;
    if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
    var n = Object.prototype.toString.call(o2).slice(8, -1);
    if (n === "Object" && o2.constructor) n = o2.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o2);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o2, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function classList(props) {
    var _classes;
    var beat = props.beat, fade = props.fade, beatFade = props.beatFade, bounce = props.bounce, shake = props.shake, flash = props.flash, spin = props.spin, spinPulse = props.spinPulse, spinReverse = props.spinReverse, pulse = props.pulse, fixedWidth = props.fixedWidth, inverse = props.inverse, border = props.border, listItem = props.listItem, flip = props.flip, size = props.size, rotation = props.rotation, pull = props.pull;
    var classes = (_classes = {
      "fa-beat": beat,
      "fa-fade": fade,
      "fa-beat-fade": beatFade,
      "fa-bounce": bounce,
      "fa-shake": shake,
      "fa-flash": flash,
      "fa-spin": spin,
      "fa-spin-reverse": spinReverse,
      "fa-spin-pulse": spinPulse,
      "fa-pulse": pulse,
      "fa-fw": fixedWidth,
      "fa-inverse": inverse,
      "fa-border": border,
      "fa-li": listItem,
      "fa-flip": flip === true,
      "fa-flip-horizontal": flip === "horizontal" || flip === "both",
      "fa-flip-vertical": flip === "vertical" || flip === "both"
    }, _defineProperty2(_classes, "fa-".concat(size), typeof size !== "undefined" && size !== null), _defineProperty2(_classes, "fa-rotate-".concat(rotation), typeof rotation !== "undefined" && rotation !== null && rotation !== 0), _defineProperty2(_classes, "fa-pull-".concat(pull), typeof pull !== "undefined" && pull !== null), _defineProperty2(_classes, "fa-swap-opacity", props.swapOpacity), _classes);
    return Object.keys(classes).map(function(key) {
      return classes[key] ? key : null;
    }).filter(function(key) {
      return key;
    });
  }
  function _isNumerical(obj) {
    obj = obj - 0;
    return obj === obj;
  }
  function camelize(string) {
    if (_isNumerical(string)) {
      return string;
    }
    string = string.replace(/[\-_\s]+(.)?/g, function(match2, chr) {
      return chr ? chr.toUpperCase() : "";
    });
    return string.substr(0, 1).toLowerCase() + string.substr(1);
  }
  var _excluded = ["style"];
  function capitalize2(val) {
    return val.charAt(0).toUpperCase() + val.slice(1);
  }
  function styleToObject(style) {
    return style.split(";").map(function(s2) {
      return s2.trim();
    }).filter(function(s2) {
      return s2;
    }).reduce(function(acc, pair) {
      var i = pair.indexOf(":");
      var prop = camelize(pair.slice(0, i));
      var value = pair.slice(i + 1).trim();
      prop.startsWith("webkit") ? acc[capitalize2(prop)] = value : acc[prop] = value;
      return acc;
    }, {});
  }
  function convert(createElement15, element) {
    var extraProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof element === "string") {
      return element;
    }
    var children = (element.children || []).map(function(child) {
      return convert(createElement15, child);
    });
    var mixins = Object.keys(element.attributes || {}).reduce(function(acc, key) {
      var val = element.attributes[key];
      switch (key) {
        case "class":
          acc.attrs["className"] = val;
          delete element.attributes["class"];
          break;
        case "style":
          acc.attrs["style"] = styleToObject(val);
          break;
        default:
          if (key.indexOf("aria-") === 0 || key.indexOf("data-") === 0) {
            acc.attrs[key.toLowerCase()] = val;
          } else {
            acc.attrs[camelize(key)] = val;
          }
      }
      return acc;
    }, {
      attrs: {}
    });
    var _extraProps$style = extraProps.style, existingStyle = _extraProps$style === void 0 ? {} : _extraProps$style, remaining = _objectWithoutProperties(extraProps, _excluded);
    mixins.attrs["style"] = _objectSpread22(_objectSpread22({}, mixins.attrs["style"]), existingStyle);
    return createElement15.apply(void 0, [element.tag, _objectSpread22(_objectSpread22({}, mixins.attrs), remaining)].concat(_toConsumableArray(children)));
  }
  var PRODUCTION2 = false;
  try {
    PRODUCTION2 = false;
  } catch (e) {
  }
  function log() {
    if (!PRODUCTION2 && console && typeof console.error === "function") {
      var _console;
      (_console = console).error.apply(_console, arguments);
    }
  }
  function normalizeIconArgs(icon2) {
    if (icon2 && _typeof(icon2) === "object" && icon2.prefix && icon2.iconName && icon2.icon) {
      return icon2;
    }
    if (parse$1.icon) {
      return parse$1.icon(icon2);
    }
    if (icon2 === null) {
      return null;
    }
    if (icon2 && _typeof(icon2) === "object" && icon2.prefix && icon2.iconName) {
      return icon2;
    }
    if (Array.isArray(icon2) && icon2.length === 2) {
      return {
        prefix: icon2[0],
        iconName: icon2[1]
      };
    }
    if (typeof icon2 === "string") {
      return {
        prefix: "fas",
        iconName: icon2
      };
    }
  }
  function objectWithKey(key, value) {
    return Array.isArray(value) && value.length > 0 || !Array.isArray(value) && value ? _defineProperty2({}, key, value) : {};
  }
  var defaultProps = {
    border: false,
    className: "",
    mask: null,
    maskId: null,
    fixedWidth: false,
    inverse: false,
    flip: false,
    icon: null,
    listItem: false,
    pull: null,
    pulse: false,
    rotation: null,
    size: null,
    spin: false,
    spinPulse: false,
    spinReverse: false,
    beat: false,
    fade: false,
    beatFade: false,
    bounce: false,
    shake: false,
    symbol: false,
    title: "",
    titleId: null,
    transform: null,
    swapOpacity: false
  };
  var FontAwesomeIcon = /* @__PURE__ */ import_react12.default.forwardRef(function(props, ref) {
    var allProps = _objectSpread22(_objectSpread22({}, defaultProps), props);
    var iconArgs = allProps.icon, maskArgs = allProps.mask, symbol = allProps.symbol, className = allProps.className, title = allProps.title, titleId = allProps.titleId, maskId = allProps.maskId;
    var iconLookup = normalizeIconArgs(iconArgs);
    var classes = objectWithKey("classes", [].concat(_toConsumableArray(classList(allProps)), _toConsumableArray((className || "").split(" "))));
    var transform2 = objectWithKey("transform", typeof allProps.transform === "string" ? parse$1.transform(allProps.transform) : allProps.transform);
    var mask = objectWithKey("mask", normalizeIconArgs(maskArgs));
    var renderedIcon = icon(iconLookup, _objectSpread22(_objectSpread22(_objectSpread22(_objectSpread22({}, classes), transform2), mask), {}, {
      symbol,
      title,
      titleId,
      maskId
    }));
    if (!renderedIcon) {
      log("Could not find icon", iconLookup);
      return null;
    }
    var abstract2 = renderedIcon.abstract;
    var extraProps = {
      ref
    };
    Object.keys(allProps).forEach(function(key) {
      if (!defaultProps.hasOwnProperty(key)) {
        extraProps[key] = allProps[key];
      }
    });
    return convertCurry(abstract2[0], extraProps);
  });
  FontAwesomeIcon.displayName = "FontAwesomeIcon";
  FontAwesomeIcon.propTypes = {
    beat: import_prop_types4.default.bool,
    border: import_prop_types4.default.bool,
    beatFade: import_prop_types4.default.bool,
    bounce: import_prop_types4.default.bool,
    className: import_prop_types4.default.string,
    fade: import_prop_types4.default.bool,
    flash: import_prop_types4.default.bool,
    mask: import_prop_types4.default.oneOfType([import_prop_types4.default.object, import_prop_types4.default.array, import_prop_types4.default.string]),
    maskId: import_prop_types4.default.string,
    fixedWidth: import_prop_types4.default.bool,
    inverse: import_prop_types4.default.bool,
    flip: import_prop_types4.default.oneOf([true, false, "horizontal", "vertical", "both"]),
    icon: import_prop_types4.default.oneOfType([import_prop_types4.default.object, import_prop_types4.default.array, import_prop_types4.default.string]),
    listItem: import_prop_types4.default.bool,
    pull: import_prop_types4.default.oneOf(["right", "left"]),
    pulse: import_prop_types4.default.bool,
    rotation: import_prop_types4.default.oneOf([0, 90, 180, 270]),
    shake: import_prop_types4.default.bool,
    size: import_prop_types4.default.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
    spin: import_prop_types4.default.bool,
    spinPulse: import_prop_types4.default.bool,
    spinReverse: import_prop_types4.default.bool,
    symbol: import_prop_types4.default.oneOfType([import_prop_types4.default.bool, import_prop_types4.default.string]),
    title: import_prop_types4.default.string,
    titleId: import_prop_types4.default.string,
    transform: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.object]),
    swapOpacity: import_prop_types4.default.bool
  };
  var convertCurry = convert.bind(null, import_react12.default.createElement);

  // node_modules/@fortawesome/free-solid-svg-icons/index.mjs
  var faFileCsv = {
    prefix: "fas",
    iconName: "file-csv",
    icon: [512, 512, [], "f6dd", "M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 144-208 0c-35.3 0-64 28.7-64 64l0 144-48 0c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128zM200 352l16 0c22.1 0 40 17.9 40 40l0 8c0 8.8-7.2 16-16 16s-16-7.2-16-16l0-8c0-4.4-3.6-8-8-8l-16 0c-4.4 0-8 3.6-8 8l0 80c0 4.4 3.6 8 8 8l16 0c4.4 0 8-3.6 8-8l0-8c0-8.8 7.2-16 16-16s16 7.2 16 16l0 8c0 22.1-17.9 40-40 40l-16 0c-22.1 0-40-17.9-40-40l0-80c0-22.1 17.9-40 40-40zm133.1 0l34.9 0c8.8 0 16 7.2 16 16s-7.2 16-16 16l-34.9 0c-7.2 0-13.1 5.9-13.1 13.1c0 5.2 3 9.9 7.8 12l37.4 16.6c16.3 7.2 26.8 23.4 26.8 41.2c0 24.9-20.2 45.1-45.1 45.1L304 512c-8.8 0-16-7.2-16-16s7.2-16 16-16l42.9 0c7.2 0 13.1-5.9 13.1-13.1c0-5.2-3-9.9-7.8-12l-37.4-16.6c-16.3-7.2-26.8-23.4-26.8-41.2c0-24.9 20.2-45.1 45.1-45.1zm98.9 0c8.8 0 16 7.2 16 16l0 31.6c0 23 5.5 45.6 16 66c10.5-20.3 16-42.9 16-66l0-31.6c0-8.8 7.2-16 16-16s16 7.2 16 16l0 31.6c0 34.7-10.3 68.7-29.6 97.6l-5.1 7.7c-3 4.5-8 7.1-13.3 7.1s-10.3-2.7-13.3-7.1l-5.1-7.7c-19.3-28.9-29.6-62.9-29.6-97.6l0-31.6c0-8.8 7.2-16 16-16z"]
  };
  var faAsterisk = {
    prefix: "fas",
    iconName: "asterisk",
    icon: [384, 512, [10033, 61545], "2a", "M192 32c17.7 0 32 14.3 32 32l0 135.5 111.5-66.9c15.2-9.1 34.8-4.2 43.9 11s4.2 34.8-11 43.9L254.2 256l114.3 68.6c15.2 9.1 20.1 28.7 11 43.9s-28.7 20.1-43.9 11L224 312.5 224 448c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-135.5L48.5 379.4c-15.2 9.1-34.8 4.2-43.9-11s-4.2-34.8 11-43.9L129.8 256 15.5 187.4c-15.2-9.1-20.1-28.7-11-43.9s28.7-20.1 43.9-11L160 199.5 160 64c0-17.7 14.3-32 32-32z"]
  };
  var faChartSimple = {
    prefix: "fas",
    iconName: "chart-simple",
    icon: [448, 512, [], "e473", "M160 80c0-26.5 21.5-48 48-48l32 0c26.5 0 48 21.5 48 48l0 352c0 26.5-21.5 48-48 48l-32 0c-26.5 0-48-21.5-48-48l0-352zM0 272c0-26.5 21.5-48 48-48l32 0c26.5 0 48 21.5 48 48l0 160c0 26.5-21.5 48-48 48l-32 0c-26.5 0-48-21.5-48-48L0 272zM368 96l32 0c26.5 0 48 21.5 48 48l0 288c0 26.5-21.5 48-48 48l-32 0c-26.5 0-48-21.5-48-48l0-288c0-26.5 21.5-48 48-48z"]
  };
  var faUserGroup = {
    prefix: "fas",
    iconName: "user-group",
    icon: [640, 512, [128101, "user-friends"], "f500", "M96 128a128 128 0 1 1 256 0A128 128 0 1 1 96 128zM0 482.3C0 383.8 79.8 304 178.3 304l91.4 0C368.2 304 448 383.8 448 482.3c0 16.4-13.3 29.7-29.7 29.7L29.7 512C13.3 512 0 498.7 0 482.3zM609.3 512l-137.8 0c5.4-9.4 8.6-20.3 8.6-32l0-8c0-60.7-27.1-115.2-69.8-151.8c2.4-.1 4.7-.2 7.1-.2l61.4 0C567.8 320 640 392.2 640 481.3c0 17-13.8 30.7-30.7 30.7zM432 256c-31 0-59-12.6-79.3-32.9C372.4 196.5 384 163.6 384 128c0-26.8-6.6-52.1-18.3-74.3C384.3 40.1 407.2 32 432 32c61.9 0 112 50.1 112 112s-50.1 112-112 112z"]
  };
  var faHandshake = {
    prefix: "fas",
    iconName: "handshake",
    icon: [640, 512, [], "f2b5", "M323.4 85.2l-96.8 78.4c-16.1 13-19.2 36.4-7 53.1c12.9 17.8 38 21.3 55.3 7.8l99.3-77.2c7-5.4 17-4.2 22.5 2.8s4.2 17-2.8 22.5l-20.9 16.2L512 316.8 512 128l-.7 0-3.9-2.5L434.8 79c-15.3-9.8-33.2-15-51.4-15c-21.8 0-43 7.5-60 21.2zm22.8 124.4l-51.7 40.2C263 274.4 217.3 268 193.7 235.6c-22.2-30.5-16.6-73.1 12.7-96.8l83.2-67.3c-11.6-4.9-24.1-7.4-36.8-7.4C234 64 215.7 69.6 200 80l-72 48 0 224 28.2 0 91.4 83.4c19.6 17.9 49.9 16.5 67.8-3.1c5.5-6.1 9.2-13.2 11.1-20.6l17 15.6c19.5 17.9 49.9 16.6 67.8-2.9c4.5-4.9 7.8-10.6 9.9-16.5c19.4 13 45.8 10.3 62.1-7.5c17.9-19.5 16.6-49.9-2.9-67.8l-134.2-123zM16 128c-8.8 0-16 7.2-16 16L0 352c0 17.7 14.3 32 32 32l32 0c17.7 0 32-14.3 32-32l0-224-80 0zM48 320a16 16 0 1 1 0 32 16 16 0 1 1 0-32zM544 128l0 224c0 17.7 14.3 32 32 32l32 0c17.7 0 32-14.3 32-32l0-208c0-8.8-7.2-16-16-16l-80 0zm32 208a16 16 0 1 1 32 0 16 16 0 1 1 -32 0z"]
  };
  var faFilter = {
    prefix: "fas",
    iconName: "filter",
    icon: [512, 512, [], "f0b0", "M3.9 54.9C10.5 40.9 24.5 32 40 32l432 0c15.5 0 29.5 8.9 36.1 22.9s4.6 30.5-5.2 42.5L320 320.9 320 448c0 12.1-6.8 23.2-17.7 28.6s-23.8 4.3-33.5-3l-64-48c-8.1-6-12.8-15.5-12.8-25.6l0-79.1L9 97.3C-.7 85.4-2.8 68.8 3.9 54.9z"]
  };
  var faChartLine = {
    prefix: "fas",
    iconName: "chart-line",
    icon: [512, 512, ["line-chart"], "f201", "M64 64c0-17.7-14.3-32-32-32S0 46.3 0 64L0 400c0 44.2 35.8 80 80 80l400 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L80 416c-8.8 0-16-7.2-16-16L64 64zm406.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L320 210.7l-57.4-57.4c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L240 221.3l57.4 57.4c12.5 12.5 32.8 12.5 45.3 0l128-128z"]
  };
  var faArrowRight = {
    prefix: "fas",
    iconName: "arrow-right",
    icon: [448, 512, [8594], "f061", "M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"]
  };
  var faCircleQuestion = {
    prefix: "fas",
    iconName: "circle-question",
    icon: [512, 512, [62108, "question-circle"], "f059", "M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM169.8 165.3c7.9-22.3 29.1-37.3 52.8-37.3l58.3 0c34.9 0 63.1 28.3 63.1 63.1c0 22.6-12.1 43.5-31.7 54.8L280 264.4c-.2 13-10.9 23.6-24 23.6c-13.3 0-24-10.7-24-24l0-13.5c0-8.6 4.6-16.5 12.1-20.8l44.3-25.4c4.7-2.7 7.6-7.7 7.6-13.1c0-8.4-6.8-15.1-15.1-15.1l-58.3 0c-3.4 0-6.4 2.1-7.5 5.3l-.4 1.2c-4.4 12.5-18.2 19-30.6 14.6s-19-18.2-14.6-30.6l.4-1.2zM224 352a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"]
  };
  var faArrowLeft = {
    prefix: "fas",
    iconName: "arrow-left",
    icon: [448, 512, [8592], "f060", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"]
  };
  var faLandmark = {
    prefix: "fas",
    iconName: "landmark",
    icon: [512, 512, [127963], "f66f", "M240.1 4.2c9.8-5.6 21.9-5.6 31.8 0l171.8 98.1L448 104l0 .9 47.9 27.4c12.6 7.2 18.8 22 15.1 36s-16.4 23.8-30.9 23.8L32 192c-14.5 0-27.2-9.8-30.9-23.8s2.5-28.8 15.1-36L64 104.9l0-.9 4.4-1.6L240.1 4.2zM64 224l64 0 0 192 40 0 0-192 64 0 0 192 48 0 0-192 64 0 0 192 40 0 0-192 64 0 0 196.3c.6 .3 1.2 .7 1.8 1.1l48 32c11.7 7.8 17 22.4 12.9 35.9S494.1 512 480 512L32 512c-14.1 0-26.5-9.2-30.6-22.7s1.1-28.1 12.9-35.9l48-32c.6-.4 1.2-.7 1.8-1.1L64 224z"]
  };
  var faArrowDown = {
    prefix: "fas",
    iconName: "arrow-down",
    icon: [384, 512, [8595], "f063", "M169.4 470.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 370.8 224 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 306.7L54.6 265.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z"]
  };
  var faLink = {
    prefix: "fas",
    iconName: "link",
    icon: [640, 512, [128279, "chain"], "f0c1", "M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z"]
  };
  var faArrowUp = {
    prefix: "fas",
    iconName: "arrow-up",
    icon: [384, 512, [8593], "f062", "M214.6 41.4c-12.5-12.5-32.8-12.5-45.3 0l-160 160c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L160 141.2 160 448c0 17.7 14.3 32 32 32s32-14.3 32-32l0-306.7L329.4 246.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3l-160-160z"]
  };
  var faChevronRight = {
    prefix: "fas",
    iconName: "chevron-right",
    icon: [320, 512, [9002], "f054", "M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
  };
  var faThumbtack = {
    prefix: "fas",
    iconName: "thumbtack",
    icon: [384, 512, [128204, 128392, "thumb-tack"], "f08d", "M32 32C32 14.3 46.3 0 64 0L320 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-29.5 0 11.4 148.2c36.7 19.9 65.7 53.2 79.5 94.7l1 3c3.3 9.8 1.6 20.5-4.4 28.8s-15.7 13.3-26 13.3L32 352c-10.3 0-19.9-4.9-26-13.3s-7.7-19.1-4.4-28.8l1-3c13.8-41.5 42.8-74.8 79.5-94.7L93.5 64 64 64C46.3 64 32 49.7 32 32zM160 384l64 0 0 96c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-96z"]
  };
  var faTrophy = {
    prefix: "fas",
    iconName: "trophy",
    icon: [576, 512, [127942], "f091", "M400 0L176 0c-26.5 0-48.1 21.8-47.1 48.2c.2 5.3 .4 10.6 .7 15.8L24 64C10.7 64 0 74.7 0 88c0 92.6 33.5 157 78.5 200.7c44.3 43.1 98.3 64.8 138.1 75.8c23.4 6.5 39.4 26 39.4 45.6c0 20.9-17 37.9-37.9 37.9L192 448c-17.7 0-32 14.3-32 32s14.3 32 32 32l192 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-26.1 0C337 448 320 431 320 410.1c0-19.6 15.9-39.2 39.4-45.6c39.9-11 93.9-32.7 138.2-75.8C542.5 245 576 180.6 576 88c0-13.3-10.7-24-24-24L446.4 64c.3-5.2 .5-10.4 .7-15.8C448.1 21.8 426.5 0 400 0zM48.9 112l84.4 0c9.1 90.1 29.2 150.3 51.9 190.6c-24.9-11-50.8-26.5-73.2-48.3c-32-31.1-58-76-63-142.3zM464.1 254.3c-22.4 21.8-48.3 37.3-73.2 48.3c22.7-40.3 42.8-100.5 51.9-190.6l84.4 0c-5.1 66.3-31.1 111.2-63 142.3z"]
  };
  var faBuilding = {
    prefix: "fas",
    iconName: "building",
    icon: [384, 512, [127970, 61687], "f1ad", "M48 0C21.5 0 0 21.5 0 48L0 464c0 26.5 21.5 48 48 48l96 0 0-80c0-26.5 21.5-48 48-48s48 21.5 48 48l0 80 96 0c26.5 0 48-21.5 48-48l0-416c0-26.5-21.5-48-48-48L48 0zM64 240c0-8.8 7.2-16 16-16l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32zm112-16l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32c0-8.8 7.2-16 16-16zm80 16c0-8.8 7.2-16 16-16l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32zM80 96l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32c0-8.8 7.2-16 16-16zm80 16c0-8.8 7.2-16 16-16l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32zM272 96l32 0c8.8 0 16 7.2 16 16l0 32c0 8.8-7.2 16-16 16l-32 0c-8.8 0-16-7.2-16-16l0-32c0-8.8 7.2-16 16-16z"]
  };
  var faCheck = {
    prefix: "fas",
    iconName: "check",
    icon: [448, 512, [10003, 10004], "f00c", "M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"]
  };
  var faBriefcase = {
    prefix: "fas",
    iconName: "briefcase",
    icon: [512, 512, [128188], "f0b1", "M184 48l144 0c4.4 0 8 3.6 8 8l0 40L176 96l0-40c0-4.4 3.6-8 8-8zm-56 8l0 40L64 96C28.7 96 0 124.7 0 160l0 96 192 0 128 0 192 0 0-96c0-35.3-28.7-64-64-64l-64 0 0-40c0-30.9-25.1-56-56-56L184 0c-30.9 0-56 25.1-56 56zM512 288l-192 0 0 32c0 17.7-14.3 32-32 32l-64 0c-17.7 0-32-14.3-32-32l0-32L0 288 0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-128z"]
  };
  var faTriangleExclamation = {
    prefix: "fas",
    iconName: "triangle-exclamation",
    icon: [512, 512, [9888, "exclamation-triangle", "warning"], "f071", "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480L40 480c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24l0 112c0 13.3 10.7 24 24 24s24-10.7 24-24l0-112c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"]
  };
  var faDatabase = {
    prefix: "fas",
    iconName: "database",
    icon: [448, 512, [], "f1c0", "M448 80l0 48c0 44.2-100.3 80-224 80S0 172.2 0 128L0 80C0 35.8 100.3 0 224 0S448 35.8 448 80zM393.2 214.7c20.8-7.4 39.9-16.9 54.8-28.6L448 288c0 44.2-100.3 80-224 80S0 332.2 0 288L0 186.1c14.9 11.8 34 21.2 54.8 28.6C99.7 230.7 159.5 240 224 240s124.3-9.3 169.2-25.3zM0 346.1c14.9 11.8 34 21.2 54.8 28.6C99.7 390.7 159.5 400 224 400s124.3-9.3 169.2-25.3c20.8-7.4 39.9-16.9 54.8-28.6l0 85.9c0 44.2-100.3 80-224 80S0 476.2 0 432l0-85.9z"]
  };
  var faUserLarge = {
    prefix: "fas",
    iconName: "user-large",
    icon: [512, 512, ["user-alt"], "f406", "M256 288A144 144 0 1 0 256 0a144 144 0 1 0 0 288zm-94.7 32C72.2 320 0 392.2 0 481.3c0 17 13.8 30.7 30.7 30.7l450.6 0c17 0 30.7-13.8 30.7-30.7C512 392.2 439.8 320 350.7 320l-189.4 0z"]
  };

  // node_modules/@fortawesome/free-regular-svg-icons/index.mjs
  var faCalendar = {
    prefix: "far",
    iconName: "calendar",
    icon: [448, 512, [128197, 128198], "f133", "M152 24c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40L64 64C28.7 64 0 92.7 0 128l0 16 0 48L0 448c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-256 0-48 0-16c0-35.3-28.7-64-64-64l-40 0 0-40c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 40L152 64l0-40zM48 192l352 0 0 256c0 8.8-7.2 16-16 16L64 464c-8.8 0-16-7.2-16-16l0-256z"]
  };

  // assets/scripts/components/icon.tsx
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  library$1.add(
    faArrowDown,
    faArrowLeft,
    faArrowRight,
    faArrowUp,
    faAsterisk,
    faBriefcase,
    faBuilding,
    faCalendar,
    faChartLine,
    faChartSimple,
    faCheck,
    faChevronRight,
    faCircleQuestion,
    faDatabase,
    faFileCsv,
    faFilter,
    faHandshake,
    faLandmark,
    faLink,
    faThumbtack,
    faTriangleExclamation,
    faTrophy,
    faUserGroup,
    faUserLarge
  );
  var SetForIcon = /* @__PURE__ */ ((SetForIcon2) => {
    SetForIcon2["arrow-down"] = "fas" /* Solid */;
    SetForIcon2["arrow-left"] = "fas" /* Solid */;
    SetForIcon2["arrow-right"] = "fas" /* Solid */;
    SetForIcon2["arrow-up"] = "fas" /* Solid */;
    SetForIcon2["asterisk"] = "fas" /* Solid */;
    SetForIcon2["briefcase"] = "fas" /* Solid */;
    SetForIcon2["building"] = "fas" /* Solid */;
    SetForIcon2["calendar"] = "far" /* Regular */;
    SetForIcon2["chart-line"] = "fas" /* Solid */;
    SetForIcon2["chart-simple"] = "fas" /* Solid */;
    SetForIcon2["check"] = "fas" /* Solid */;
    SetForIcon2["chevron-right"] = "fas" /* Solid */;
    SetForIcon2["circle-question"] = "fas" /* Solid */;
    SetForIcon2["database"] = "fas" /* Solid */;
    SetForIcon2["file-csv"] = "fas" /* Solid */;
    SetForIcon2["filter"] = "fas" /* Solid */;
    SetForIcon2["handshake"] = "fas" /* Solid */;
    SetForIcon2["landmark"] = "fas" /* Solid */;
    SetForIcon2["link"] = "fas" /* Solid */;
    SetForIcon2["thumbtack"] = "fas" /* Solid */;
    SetForIcon2["triangle-exclamation"] = "fas" /* Solid */;
    SetForIcon2["trophy"] = "fas" /* Solid */;
    SetForIcon2["user-group"] = "fas" /* Solid */;
    SetForIcon2["user-large"] = "fas" /* Solid */;
    return SetForIcon2;
  })(SetForIcon || {});
  var Icon = ({ className, name, size = "lg" }) => {
    const set7 = SetForIcon[name];
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("span", { className: cx(`icon icon-${name}`, className), children: /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(FontAwesomeIcon, { icon: [set7, name], size }) });
  };
  var icon_default = Icon;

  // assets/scripts/components/item-text-with-icon.tsx
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  var ItemTextWithIcon = ({
    after = false,
    children,
    icon: icon2
  }) => /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { className: "item-text-with-icon", children: after ? /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { className: "item-text", children }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(icon_default, { name: icon2 })
  ] }) : /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(icon_default, { name: icon2 }),
    /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("span", { className: "item-text", children })
  ] }) });
  var item_text_with_icon_default = ItemTextWithIcon;

  // assets/scripts/lib/array.ts
  var unique = (arr) => [...new Set(arr)];

  // assets/scripts/components/alert.tsx
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());
  var isObject3 = (alert) => typeof alert === "object";
  var getHasCustomMessage = (alert) => isObject3 && Boolean(alert.customMessage);
  var getHasMessage = (alert) => isObject3 && Boolean(alert.message);
  var getHasStatus = (alert) => isObject3 && Boolean(alert.status);
  var MessageContent = ({ alert }) => {
    const hasMessage = getHasMessage(alert);
    const hasStatus = getHasStatus(alert);
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
      hasStatus && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("strong", { children: alert.status }),
      hasStatus && hasMessage && " ",
      hasMessage && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { dangerouslySetInnerHTML: { __html: alert.message } }),
      !hasStatus && !hasMessage && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("span", { children: "Something went wrong" })
    ] });
  };
  var AlertMessageContent = ({ alert }) => {
    const hasCustomMessage = getHasCustomMessage(alert);
    return hasCustomMessage ? /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
        "p",
        {
          className: "message-content",
          dangerouslySetInnerHTML: { __html: alert.customMessage }
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("p", { className: "original-message-content", children: [
        "(",
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(MessageContent, { alert }),
        ")"
      ] })
    ] }) : /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("p", { className: "message-content", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(MessageContent, { alert }) });
  };
  var Alert = ({
    alerts,
    deactivate,
    grade,
    isActive
  }) => {
    const ref = (0, import_react13.useRef)();
    const iconName = ["error", "warning"].includes(grade) ? "triangle-exclamation" : "asterisk";
    const classNames = unique(["alert-message", `alert-${grade}`]).join(" ");
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
      CSSTransition_default,
      {
        timeout: 250,
        classNames: "alert",
        in: isActive,
        nodeRef: ref,
        unmountOnExit: true,
        children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
          alert_portal_default,
          {
            deactivate,
            isActive,
            ref,
            children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("section", { className: classNames, children: [
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("header", { className: "alert-header", children: /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("h4", { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(item_text_with_icon_default, { icon: iconName, children: [
                grade === "error" && "Error",
                grade === "message" && "Message",
                grade === "warning" && "Warning"
              ] }) }) }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("main", { className: "alert-main", children: alerts.map((alert, i) => /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(AlertMessageContent, { alert }, i)) }),
              /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("footer", { className: "alert-footer", children: "Click anywhere to exit." })
            ] })
          }
        )
      }
    );
  };
  var alert_default = Alert;

  // assets/scripts/components/alert-error.tsx
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var AlertError = () => {
    const [isActive, setIsActive] = (0, import_react14.useState)(false);
    const dispatch = useDispatch();
    const deactivate = () => {
      setIsActive(false);
      setTimeout(() => {
        dispatch(actions2.clearErrors());
      }, 250);
    };
    const alerts = useSelector(getErrors);
    const hasAlerts = alerts.length > 0;
    (0, import_react14.useEffect)(() => {
      if (hasAlerts) {
        setIsActive(true);
      }
    }, [hasAlerts]);
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(
      alert_default,
      {
        alerts,
        deactivate,
        grade: "error",
        isActive
      }
    );
  };
  var alert_error_default = AlertError;

  // assets/scripts/components/app.tsx
  var import_react25 = __toESM(require_react());

  // node_modules/react-helmet/es/Helmet.js
  var import_prop_types5 = __toESM(require_prop_types());
  var import_react_side_effect = __toESM(require_lib());
  var import_react_fast_compare = __toESM(require_react_fast_compare());
  var import_react15 = __toESM(require_react());
  var import_object_assign = __toESM(require_object_assign());
  var ATTRIBUTE_NAMES = {
    BODY: "bodyAttributes",
    HTML: "htmlAttributes",
    TITLE: "titleAttributes"
  };
  var TAG_NAMES = {
    BASE: "base",
    BODY: "body",
    HEAD: "head",
    HTML: "html",
    LINK: "link",
    META: "meta",
    NOSCRIPT: "noscript",
    SCRIPT: "script",
    STYLE: "style",
    TITLE: "title"
  };
  var VALID_TAG_NAMES = Object.keys(TAG_NAMES).map(function(name) {
    return TAG_NAMES[name];
  });
  var TAG_PROPERTIES = {
    CHARSET: "charset",
    CSS_TEXT: "cssText",
    HREF: "href",
    HTTPEQUIV: "http-equiv",
    INNER_HTML: "innerHTML",
    ITEM_PROP: "itemprop",
    NAME: "name",
    PROPERTY: "property",
    REL: "rel",
    SRC: "src",
    TARGET: "target"
  };
  var REACT_TAG_MAP = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex"
  };
  var HELMET_PROPS = {
    DEFAULT_TITLE: "defaultTitle",
    DEFER: "defer",
    ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
    ON_CHANGE_CLIENT_STATE: "onChangeClientState",
    TITLE_TEMPLATE: "titleTemplate"
  };
  var HTML_TAG_MAP = Object.keys(REACT_TAG_MAP).reduce(function(obj, key) {
    obj[REACT_TAG_MAP[key]] = key;
    return obj;
  }, {});
  var SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE];
  var HELMET_ATTRIBUTE = "data-react-helmet";
  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = /* @__PURE__ */ function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  var _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var inherits = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  var objectWithoutProperties = function(obj, keys) {
    var target = {};
    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }
    return target;
  };
  var possibleConstructorReturn = function(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };
  var encodeSpecialCharacters = function encodeSpecialCharacters2(str) {
    var encode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (encode === false) {
      return String(str);
    }
    return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  };
  var getTitleFromPropsList = function getTitleFromPropsList2(propsList) {
    var innermostTitle = getInnermostProperty(propsList, TAG_NAMES.TITLE);
    var innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);
    if (innermostTemplate && innermostTitle) {
      return innermostTemplate.replace(/%s/g, function() {
        return Array.isArray(innermostTitle) ? innermostTitle.join("") : innermostTitle;
      });
    }
    var innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);
    return innermostTitle || innermostDefaultTitle || void 0;
  };
  var getOnChangeClientState = function getOnChangeClientState2(propsList) {
    return getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || function() {
    };
  };
  var getAttributesFromPropsList = function getAttributesFromPropsList2(tagType, propsList) {
    return propsList.filter(function(props) {
      return typeof props[tagType] !== "undefined";
    }).map(function(props) {
      return props[tagType];
    }).reduce(function(tagAttrs, current2) {
      return _extends2({}, tagAttrs, current2);
    }, {});
  };
  var getBaseTagFromPropsList = function getBaseTagFromPropsList2(primaryAttributes, propsList) {
    return propsList.filter(function(props) {
      return typeof props[TAG_NAMES.BASE] !== "undefined";
    }).map(function(props) {
      return props[TAG_NAMES.BASE];
    }).reverse().reduce(function(innermostBaseTag, tag) {
      if (!innermostBaseTag.length) {
        var keys = Object.keys(tag);
        for (var i = 0; i < keys.length; i++) {
          var attributeKey = keys[i];
          var lowerCaseAttributeKey = attributeKey.toLowerCase();
          if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
            return innermostBaseTag.concat(tag);
          }
        }
      }
      return innermostBaseTag;
    }, []);
  };
  var getTagsFromPropsList = function getTagsFromPropsList2(tagName, primaryAttributes, propsList) {
    var approvedSeenTags = {};
    return propsList.filter(function(props) {
      if (Array.isArray(props[tagName])) {
        return true;
      }
      if (typeof props[tagName] !== "undefined") {
        warn("Helmet: " + tagName + ' should be of type "Array". Instead found type "' + _typeof2(props[tagName]) + '"');
      }
      return false;
    }).map(function(props) {
      return props[tagName];
    }).reverse().reduce(function(approvedTags, instanceTags) {
      var instanceSeenTags = {};
      instanceTags.filter(function(tag) {
        var primaryAttributeKey = void 0;
        var keys2 = Object.keys(tag);
        for (var i2 = 0; i2 < keys2.length; i2++) {
          var attributeKey2 = keys2[i2];
          var lowerCaseAttributeKey = attributeKey2.toLowerCase();
          if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === TAG_PROPERTIES.REL && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === TAG_PROPERTIES.REL && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
            primaryAttributeKey = lowerCaseAttributeKey;
          }
          if (primaryAttributes.indexOf(attributeKey2) !== -1 && (attributeKey2 === TAG_PROPERTIES.INNER_HTML || attributeKey2 === TAG_PROPERTIES.CSS_TEXT || attributeKey2 === TAG_PROPERTIES.ITEM_PROP)) {
            primaryAttributeKey = attributeKey2;
          }
        }
        if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
          return false;
        }
        var value = tag[primaryAttributeKey].toLowerCase();
        if (!approvedSeenTags[primaryAttributeKey]) {
          approvedSeenTags[primaryAttributeKey] = {};
        }
        if (!instanceSeenTags[primaryAttributeKey]) {
          instanceSeenTags[primaryAttributeKey] = {};
        }
        if (!approvedSeenTags[primaryAttributeKey][value]) {
          instanceSeenTags[primaryAttributeKey][value] = true;
          return true;
        }
        return false;
      }).reverse().forEach(function(tag) {
        return approvedTags.push(tag);
      });
      var keys = Object.keys(instanceSeenTags);
      for (var i = 0; i < keys.length; i++) {
        var attributeKey = keys[i];
        var tagUnion = (0, import_object_assign.default)({}, approvedSeenTags[attributeKey], instanceSeenTags[attributeKey]);
        approvedSeenTags[attributeKey] = tagUnion;
      }
      return approvedTags;
    }, []).reverse();
  };
  var getInnermostProperty = function getInnermostProperty2(propsList, property) {
    for (var i = propsList.length - 1; i >= 0; i--) {
      var props = propsList[i];
      if (props.hasOwnProperty(property)) {
        return props[property];
      }
    }
    return null;
  };
  var reducePropsToState = function reducePropsToState2(propsList) {
    return {
      baseTag: getBaseTagFromPropsList([TAG_PROPERTIES.HREF, TAG_PROPERTIES.TARGET], propsList),
      bodyAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.BODY, propsList),
      defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
      encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
      htmlAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.HTML, propsList),
      linkTags: getTagsFromPropsList(TAG_NAMES.LINK, [TAG_PROPERTIES.REL, TAG_PROPERTIES.HREF], propsList),
      metaTags: getTagsFromPropsList(TAG_NAMES.META, [TAG_PROPERTIES.NAME, TAG_PROPERTIES.CHARSET, TAG_PROPERTIES.HTTPEQUIV, TAG_PROPERTIES.PROPERTY, TAG_PROPERTIES.ITEM_PROP], propsList),
      noscriptTags: getTagsFromPropsList(TAG_NAMES.NOSCRIPT, [TAG_PROPERTIES.INNER_HTML], propsList),
      onChangeClientState: getOnChangeClientState(propsList),
      scriptTags: getTagsFromPropsList(TAG_NAMES.SCRIPT, [TAG_PROPERTIES.SRC, TAG_PROPERTIES.INNER_HTML], propsList),
      styleTags: getTagsFromPropsList(TAG_NAMES.STYLE, [TAG_PROPERTIES.CSS_TEXT], propsList),
      title: getTitleFromPropsList(propsList),
      titleAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.TITLE, propsList)
    };
  };
  var rafPolyfill = function() {
    var clock = Date.now();
    return function(callback2) {
      var currentTime = Date.now();
      if (currentTime - clock > 16) {
        clock = currentTime;
        callback2(currentTime);
      } else {
        setTimeout(function() {
          rafPolyfill(callback2);
        }, 0);
      }
    };
  }();
  var cafPolyfill = function cafPolyfill2(id) {
    return clearTimeout(id);
  };
  var requestAnimationFrame = typeof window !== "undefined" ? window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || rafPolyfill : global.requestAnimationFrame || rafPolyfill;
  var cancelAnimationFrame = typeof window !== "undefined" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || cafPolyfill : global.cancelAnimationFrame || cafPolyfill;
  var warn = function warn2(msg) {
    return console && typeof console.warn === "function" && console.warn(msg);
  };
  var _helmetCallback = null;
  var handleClientStateChange = function handleClientStateChange2(newState) {
    if (_helmetCallback) {
      cancelAnimationFrame(_helmetCallback);
    }
    if (newState.defer) {
      _helmetCallback = requestAnimationFrame(function() {
        commitTagChanges(newState, function() {
          _helmetCallback = null;
        });
      });
    } else {
      commitTagChanges(newState);
      _helmetCallback = null;
    }
  };
  var commitTagChanges = function commitTagChanges2(newState, cb) {
    var baseTag = newState.baseTag, bodyAttributes = newState.bodyAttributes, htmlAttributes = newState.htmlAttributes, linkTags = newState.linkTags, metaTags = newState.metaTags, noscriptTags = newState.noscriptTags, onChangeClientState = newState.onChangeClientState, scriptTags = newState.scriptTags, styleTags = newState.styleTags, title = newState.title, titleAttributes = newState.titleAttributes;
    updateAttributes(TAG_NAMES.BODY, bodyAttributes);
    updateAttributes(TAG_NAMES.HTML, htmlAttributes);
    updateTitle(title, titleAttributes);
    var tagUpdates = {
      baseTag: updateTags(TAG_NAMES.BASE, baseTag),
      linkTags: updateTags(TAG_NAMES.LINK, linkTags),
      metaTags: updateTags(TAG_NAMES.META, metaTags),
      noscriptTags: updateTags(TAG_NAMES.NOSCRIPT, noscriptTags),
      scriptTags: updateTags(TAG_NAMES.SCRIPT, scriptTags),
      styleTags: updateTags(TAG_NAMES.STYLE, styleTags)
    };
    var addedTags = {};
    var removedTags = {};
    Object.keys(tagUpdates).forEach(function(tagType) {
      var _tagUpdates$tagType = tagUpdates[tagType], newTags = _tagUpdates$tagType.newTags, oldTags = _tagUpdates$tagType.oldTags;
      if (newTags.length) {
        addedTags[tagType] = newTags;
      }
      if (oldTags.length) {
        removedTags[tagType] = tagUpdates[tagType].oldTags;
      }
    });
    cb && cb();
    onChangeClientState(newState, addedTags, removedTags);
  };
  var flattenArray = function flattenArray2(possibleArray) {
    return Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
  };
  var updateTitle = function updateTitle2(title, attributes) {
    if (typeof title !== "undefined" && document.title !== title) {
      document.title = flattenArray(title);
    }
    updateAttributes(TAG_NAMES.TITLE, attributes);
  };
  var updateAttributes = function updateAttributes2(tagName, attributes) {
    var elementTag = document.getElementsByTagName(tagName)[0];
    if (!elementTag) {
      return;
    }
    var helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
    var helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
    var attributesToRemove = [].concat(helmetAttributes);
    var attributeKeys = Object.keys(attributes);
    for (var i = 0; i < attributeKeys.length; i++) {
      var attribute = attributeKeys[i];
      var value = attributes[attribute] || "";
      if (elementTag.getAttribute(attribute) !== value) {
        elementTag.setAttribute(attribute, value);
      }
      if (helmetAttributes.indexOf(attribute) === -1) {
        helmetAttributes.push(attribute);
      }
      var indexToSave = attributesToRemove.indexOf(attribute);
      if (indexToSave !== -1) {
        attributesToRemove.splice(indexToSave, 1);
      }
    }
    for (var _i = attributesToRemove.length - 1; _i >= 0; _i--) {
      elementTag.removeAttribute(attributesToRemove[_i]);
    }
    if (helmetAttributes.length === attributesToRemove.length) {
      elementTag.removeAttribute(HELMET_ATTRIBUTE);
    } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
      elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
    }
  };
  var updateTags = function updateTags2(type, tags) {
    var headElement = document.head || document.querySelector(TAG_NAMES.HEAD);
    var tagNodes = headElement.querySelectorAll(type + "[" + HELMET_ATTRIBUTE + "]");
    var oldTags = Array.prototype.slice.call(tagNodes);
    var newTags = [];
    var indexToDelete = void 0;
    if (tags && tags.length) {
      tags.forEach(function(tag) {
        var newElement = document.createElement(type);
        for (var attribute in tag) {
          if (tag.hasOwnProperty(attribute)) {
            if (attribute === TAG_PROPERTIES.INNER_HTML) {
              newElement.innerHTML = tag.innerHTML;
            } else if (attribute === TAG_PROPERTIES.CSS_TEXT) {
              if (newElement.styleSheet) {
                newElement.styleSheet.cssText = tag.cssText;
              } else {
                newElement.appendChild(document.createTextNode(tag.cssText));
              }
            } else {
              var value = typeof tag[attribute] === "undefined" ? "" : tag[attribute];
              newElement.setAttribute(attribute, value);
            }
          }
        }
        newElement.setAttribute(HELMET_ATTRIBUTE, "true");
        if (oldTags.some(function(existingTag, index) {
          indexToDelete = index;
          return newElement.isEqualNode(existingTag);
        })) {
          oldTags.splice(indexToDelete, 1);
        } else {
          newTags.push(newElement);
        }
      });
    }
    oldTags.forEach(function(tag) {
      return tag.parentNode.removeChild(tag);
    });
    newTags.forEach(function(tag) {
      return headElement.appendChild(tag);
    });
    return {
      oldTags,
      newTags
    };
  };
  var generateElementAttributesAsString = function generateElementAttributesAsString2(attributes) {
    return Object.keys(attributes).reduce(function(str, key) {
      var attr = typeof attributes[key] !== "undefined" ? key + '="' + attributes[key] + '"' : "" + key;
      return str ? str + " " + attr : attr;
    }, "");
  };
  var generateTitleAsString = function generateTitleAsString2(type, title, attributes, encode) {
    var attributeString = generateElementAttributesAsString(attributes);
    var flattenedTitle = flattenArray(title);
    return attributeString ? "<" + type + " " + HELMET_ATTRIBUTE + '="true" ' + attributeString + ">" + encodeSpecialCharacters(flattenedTitle, encode) + "</" + type + ">" : "<" + type + " " + HELMET_ATTRIBUTE + '="true">' + encodeSpecialCharacters(flattenedTitle, encode) + "</" + type + ">";
  };
  var generateTagsAsString = function generateTagsAsString2(type, tags, encode) {
    return tags.reduce(function(str, tag) {
      var attributeHtml = Object.keys(tag).filter(function(attribute) {
        return !(attribute === TAG_PROPERTIES.INNER_HTML || attribute === TAG_PROPERTIES.CSS_TEXT);
      }).reduce(function(string, attribute) {
        var attr = typeof tag[attribute] === "undefined" ? attribute : attribute + '="' + encodeSpecialCharacters(tag[attribute], encode) + '"';
        return string ? string + " " + attr : attr;
      }, "");
      var tagContent = tag.innerHTML || tag.cssText || "";
      var isSelfClosing = SELF_CLOSING_TAGS.indexOf(type) === -1;
      return str + "<" + type + " " + HELMET_ATTRIBUTE + '="true" ' + attributeHtml + (isSelfClosing ? "/>" : ">" + tagContent + "</" + type + ">");
    }, "");
  };
  var convertElementAttributestoReactProps = function convertElementAttributestoReactProps2(attributes) {
    var initProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Object.keys(attributes).reduce(function(obj, key) {
      obj[REACT_TAG_MAP[key] || key] = attributes[key];
      return obj;
    }, initProps);
  };
  var convertReactPropstoHtmlAttributes = function convertReactPropstoHtmlAttributes2(props) {
    var initAttributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Object.keys(props).reduce(function(obj, key) {
      obj[HTML_TAG_MAP[key] || key] = props[key];
      return obj;
    }, initAttributes);
  };
  var generateTitleAsReactComponent = function generateTitleAsReactComponent2(type, title, attributes) {
    var _initProps;
    var initProps = (_initProps = {
      key: title
    }, _initProps[HELMET_ATTRIBUTE] = true, _initProps);
    var props = convertElementAttributestoReactProps(attributes, initProps);
    return [import_react15.default.createElement(TAG_NAMES.TITLE, props, title)];
  };
  var generateTagsAsReactComponent = function generateTagsAsReactComponent2(type, tags) {
    return tags.map(function(tag, i) {
      var _mappedTag;
      var mappedTag = (_mappedTag = {
        key: i
      }, _mappedTag[HELMET_ATTRIBUTE] = true, _mappedTag);
      Object.keys(tag).forEach(function(attribute) {
        var mappedAttribute = REACT_TAG_MAP[attribute] || attribute;
        if (mappedAttribute === TAG_PROPERTIES.INNER_HTML || mappedAttribute === TAG_PROPERTIES.CSS_TEXT) {
          var content = tag.innerHTML || tag.cssText;
          mappedTag.dangerouslySetInnerHTML = { __html: content };
        } else {
          mappedTag[mappedAttribute] = tag[attribute];
        }
      });
      return import_react15.default.createElement(type, mappedTag);
    });
  };
  var getMethodsForTag = function getMethodsForTag2(type, tags, encode) {
    switch (type) {
      case TAG_NAMES.TITLE:
        return {
          toComponent: function toComponent() {
            return generateTitleAsReactComponent(type, tags.title, tags.titleAttributes, encode);
          },
          toString: function toString() {
            return generateTitleAsString(type, tags.title, tags.titleAttributes, encode);
          }
        };
      case ATTRIBUTE_NAMES.BODY:
      case ATTRIBUTE_NAMES.HTML:
        return {
          toComponent: function toComponent() {
            return convertElementAttributestoReactProps(tags);
          },
          toString: function toString() {
            return generateElementAttributesAsString(tags);
          }
        };
      default:
        return {
          toComponent: function toComponent() {
            return generateTagsAsReactComponent(type, tags);
          },
          toString: function toString() {
            return generateTagsAsString(type, tags, encode);
          }
        };
    }
  };
  var mapStateOnServer = function mapStateOnServer2(_ref) {
    var baseTag = _ref.baseTag, bodyAttributes = _ref.bodyAttributes, encode = _ref.encode, htmlAttributes = _ref.htmlAttributes, linkTags = _ref.linkTags, metaTags = _ref.metaTags, noscriptTags = _ref.noscriptTags, scriptTags = _ref.scriptTags, styleTags = _ref.styleTags, _ref$title = _ref.title, title = _ref$title === void 0 ? "" : _ref$title, titleAttributes = _ref.titleAttributes;
    return {
      base: getMethodsForTag(TAG_NAMES.BASE, baseTag, encode),
      bodyAttributes: getMethodsForTag(ATTRIBUTE_NAMES.BODY, bodyAttributes, encode),
      htmlAttributes: getMethodsForTag(ATTRIBUTE_NAMES.HTML, htmlAttributes, encode),
      link: getMethodsForTag(TAG_NAMES.LINK, linkTags, encode),
      meta: getMethodsForTag(TAG_NAMES.META, metaTags, encode),
      noscript: getMethodsForTag(TAG_NAMES.NOSCRIPT, noscriptTags, encode),
      script: getMethodsForTag(TAG_NAMES.SCRIPT, scriptTags, encode),
      style: getMethodsForTag(TAG_NAMES.STYLE, styleTags, encode),
      title: getMethodsForTag(TAG_NAMES.TITLE, { title, titleAttributes }, encode)
    };
  };
  var Helmet = function Helmet2(Component4) {
    var _class, _temp;
    return _temp = _class = function(_React$Component) {
      inherits(HelmetWrapper, _React$Component);
      function HelmetWrapper() {
        classCallCheck(this, HelmetWrapper);
        return possibleConstructorReturn(this, _React$Component.apply(this, arguments));
      }
      HelmetWrapper.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
        return !(0, import_react_fast_compare.default)(this.props, nextProps);
      };
      HelmetWrapper.prototype.mapNestedChildrenToProps = function mapNestedChildrenToProps(child, nestedChildren) {
        if (!nestedChildren) {
          return null;
        }
        switch (child.type) {
          case TAG_NAMES.SCRIPT:
          case TAG_NAMES.NOSCRIPT:
            return {
              innerHTML: nestedChildren
            };
          case TAG_NAMES.STYLE:
            return {
              cssText: nestedChildren
            };
        }
        throw new Error("<" + child.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.");
      };
      HelmetWrapper.prototype.flattenArrayTypeChildren = function flattenArrayTypeChildren(_ref) {
        var _babelHelpers$extends;
        var child = _ref.child, arrayTypeChildren = _ref.arrayTypeChildren, newChildProps = _ref.newChildProps, nestedChildren = _ref.nestedChildren;
        return _extends2({}, arrayTypeChildren, (_babelHelpers$extends = {}, _babelHelpers$extends[child.type] = [].concat(arrayTypeChildren[child.type] || [], [_extends2({}, newChildProps, this.mapNestedChildrenToProps(child, nestedChildren))]), _babelHelpers$extends));
      };
      HelmetWrapper.prototype.mapObjectTypeChildren = function mapObjectTypeChildren(_ref2) {
        var _babelHelpers$extends2, _babelHelpers$extends3;
        var child = _ref2.child, newProps = _ref2.newProps, newChildProps = _ref2.newChildProps, nestedChildren = _ref2.nestedChildren;
        switch (child.type) {
          case TAG_NAMES.TITLE:
            return _extends2({}, newProps, (_babelHelpers$extends2 = {}, _babelHelpers$extends2[child.type] = nestedChildren, _babelHelpers$extends2.titleAttributes = _extends2({}, newChildProps), _babelHelpers$extends2));
          case TAG_NAMES.BODY:
            return _extends2({}, newProps, {
              bodyAttributes: _extends2({}, newChildProps)
            });
          case TAG_NAMES.HTML:
            return _extends2({}, newProps, {
              htmlAttributes: _extends2({}, newChildProps)
            });
        }
        return _extends2({}, newProps, (_babelHelpers$extends3 = {}, _babelHelpers$extends3[child.type] = _extends2({}, newChildProps), _babelHelpers$extends3));
      };
      HelmetWrapper.prototype.mapArrayTypeChildrenToProps = function mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
        var newFlattenedProps = _extends2({}, newProps);
        Object.keys(arrayTypeChildren).forEach(function(arrayChildName) {
          var _babelHelpers$extends4;
          newFlattenedProps = _extends2({}, newFlattenedProps, (_babelHelpers$extends4 = {}, _babelHelpers$extends4[arrayChildName] = arrayTypeChildren[arrayChildName], _babelHelpers$extends4));
        });
        return newFlattenedProps;
      };
      HelmetWrapper.prototype.warnOnInvalidChildren = function warnOnInvalidChildren(child, nestedChildren) {
        if (true) {
          if (!VALID_TAG_NAMES.some(function(name) {
            return child.type === name;
          })) {
            if (typeof child.type === "function") {
              return warn("You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.");
            }
            return warn("Only elements types " + VALID_TAG_NAMES.join(", ") + " are allowed. Helmet does not support rendering <" + child.type + "> elements. Refer to our API for more information.");
          }
          if (nestedChildren && typeof nestedChildren !== "string" && (!Array.isArray(nestedChildren) || nestedChildren.some(function(nestedChild) {
            return typeof nestedChild !== "string";
          }))) {
            throw new Error("Helmet expects a string as a child of <" + child.type + ">. Did you forget to wrap your children in braces? ( <" + child.type + ">{``}</" + child.type + "> ) Refer to our API for more information.");
          }
        }
        return true;
      };
      HelmetWrapper.prototype.mapChildrenToProps = function mapChildrenToProps(children, newProps) {
        var _this2 = this;
        var arrayTypeChildren = {};
        import_react15.default.Children.forEach(children, function(child) {
          if (!child || !child.props) {
            return;
          }
          var _child$props = child.props, nestedChildren = _child$props.children, childProps = objectWithoutProperties(_child$props, ["children"]);
          var newChildProps = convertReactPropstoHtmlAttributes(childProps);
          _this2.warnOnInvalidChildren(child, nestedChildren);
          switch (child.type) {
            case TAG_NAMES.LINK:
            case TAG_NAMES.META:
            case TAG_NAMES.NOSCRIPT:
            case TAG_NAMES.SCRIPT:
            case TAG_NAMES.STYLE:
              arrayTypeChildren = _this2.flattenArrayTypeChildren({
                child,
                arrayTypeChildren,
                newChildProps,
                nestedChildren
              });
              break;
            default:
              newProps = _this2.mapObjectTypeChildren({
                child,
                newProps,
                newChildProps,
                nestedChildren
              });
              break;
          }
        });
        newProps = this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
        return newProps;
      };
      HelmetWrapper.prototype.render = function render2() {
        var _props = this.props, children = _props.children, props = objectWithoutProperties(_props, ["children"]);
        var newProps = _extends2({}, props);
        if (children) {
          newProps = this.mapChildrenToProps(children, newProps);
        }
        return import_react15.default.createElement(Component4, newProps);
      };
      createClass(HelmetWrapper, null, [{
        key: "canUseDOM",
        // Component.peek comes from react-side-effect:
        // For testing, you may use a static peek() method available on the returned component.
        // It lets you get the current state without resetting the mounted instance stack.
        // Dont use it for anything other than testing.
        /**
         * @param {Object} base: {"target": "_blank", "href": "http://mysite.com/"}
         * @param {Object} bodyAttributes: {"className": "root"}
         * @param {String} defaultTitle: "Default Title"
         * @param {Boolean} defer: true
         * @param {Boolean} encodeSpecialCharacters: true
         * @param {Object} htmlAttributes: {"lang": "en", "amp": undefined}
         * @param {Array} link: [{"rel": "canonical", "href": "http://mysite.com/example"}]
         * @param {Array} meta: [{"name": "description", "content": "Test description"}]
         * @param {Array} noscript: [{"innerHTML": "<img src='http://mysite.com/js/test.js'"}]
         * @param {Function} onChangeClientState: "(newState) => console.log(newState)"
         * @param {Array} script: [{"type": "text/javascript", "src": "http://mysite.com/js/test.js"}]
         * @param {Array} style: [{"type": "text/css", "cssText": "div { display: block; color: blue; }"}]
         * @param {String} title: "Title"
         * @param {Object} titleAttributes: {"itemprop": "name"}
         * @param {String} titleTemplate: "MySite.com - %s"
         */
        set: function set$$1(canUseDOM3) {
          Component4.canUseDOM = canUseDOM3;
        }
      }]);
      return HelmetWrapper;
    }(import_react15.default.Component), _class.propTypes = {
      base: import_prop_types5.default.object,
      bodyAttributes: import_prop_types5.default.object,
      children: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.node), import_prop_types5.default.node]),
      defaultTitle: import_prop_types5.default.string,
      defer: import_prop_types5.default.bool,
      encodeSpecialCharacters: import_prop_types5.default.bool,
      htmlAttributes: import_prop_types5.default.object,
      link: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
      meta: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
      noscript: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
      onChangeClientState: import_prop_types5.default.func,
      script: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
      style: import_prop_types5.default.arrayOf(import_prop_types5.default.object),
      title: import_prop_types5.default.string,
      titleAttributes: import_prop_types5.default.object,
      titleTemplate: import_prop_types5.default.string
    }, _class.defaultProps = {
      defer: true,
      encodeSpecialCharacters: true
    }, _class.peek = Component4.peek, _class.rewind = function() {
      var mappedState = Component4.rewind();
      if (!mappedState) {
        mappedState = mapStateOnServer({
          baseTag: [],
          bodyAttributes: {},
          encodeSpecialCharacters: true,
          htmlAttributes: {},
          linkTags: [],
          metaTags: [],
          noscriptTags: [],
          scriptTags: [],
          styleTags: [],
          title: "",
          titleAttributes: {}
        });
      }
      return mappedState;
    }, _temp;
  };
  var NullComponent = function NullComponent2() {
    return null;
  };
  var HelmetSideEffects = (0, import_react_side_effect.default)(reducePropsToState, handleClientStateChange, mapStateOnServer)(NullComponent);
  var HelmetExport = Helmet(HelmetSideEffects);
  HelmetExport.renderStatic = HelmetExport.rewind;

  // assets/scripts/components/modal-portal.tsx
  var import_react16 = __toESM(require_react());
  var import_react_dom3 = __toESM(require_react_dom());
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  var hasModalClass = "has-modal";
  var modalRootId = "modal-root";
  var modalPortalId = "modal-root-portal";
  var Escape2 = "Escape";
  var ModalPortal = (0, import_react16.forwardRef)(({
    children,
    className,
    deactivate,
    isActive
  }, ref) => {
    const target = document.getElementById(modalPortalId);
    const handleOverlayClick = () => {
      deactivate();
    };
    const handleKeyUp = (e) => {
      if (e.key === Escape2 && isActive) {
        deactivate();
      }
    };
    use_fixed_body_when_has_class_default(hasModalClass);
    return (0, import_react_dom3.createPortal)(
      /* @__PURE__ */ (0, import_jsx_runtime6.jsxs)(
        "div",
        {
          className: cx("modal", className),
          onKeyUp: handleKeyUp,
          ref,
          tabIndex: 0,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
              "div",
              {
                className: "modal-overlay",
                onClick: handleOverlayClick
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime6.jsx)("div", { className: "modal-content", children })
          ]
        }
      ),
      target
    );
  });
  var modal_portal_default = ModalPortal;

  // assets/scripts/components/alert-message.tsx
  var import_react17 = __toESM(require_react());
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var AlertMessage = () => {
    const [isActive, setIsActive] = (0, import_react17.useState)(false);
    const dispatch = useDispatch();
    const deactivate = () => {
      setIsActive(false);
      setTimeout(() => {
        dispatch(actions2.clearMessages());
      }, 250);
    };
    const alerts = useSelector(getMessages);
    const hasAlerts = alerts.length > 0;
    (0, import_react17.useEffect)(() => {
      if (hasAlerts) {
        setIsActive(true);
      }
    }, [hasAlerts]);
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
      alert_default,
      {
        alerts,
        deactivate,
        grade: "message",
        isActive
      }
    );
  };
  var alert_message_default = AlertMessage;

  // assets/scripts/components/alert-warning.tsx
  var import_react18 = __toESM(require_react());
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var AlertWarning = () => {
    const [isActive, setIsActive] = (0, import_react18.useState)(false);
    const dispatch = useDispatch();
    const deactivate = () => {
      setIsActive(false);
      setTimeout(() => {
        dispatch(actions2.clearWarnings());
      }, 250);
    };
    const alerts = useSelector(getWarnings);
    const hasAlerts = alerts.length > 0;
    (0, import_react18.useEffect)(() => {
      if (hasAlerts) {
        setIsActive(true);
      }
    }, [hasAlerts]);
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
      alert_default,
      {
        alerts,
        deactivate,
        grade: "warning",
        isActive
      }
    );
  };
  var alert_warning_default = AlertWarning;

  // assets/scripts/icons/eye.tsx
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  var Eye = () => /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 72 72", className: "icon", fill: "currentColor", children: [
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { d: "M35.99 30.48c0 4.44-3.61 8.05-8.05 8.05-.89 0-1.75-.15-2.55-.41-.69-.23-1.5.2-1.47.93.04.87.16 1.73.4 2.6 1.72 6.44 8.35 10.26 14.78 8.54 6.44-1.72 10.26-8.35 8.54-14.78-1.4-5.22-6.01-8.72-11.14-8.94-.73-.03-1.16.77-.93 1.47.27.8.42 1.65.42 2.54z" }),
    /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", { d: "M71.89 35.6c-1.86-4.49-5.8-11.03-11.68-16.48C54.29 13.62 46.16 8.99 36 8.99s-18.29 4.63-24.21 10.13C5.9 24.58 1.97 31.12.11 35.6c-.41.99.51 2.1.92 3.09 1.86 4.49 4.88 9.64 10.76 15.1C17.71 59.3 25.85 63 36 63s18.3-3.71 24.22-9.21c5.88-5.46 8.9-10.61 10.76-15.1.41-.99 1.33-2.09.91-3.09zM56.77 50.09c-6.27 5.83-13.26 7.86-20.78 7.86s-14.5-2.03-20.77-7.86c-5.03-4.67-6.73-8.99-8.44-12.94 1.71-3.94 3.4-5.96 8.44-10.64 6.24-5.8 13.29-7.84 20.77-7.86 7.48.03 14.53 2.06 20.77 7.86 5.04 4.68 6.74 6.7 8.44 10.64-1.7 3.95-3.39 8.27-8.43 12.94z" })
  ] });
  var eye_default = Eye;

  // assets/scripts/components/eyes.tsx
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var Eyes = () => /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("div", { className: "eyes", children: [
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(eye_default, {}),
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(eye_default, {}),
    /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(eye_default, {})
  ] });
  var eyes_default = Eyes;

  // assets/scripts/components/links.tsx
  var import_react19 = __toESM(require_react());

  // assets/scripts/lib/links.ts
  var isCurrent = (location2, newSearch) => {
    const { pathname, search } = location2;
    const currentPath = [pathname, search].filter(Boolean).join("");
    const linkedPath = [pathname, newSearch].filter(Boolean).join("?");
    return currentPath === linkedPath;
  };
  var getQueryParams = (location2, newParams, replace4 = true) => {
    const { pathname, search } = location2;
    const options2 = replace4 ? void 0 : search;
    const searchParams = new URLSearchParams(options2);
    Object.entries(newParams).forEach(([key, value]) => {
      if (value) {
        searchParams.set(key, String(value));
      } else {
        searchParams.delete(key);
      }
    });
    const newSearch = searchParams.toString();
    return {
      link: {
        pathname,
        search: newSearch
      },
      get: (key) => searchParams.get(key),
      has: (key) => searchParams.has(key),
      isCurrent: isCurrent(location2, newSearch)
    };
  };

  // assets/scripts/types.ts
  var DataFormat = /* @__PURE__ */ ((DataFormat2) => {
    DataFormat2["csv"] = "CSV";
    return DataFormat2;
  })(DataFormat || {});

  // assets/scripts/components/links.tsx
  var import_jsx_runtime11 = __toESM(require_jsx_runtime());
  var dateOnParam = "date_on";
  var dateRangeFromParam = "date_range_from";
  var dateRangeToParam = "date_range_to";
  var quarterParam = "quarter";
  var sortByParam = "sort_by";
  var withEntityIdParam = "with_entity_id";
  var withPersonIdParam = "with_person_id";
  var getSortByParam = (value, isDefault) => ({
    [sortByParam]: isDefault ? null : value
  });
  var getWithEntityParams = (item) => ({
    [withEntityIdParam]: item.entity.id
  });
  var getWithPersonParams = (item) => ({
    [withPersonIdParam]: item.person.id
  });
  var useQueryParams = (newParams, replace4 = true) => getQueryParams(useLocation(), newParams, replace4);
  var BetterLink = ({
    onClick,
    ...rest
  }) => {
    const ref = (0, import_react19.useRef)();
    const handleClick = (e) => {
      if (e.button || e.altKey || e.ctrlKey || e.metaKey || e.shiftKey) {
        const customEvent = new MouseEvent("click", {
          altKey: e.altKey,
          ctrlKey: e.ctrlKey,
          metaKey: e.metaKey,
          shiftKey: e.shiftKey,
          button: e.button
        });
        e.preventDefault();
        ref.current.dispatchEvent(customEvent);
      } else {
        onClick?.(e);
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(Link, { ref, onClick: handleClick, ...rest });
  };
  var LinkToQueryParams = ({
    children,
    className,
    newParams,
    replace: replace4,
    ...rest
  }) => {
    const queryParams = useQueryParams(newParams, replace4);
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      Link,
      {
        to: queryParams.link,
        className: cx({
          "is-active": queryParams.isCurrent
        }, className),
        preventScrollReset: true,
        ...rest,
        children
      }
    );
  };
  var FilterLink = ({
    children,
    className,
    hasIcon,
    title,
    ...rest
  }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    LinkToQueryParams,
    {
      className: cx("link-filter", className),
      title: title || "Apply this filter",
      ...rest,
      children: hasIcon ? /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(item_text_with_icon_default, { icon: "filter", children }) : children
    }
  );
  var toggleSort = (sort) => sort === "ASC" /* ASC */ ? "DESC" /* DESC */ : "ASC" /* ASC */;
  var getIconNameForSort = (sort) => sort === "ASC" /* ASC */ ? "arrow-up" : "arrow-down";
  var SortLink = ({
    children,
    className,
    title,
    newParams,
    defaultSort,
    ...rest
  }) => {
    const [nextSort, setNextSort] = (0, import_react19.useState)(defaultSort);
    const [searchParams] = useSearchParams();
    const params = new Map(Object.entries(newParams));
    for (const [key, value] of searchParams.entries()) {
      params.set(key, value);
    }
    const queryParams = useQueryParams(Object.fromEntries(params));
    const hasSortBy = searchParams.has("sort_by");
    const isDefault = params.get("sort_by") === null && !hasSortBy;
    const isSorted = params.get("sort_by") !== null && hasSortBy;
    const hasIcon = isDefault || isSorted;
    const icon2 = getIconNameForSort(toggleSort(nextSort));
    (0, import_react19.useEffect)(() => {
      const sortValue = searchParams.get("sort") || defaultSort;
      if (queryParams.isCurrent) {
        setNextSort(toggleSort(sortValue));
      }
    }, [
      queryParams,
      searchParams,
      defaultSort,
      setNextSort
    ]);
    if (queryParams.isCurrent) {
      params.set("sort", nextSort === defaultSort ? null : nextSort);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
      LinkToQueryParams,
      {
        className: cx("link-sort", className),
        title: title || "Sort this list",
        newParams: Object.fromEntries(params),
        ...rest,
        children: hasIcon ? /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
          item_text_with_icon_default,
          {
            icon: icon2,
            after: true,
            children
          }
        ) : children
      }
    );
  };
  var GlobalLink = ({ children, to: to2, ...rest }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    NavLink,
    {
      to: to2,
      className: ({ isActive }) => isActive ? "is-active" : void 0,
      ...rest,
      children
    }
  );
  var LinkToPage = ({
    children,
    isCurrent: isCurrent2,
    onClick,
    to: to2,
    ...rest
  }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(
    NavLink,
    {
      to: to2,
      className: ({ isActive }) => isCurrent2 && isActive ? "is-active" : void 0,
      onClick,
      preventScrollReset: true,
      end: true,
      ...rest,
      children
    }
  );
  var LinkToEntities = ({ children, ...rest }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BetterLink, { to: "/entities", ...rest, children });
  var LinkToEntity = ({ children, id, onClick, ...rest }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BetterLink, { to: `/entities/${id}`, onClick, ...rest, children });
  var LinkToIncidents = ({ children, ...rest }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BetterLink, { to: "/incidents", ...rest, children });
  var LinkToIncident = ({ children, id, onClick, ...rest }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BetterLink, { to: `/incidents/${id}`, onClick, ...rest, children });
  var LinkToPeople = ({ children, ...rest }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BetterLink, { to: "/people", ...rest, children });
  var LinkToPerson = ({ children, id, onClick, ...rest }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BetterLink, { to: `/people/${id}`, onClick, ...rest, children });
  var LinkToSources = ({ children, ...rest }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BetterLink, { to: "/sources", ...rest, children });
  var LinkToSource = ({ children, id, onClick, ...rest }) => /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(BetterLink, { to: `/sources/${id}`, onClick, ...rest, children });

  // assets/scripts/components/global-footer.tsx
  var import_jsx_runtime12 = __toESM(require_jsx_runtime());
  var GlobalFooter = () => /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("footer", { className: "global-footer", children: [
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("nav", { className: "global-footer-navigation", "aria-label": "Global Navigation", children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "global-footer-navigation-title", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)(GlobalLink, { to: "/", children: [
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(eyes_default, {}),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("h6", { children: "The Big Blink" })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("ul", { className: "global-footer-navigation-links", children: [
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("li", { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(GlobalLink, { to: "/incidents", children: "Incidents" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("li", { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(GlobalLink, { to: "/entities", children: "Entities" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("li", { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(GlobalLink, { to: "/people", children: "People" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("li", { children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(GlobalLink, { to: "/sources", children: "Data Sources" }) })
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("section", { className: "global-footer-content", children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("h6", { children: "About" }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { children: [
        "This website (\u201Csite\u201D) was developed using ",
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(LinkToSources, { children: "data published by the City of Portland" }),
        " (\u201CCity\u201D). Good effort was made to represent City data with accuracy and completeness, though unintentional errors and omissions may have occurred during the import process. In the event a discrepancy is found to exist between the data represented on this site and the data published on the City of Portland\u2019s website, ",
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("a", { href: "mailto:help@bigblinkpdx.org", children: "please reach out" }),
        ". Data on the City\u2019s site is to be considered for all purposes official, accurate, and complete."
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("h6", { children: "License" }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { children: [
        "Copyright \xA9 2023\u20132025 by ",
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("a", { href: "https://justinskolnick.com", children: "Justin Skolnick" }),
        "."
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { children: [
        "The code for this site is ",
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("a", { href: "https://en.wikipedia.org/wiki/Open-source_software", children: "open source" }),
        ". ",
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("a", { href: "https://github.com/justinskolnick/big-blink-pdx", children: "Contribute to its development on Github" }),
        "."
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("h6", { children: "Privacy Policy" }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("p", { children: [
        "This site is not configured to identify you or collect personal data from you, although your device\u2019s ",
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("a", { href: "https://en.wikipedia.org/wiki/IP_address", children: "IP address" }),
        ", ",
        /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("a", { href: "https://en.wikipedia.org/wiki/User_agent", children: "user agent" }),
        ", and time of access may be incidentally logged by the web server that publishes this site. Third-party software installed to provide site services (potentially including but not limited to: user interface features, performance monitoring, and/or error reporting) may be found to collect and store data about you and/or your device; no responsibility is assumed for the operation and/or data-handling processes and/or practices of third-party software and/or services."
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("h6", { children: "Media Inquiries" }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { children: "Contact information for current City officials may be found on the City\u2019s website \u2014 follow your hunches!" }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("h6", { children: "Accessibility" }),
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("p", { children: "Making this site accessible to users of all abilities is a sincere aspiration and is always a work in progress." })
    ] })
  ] });
  var global_footer_default = GlobalFooter;

  // assets/scripts/components/entities/icon.tsx
  var import_jsx_runtime13 = __toESM(require_jsx_runtime());
  var EntitiesIcon = () => /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(icon_default, { name: "building" });
  var icon_default2 = EntitiesIcon;

  // assets/scripts/components/incidents/icon.tsx
  var import_jsx_runtime14 = __toESM(require_jsx_runtime());
  var EntitiesIcon2 = () => /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(icon_default, { name: "thumbtack" });
  var icon_default3 = EntitiesIcon2;

  // assets/scripts/components/people/icon.tsx
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  var TypeForIcon = /* @__PURE__ */ ((TypeForIcon2) => {
    TypeForIcon2["group"] = "user-group";
    TypeForIcon2["person"] = "user-large";
    TypeForIcon2["unknown"] = "circle-question";
    return TypeForIcon2;
  })(TypeForIcon || {});
  var getIconName2 = (person) => TypeForIcon[person?.type ?? "person"];
  var PeopleIcon = ({ person }) => {
    const { id } = useParams();
    const numericId = Number(id);
    const personAtId = useSelector((state) => selectors3.selectById(state, numericId));
    const name = getIconName2(person || personAtId);
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(icon_default, { name });
  };
  var icon_default4 = PeopleIcon;

  // assets/scripts/components/sources/icon.tsx
  var import_jsx_runtime16 = __toESM(require_jsx_runtime());
  var EntitiesIcon3 = () => /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(icon_default, { name: "database" });
  var icon_default5 = EntitiesIcon3;

  // assets/scripts/components/section-icon.tsx
  var import_jsx_runtime17 = __toESM(require_jsx_runtime());
  var ENTITIES = "entities";
  var INCIDENTS = "incidents";
  var PEOPLE = "people";
  var SOURCES = "sources";
  var SectionIcon = ({ name, slug }) => {
    if (name) {
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(icon_default, { name });
    } else if (slug === ENTITIES) {
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(icon_default2, {});
    } else if (slug === INCIDENTS) {
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(icon_default3, {});
    } else if (slug === PEOPLE) {
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(icon_default4, {});
    } else if (slug === SOURCES) {
      return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(icon_default5, {});
    }
    return null;
  };
  var section_icon_default = SectionIcon;

  // assets/scripts/components/header.tsx
  var import_jsx_runtime18 = __toESM(require_jsx_runtime());
  var useGetSectionLink = (slug) => {
    if (slug === "entities" /* Entities */) {
      return LinkToEntities;
    } else if (slug === "incidents" /* Incidents */) {
      return LinkToIncidents;
    } else if (slug === "people" /* People */) {
      return LinkToPeople;
    } else if (slug === "sources" /* Sources */) {
      return LinkToSources;
    }
  };
  var useGetSectionItemLink = (slug) => {
    if (slug === "entities" /* Entities */) {
      return LinkToEntity;
    } else if (slug === "incidents" /* Incidents */) {
      return LinkToIncident;
    } else if (slug === "people" /* People */) {
      return LinkToPerson;
    } else if (slug === "sources" /* Sources */) {
      return LinkToSource;
    }
  };
  var Header = ({
    children,
    icon: icon2,
    title
  }) => {
    const section = useSelector(getSection);
    const slug = section.slug;
    const SectionLink = useGetSectionLink(slug);
    const SectionItemLink = useGetSectionItemLink(slug);
    const hasLink = Boolean(SectionLink);
    const hasSubhead = Boolean(section.subtitle);
    const hasDetails = section.details?.length > 0;
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(
      "header",
      {
        className: cx(
          "header",
          hasSubhead && "has-subheader"
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "header-overview", children: [
            /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "header-identity", children: [
              /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("h1", { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(GlobalLink, { to: "/", className: "header-identity-link", children: [
                /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("span", { className: "text-secondary", children: "The" }),
                " ",
                /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("span", { className: "text-primary", children: "Big Blink" }),
                " ",
                /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("span", { className: "text-secondary", children: "PDX" })
              ] }) }),
              /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { className: "header-identity-eyes", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(eyes_default, {}) })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "header-section", children: [
              /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("div", { className: cx("header-section-icon", hasLink && "has-link"), children: hasLink ? /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SectionLink, { "aria-label": "section-icon", children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(section_icon_default, { name: icon2, slug }) }) : /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(section_icon_default, { name: icon2, slug }) }),
              /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("div", { className: "header-section-title", children: [
                /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("h2", { children: hasLink ? /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SectionLink, { "aria-label": "section-title", children: title ?? section.title }) : title ?? section.title }),
                hasSubhead && /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(import_jsx_runtime18.Fragment, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("h3", { children: /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(SectionItemLink, { id: section.id, children: section.subtitle }) }),
                  hasDetails && /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("h4", { children: section.details.map((detail, i) => /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("span", { className: "header-section-detail", children: detail }, i)) })
                ] })
              ] })
            ] })
          ] }),
          children
        ]
      }
    );
  };
  var header_default = Header;

  // assets/scripts/components/header-intro.tsx
  var import_react22 = __toESM(require_react());

  // assets/scripts/components/incident-modal.tsx
  var import_react21 = __toESM(require_react());

  // assets/scripts/components/meta-section.tsx
  var import_jsx_runtime19 = __toESM(require_jsx_runtime());
  var MetaSectionBox = ({ children, className, icon: icon2, title }) => {
    const hasIcon = Boolean(icon2);
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: cx(
      "meta-section-box",
      className,
      hasIcon && "has-icon"
    ), children: [
      hasIcon && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "meta-section-box-icon", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(icon_default, { name: icon2 }) }),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("div", { className: "meta-section-box-content", children: [
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "meta-section-box-title", children: /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("h6", { children: title }) }),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "meta-section-box-description", children })
      ] })
    ] });
  };
  var MetaSection = ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime19.jsx)("div", { className: "meta-section", children });
  var meta_section_default = MetaSection;

  // assets/scripts/components/incident-notes-box.tsx
  var import_jsx_runtime20 = __toESM(require_jsx_runtime());
  var IncidentNotesBox = ({ incident, title }) => /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(
    MetaSectionBox,
    {
      className: "incident-notes-box",
      icon: "asterisk",
      title,
      children: incident.notes || "None"
    }
  );
  var incident_notes_box_default = IncidentNotesBox;

  // assets/scripts/components/incident-attendees.tsx
  var import_jsx_runtime21 = __toESM(require_jsx_runtime());
  var Attendees = ({ attendees }) => {
    const hasAttendees = attendees?.records?.length > 0;
    if (!hasAttendees) {
      return "none";
    }
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("ul", { className: "incident-attendees", children: attendees.records.map((attendee) => /* @__PURE__ */ (0, import_jsx_runtime21.jsxs)("li", { className: "incident-attendee", children: [
      /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(LinkToPerson, { id: attendee.person.id, children: attendee.person.name }),
      attendee.as !== attendee.person.name && /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("span", { children: attendee.as })
    ] }, attendee.person.id)) });
  };
  var incident_attendees_default = Attendees;

  // assets/scripts/components/incident-table.tsx
  var import_jsx_runtime22 = __toESM(require_jsx_runtime());
  var IncidentTable = ({ incident }) => /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("table", { className: "incident-table", cellPadding: "0", cellSpacing: "0", children: /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("tbody", { children: [
    /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("th", { children: "Entity" }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("td", { children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(LinkToEntity, { id: incident.entityId, children: incident.entity }) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("th", { children: "Date" }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("td", { children: incident.contactDate })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("th", { children: "Type" }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("td", { children: incident.contactType })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("th", { children: "Category" }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("td", { children: incident.category })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("th", { children: "Topic" }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("td", { children: incident.topic })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("th", { children: "Officials" }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("td", { children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(incident_attendees_default, { attendees: incident.attendees?.officials }) })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime22.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("th", { children: "Lobbyists" }),
      /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("td", { children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(incident_attendees_default, { attendees: incident.attendees?.lobbyists }) })
    ] })
  ] }) });
  var incident_table_default = IncidentTable;

  // assets/scripts/components/item-subhead.tsx
  var import_jsx_runtime23 = __toESM(require_jsx_runtime());
  var ItemSubhead = ({
    children,
    className,
    hasBorder,
    icon: icon2,
    title,
    subtitle
  }) => {
    const hasIcon = Boolean(icon2);
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(
      "header",
      {
        className: cx(
          "item-subhead",
          hasBorder && "has-border",
          hasIcon && "has-icon",
          className
        ),
        children: [
          hasIcon && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(icon_default, { name: icon2 }),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "item-subhead-content", children: [
            title && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("h4", { children: title }),
            subtitle && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("h5", { children: subtitle }),
            children
          ] })
        ]
      }
    );
  };
  var item_subhead_default = ItemSubhead;

  // assets/scripts/components/modal.tsx
  var import_react20 = __toESM(require_react());
  var import_jsx_runtime24 = __toESM(require_jsx_runtime());
  var Modal = ({
    children,
    className,
    deactivate,
    isActive
  }) => {
    const ref = (0, import_react20.useRef)(null);
    return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
      CSSTransition_default,
      {
        timeout: 250,
        classNames: "modal",
        in: isActive,
        nodeRef: ref,
        unmountOnExit: true,
        children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
          modal_portal_default,
          {
            className,
            deactivate,
            isActive,
            ref,
            children
          }
        )
      }
    );
  };
  var modal_default = Modal;

  // assets/scripts/components/incident-modal.tsx
  var import_jsx_runtime25 = __toESM(require_jsx_runtime());
  var IncidentModal = ({ deactivate, id, isActive }) => {
    const [trigger] = api_default.useLazyGetIncidentByIdQuery();
    const incident = useSelector((state) => selectors2.selectById(state, id));
    const hasIncident = Boolean(incident && "attendees" in incident);
    const hasNotes = Boolean(incident?.notes);
    (0, import_react21.useEffect)(() => {
      if (hasIncident) return;
      trigger(id);
    }, [hasIncident, id, trigger]);
    if (!incident) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(modal_default, { className: "incident-modal", deactivate, isActive, children: /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("section", { className: "modal-incident", children: [
      /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("header", { className: "incident-header", children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(item_subhead_default, { title: /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)(import_jsx_runtime25.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(icon_default, { name: "thumbtack" }),
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("span", { className: "item-text", children: "Lobbying Incident" })
      ] }) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("main", { className: "incident-main", children: [
        /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(incident_table_default, { incident }),
        hasNotes && /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(meta_section_default, { children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
          incident_notes_box_default,
          {
            title: "Notes about this incident",
            incident
          }
        ) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("footer", { className: "incident-footer", children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(item_text_with_icon_default, { icon: "link", children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(LinkToIncident, { id: incident.id, children: "View the full record" }) }) })
    ] }) });
  };
  var incident_modal_default = IncidentModal;

  // assets/scripts/components/header-intro.tsx
  var import_jsx_runtime26 = __toESM(require_jsx_runtime());
  var dateRangeMessage = "Some incident dates appear to be anomalous and have been omitted from this range, pending official word from the City Auditor\u2019s office. Refer to individual incident records for more details.";
  var DateRangeNote = () => {
    const dispatch = useDispatch();
    const handleClick = (event) => {
      event.preventDefault();
      event.stopPropagation();
      dispatch(actions2.setMessage({
        message: dateRangeMessage
      }));
    };
    return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("span", { className: "global-date-range-note", onClick: handleClick, children: /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(icon_default, { name: "asterisk" }) });
  };
  var HeaderIntro = () => {
    const { pathname } = useLocation();
    const [savedPathname, setSavedPathname] = (0, import_react22.useState)(pathname);
    const [selectedId, setSelectedId] = (0, import_react22.useState)();
    const total = useSelector(getIncidentTotal);
    const first = useSelector(getIncidentFirst);
    const last = useSelector(getIncidentLast);
    const hasFirst = Boolean(first);
    const hasLast = Boolean(last);
    const hasData = total > 0 && hasFirst && hasLast;
    const deactivate = () => setSelectedId(null);
    const handleClick = (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (event.target instanceof HTMLAnchorElement) {
        setSelectedId(Number(event.target.dataset.id));
      }
    };
    (0, import_react22.useEffect)(() => {
      setSavedPathname(pathname);
    }, [setSavedPathname, pathname]);
    (0, import_react22.useEffect)(() => {
      if (pathname !== savedPathname) {
        setSelectedId(null);
      }
    }, [pathname, savedPathname, setSelectedId]);
    if (!hasData) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("div", { className: "header-intro", children: [
      /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)("p", { children: [
        "The Big Blink remixes lobbying data published by the City of Portland, Oregon, including",
        " ",
        /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)(LinkToIncidents, { children: [
          total,
          " lobbying incidents"
        ] }),
        " ",
        "reported between",
        " ",
        /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(LinkToIncident, { id: first.id, "data-id": first.id, onClick: handleClick, children: first.contactDate }),
        " ",
        "and",
        " ",
        /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(LinkToIncident, { id: last.id, "data-id": last.id, onClick: handleClick, children: last.contactDate }),
        ".",
        " ",
        /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(DateRangeNote, {})
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
        incident_modal_default,
        {
          deactivate,
          id: first.id,
          isActive: selectedId === first.id
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(
        incident_modal_default,
        {
          deactivate,
          id: last.id,
          isActive: selectedId === last.id
        }
      )
    ] });
  };
  var header_intro_default = HeaderIntro;

  // assets/scripts/components/section.tsx
  var import_jsx_runtime27 = __toESM(require_jsx_runtime());
  var Section = ({
    children,
    className,
    icon: icon2,
    title
  }) => {
    const location2 = useLocation();
    const isRoot = location2.pathname === "/";
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsxs)("section", { className: cx("section", className), children: [
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(header_default, { title, icon: icon2, children: isRoot && /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(header_intro_default, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("section", { className: "section-main", children })
    ] });
  };
  var section_default = Section;

  // assets/scripts/hooks/use-capture-scroll-position.ts
  var import_react23 = __toESM(require_react());
  var import_debounce = __toESM(require_debounce());
  var useCaptureScrollPosition = (classNames = []) => {
    const dispatch = useDispatch();
    const [scrollPos, setScrollPos] = (0, import_react23.useState)(0);
    const handleScroll = () => {
      setScrollPos(Number(window.scrollY) * -1);
      if (classNames.some((className) => document.body.classList.contains(className))) {
        setScrollPos(parseInt(document.body.style.top, 10));
      }
    };
    const debounced = (0, import_debounce.default)(handleScroll, 400);
    (0, import_react23.useEffect)(() => {
      window.addEventListener("scroll", debounced);
      return () => {
        window.removeEventListener("scroll", debounced);
      };
    }, [debounced]);
    (0, import_react23.useEffect)(() => {
      dispatch(actions2.setPositionY(scrollPos));
    }, [dispatch, scrollPos]);
  };
  var use_capture_scroll_position_default = useCaptureScrollPosition;

  // assets/scripts/hooks/use-trigger-primary-query.ts
  var import_react24 = __toESM(require_react());
  var useTriggerPrimaryQuery = () => {
    const [trigger] = api_default.useLazyGetPrimaryQuery();
    const location2 = useLocation();
    (0, import_react24.useEffect)(() => {
      const { pathname, search } = location2;
      trigger({ pathname, search });
    }, [location2, trigger]);
  };
  var use_trigger_primary_query_default = useTriggerPrimaryQuery;

  // assets/scripts/components/app.tsx
  var import_jsx_runtime28 = __toESM(require_jsx_runtime());
  var App = () => {
    const [trigger, result] = api_default.useLazyGetOverviewQuery();
    const location2 = useLocation();
    const description = useSelector(getDescription);
    const pageTitle = useSelector(getPageTitle);
    const isHome = location2.pathname === "/";
    const className = ["section", location2.pathname.split("/").at(1)].join("-");
    const scrollCaptureClasses = [hasAlertClass, hasModalClass];
    use_capture_scroll_position_default(scrollCaptureClasses);
    (0, import_react25.useEffect)(() => {
      if (result.isUninitialized) {
        trigger(null);
      }
    }, [result, trigger]);
    use_trigger_primary_query_default();
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)("div", { className: "global-layout", children: [
      /* @__PURE__ */ (0, import_jsx_runtime28.jsxs)(
        HelmetExport,
        {
          defaultTitle: "The Big Blink PDX",
          titleTemplate: "%s \xB7 The Big Blink PDX",
          children: [
            pageTitle && /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("title", { children: pageTitle }),
            description && /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("meta", { name: "description", content: description })
          ]
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(alert_error_default, {}),
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(alert_message_default, {}),
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(alert_warning_default, {}),
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("main", { className: "global-main", children: isHome ? /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Outlet, {}) : /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(section_default, { className, children: /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(Outlet, {}) }) }),
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(global_footer_default, {}),
      /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(ScrollRestoration, {})
    ] });
  };
  var app_default = App;

  // assets/scripts/components/loading.tsx
  var import_react26 = __toESM(require_react());
  var import_jsx_runtime29 = __toESM(require_jsx_runtime());
  var Loading = () => {
    const timedOut = (0, import_react26.useRef)(false);
    (0, import_react26.useEffect)(() => {
      if (!timedOut.current) {
        setTimeout(() => {
          timedOut.current = true;
        }, 250);
      }
    }, [timedOut]);
    if (!timedOut.current) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("div", { className: "loading", children: "..." });
  };
  var loading_default = Loading;

  // assets/scripts/components/pagination.tsx
  var import_jsx_runtime30 = __toESM(require_jsx_runtime());
  var Pagination = ({ pagination, onPageClick }) => {
    const { page, pageCount, pages } = pagination;
    if (!pages) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)("div", { className: "pagination", children: [
      /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { className: "pagination-direction", children: pages.previous ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
        LinkToPage,
        {
          to: pages.previous.link,
          onClick: onPageClick,
          "aria-label": "Previous Page",
          children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(icon_default, { name: "arrow-left" })
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(icon_default, { name: "arrow-left" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { className: "pagination-pages", children: /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)("ul", { children: [
        pages.numbered.map((numberedPage, i) => numberedPage === null ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("li", { className: "pagination-page-ellipsis", children: "..." }, i) : /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("li", { className: cx("pagination-page", {
          "pagination-page-current": numberedPage.value === page,
          "pagination-page-option": numberedPage.value !== page
        }), children: pageCount > 1 ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
          LinkToPage,
          {
            to: numberedPage.link,
            isCurrent: numberedPage.value === page,
            onClick: onPageClick,
            children: numberedPage.label
          }
        ) : numberedPage.label }, i)),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("li", { className: "pagination-page-label", children: "of" }),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("li", { className: "pagination-page pagination-page-total", children: pageCount > 1 ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
          LinkToPage,
          {
            to: pages.last.link,
            onClick: onPageClick,
            children: pages.last.label
          }
        ) : pages.last.label })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("div", { className: "pagination-direction", children: pages.next ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
        LinkToPage,
        {
          to: pages.next.link,
          onClick: onPageClick,
          "aria-label": "Next Page",
          children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(icon_default, { name: "arrow-right" })
        }
      ) : /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(icon_default, { name: "arrow-right" }) })
    ] });
  };
  var pagination_default = Pagination;

  // assets/scripts/components/section-index.tsx
  var import_jsx_runtime31 = __toESM(require_jsx_runtime());
  var SectionIndex = ({
    children,
    className,
    introduction,
    isLoading = true,
    pagination
  }) => /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)("section", { className: cx("section-index", className), children: [
    introduction && /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)("section", { className: "section-index-introduction", children: [
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("h4", { children: "Introduction" }),
      introduction
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("div", { className: "item-content", children: isLoading ? /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(loading_default, {}) : children }),
    pagination && /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("footer", { className: "item-footer", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(pagination_default, { pagination }) })
  ] });
  var section_index_default = SectionIndex;

  // assets/scripts/components/entities/index.tsx
  var import_jsx_runtime32 = __toESM(require_jsx_runtime());
  var EntityItem = ({ id }) => {
    const entity = useSelector((state) => selectors.selectById(state, id));
    const hasTotal = Boolean(entity?.overview?.totals?.values.total.value);
    if (!entity) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("td", { className: "cell-type", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(icon_default2, {}) }),
      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("td", { className: "cell-name", children: hasTotal ? /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(LinkToEntity, { id: entity.id, children: entity.name }) : entity.name }),
      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("td", { className: "cell-total", children: entity.overview?.totals.values.total.value ?? "-" }),
      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("td", { className: "cell-percent", children: entity.overview?.totals.values.percentage.value ?? "-" })
    ] });
  };
  var Introduction = () => /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(import_jsx_runtime32.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)("p", { children: [
      "The entities listed below reported their lobbying activity to the City of Portland. City Code (",
      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("a", { href: "https://www.portland.gov/code/2/12/020", children: "2.12.020" }),
      ") defines a \u201CLobbying entity\u201D as:"
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("blockquote", { children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("p", { children: "any individual, business association, corporation, partnership, association, club, company, business trust, organization or other group who lobbies either by employing or otherwise authorizing a lobbyist to lobby on that person\u2019s behalf." }) })
  ] });
  var Index = () => {
    const pagination = useSelector(getEntitiesPagination);
    const pageIds = useSelector(getEntitiesPageIds);
    const hasPageIds = pageIds?.length > 0;
    return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
      section_index_default,
      {
        pagination,
        introduction: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(Introduction, {}),
        isLoading: !hasPageIds,
        children: /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)("table", { className: "section-index-list", cellPadding: "0", cellSpacing: "0", children: [
          /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)("tr", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("th", { className: "cell-name", colSpan: 2, children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
              SortLink,
              {
                newParams: getSortByParam("name" /* Name */, true),
                defaultSort: "ASC" /* ASC */,
                title: "Sort this list by name",
                children: "Name"
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("th", { className: "cell-total", children: /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
              SortLink,
              {
                newParams: getSortByParam("total" /* Total */),
                defaultSort: "DESC" /* DESC */,
                title: "Sort this list by total",
                children: "Total"
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("th", { className: "cell-percent", children: "%" })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("tbody", { children: pageIds.map((id) => /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(EntityItem, { id }, id)) })
        ] })
      }
    );
  };
  var entities_default2 = Index;

  // assets/scripts/components/entities/detail.tsx
  var import_react35 = __toESM(require_react());

  // assets/scripts/components/incident-date-box.tsx
  var import_react27 = __toESM(require_react());

  // assets/scripts/components/stat-box.tsx
  var import_jsx_runtime33 = __toESM(require_jsx_runtime());
  var StatBox = ({
    children,
    className,
    icon: icon2,
    onClick,
    title
  }) => /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(
    "div",
    {
      className: cx(
        "activity-stat",
        className,
        icon2 && "has-icon"
      ),
      children: [
        icon2 && /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(icon_default, { name: icon2 }),
        /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)("div", { className: "activity-stat-content", children: [
          title && /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("h6", { className: "activity-stat-titles", children: title && /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("span", { className: "activity-stat-title", children: title }) }),
          /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
            "div",
            {
              className: "activity-stat-value",
              onClick,
              children
            }
          )
        ] })
      ]
    }
  );
  var stat_box_default = StatBox;

  // assets/scripts/components/incident-date-box.tsx
  var import_jsx_runtime34 = __toESM(require_jsx_runtime());
  var IncidentDateBox = ({ incident }) => {
    const [isActive, setIsActive] = (0, import_react27.useState)(false);
    const hasIncident = Boolean(incident?.value);
    const deactivate = () => setIsActive(false);
    const handleLinkClick = (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (event.target instanceof HTMLElement) {
        if (event.target.closest(".activity-stat")) {
          setIsActive(true);
        }
      }
    };
    if (!hasIncident) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)(stat_box_default, { className: "activity-stat-details", title: incident.label, children: [
      /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
        LinkToIncident,
        {
          id: incident.value.id,
          onClick: handleLinkClick,
          children: incident.value.contactDate
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
        incident_modal_default,
        {
          deactivate,
          id: incident.value.id,
          isActive
        }
      )
    ] });
  };
  var incident_date_box_default = IncidentDateBox;

  // assets/scripts/components/incident-activity-chart.tsx
  var import_jsx_runtime35 = __toESM(require_jsx_runtime());
  var IncidentActivityChart = ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("div", { className: "activity-stat item-chart", children });
  var incident_activity_chart_default = IncidentActivityChart;

  // assets/scripts/components/item-description.tsx
  var import_jsx_runtime36 = __toESM(require_jsx_runtime());
  var ItemDescription = ({ children, className }) => /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("div", { className: cx("item-description", className), children });
  var item_description_default = ItemDescription;

  // assets/scripts/components/stat-group.tsx
  var import_jsx_runtime37 = __toESM(require_jsx_runtime());
  var StatGroup = ({
    children,
    className,
    description,
    subtitle,
    title
  }) => /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)("div", { className: cx("activity-stat-group", className), children: [
    title || subtitle ? /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(item_subhead_default, { title, subtitle, children: description && /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(item_description_default, { className: "incident-activity-stat-groups-description", children: description }) }) : null,
    children
  ] });
  var stat_group_default = StatGroup;

  // assets/scripts/components/incident-stat-group.tsx
  var import_jsx_runtime38 = __toESM(require_jsx_runtime());
  var IncidentStatGroup = ({
    children,
    className,
    title
  }) => /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
    stat_group_default,
    {
      className: cx("incident-stat-group", className),
      title,
      children
    }
  );
  var incident_stat_group_default = IncidentStatGroup;

  // assets/scripts/components/stat-group-numbers.tsx
  var import_jsx_runtime39 = __toESM(require_jsx_runtime());
  var NumbersGroup = ({
    children,
    className,
    title
  }) => /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
    stat_group_default,
    {
      className: cx("activity-numbers", className),
      title,
      children
    }
  );
  var stat_group_numbers_default = NumbersGroup;

  // assets/scripts/components/subsection-subhead.tsx
  var import_jsx_runtime40 = __toESM(require_jsx_runtime());
  var SubsectionSubhead = ({ children, title }) => /* @__PURE__ */ (0, import_jsx_runtime40.jsx)("div", { className: "subsection-header", children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(item_subhead_default, { title, children: children && /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(item_description_default, { children }) }) });
  var subsection_subhead_default = SubsectionSubhead;

  // assets/scripts/components/stat-section.tsx
  var import_jsx_runtime41 = __toESM(require_jsx_runtime());
  var StatSection = ({
    children,
    className,
    description,
    stylized = true,
    subtitle,
    title
  }) => /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)("section", { className: cx("activity-stat-section", className), children: [
    (title || subtitle) && (stylized ? /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(subsection_subhead_default, { title, children: description }) : /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(item_subhead_default, { title, subtitle, children: description && /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(item_description_default, { className: "incident-activity-stat-groups-description", children: description }) })),
    children
  ] });
  var stat_section_default = StatSection;

  // assets/scripts/components/detail-activity-overview.tsx
  var import_jsx_runtime42 = __toESM(require_jsx_runtime());
  var ActivityOverview = ({
    children,
    overview,
    ref
  }) => {
    const hasOverview = Boolean(overview);
    const hasAppearances = Object.values(overview?.appearances?.values ?? {})?.some((value) => value.value);
    const hasTotals = Object.values(overview?.totals?.values ?? {})?.some((value) => value.value);
    const scrollToRef = () => {
      ref.current?.scrollIntoView({ behavior: "smooth" });
    };
    if (!hasOverview) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)("div", { className: "activity-overview", children: [
      hasOverview && /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(stat_section_default, { title: overview.label, stylized: false, children: /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)(stat_group_default, { className: "activity-numbers-and-dates", children: [
        hasTotals && /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)(stat_group_numbers_default, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
            item_subhead_default,
            {
              subtitle: overview.totals.label,
              icon: "chart-line"
            }
          ),
          Object.values(overview.totals.values).map((item) => {
            const isInteractive = item.key === "total";
            return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
              stat_box_default,
              {
                className: isInteractive && "is-interactive",
                onClick: isInteractive ? scrollToRef : void 0,
                title: item.label,
                children: item.value
              },
              item.key
            );
          })
        ] }),
        hasAppearances && /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)(incident_stat_group_default, { className: "activity-dates", children: [
          /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(
            item_subhead_default,
            {
              subtitle: overview.appearances.label,
              icon: "calendar"
            }
          ),
          Object.values(overview.appearances.values).map((item) => /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(incident_date_box_default, { incident: item }, item.key))
        ] })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(stat_section_default, { stylized: false, children: hasOverview && /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(incident_activity_chart_default, { children: hasTotals ? children : /* @__PURE__ */ (0, import_jsx_runtime42.jsx)("p", { children: "No data is available to display." }) }) })
    ] });
  };
  var detail_activity_overview_default = ActivityOverview;

  // assets/scripts/components/entities/attendees.tsx
  var import_react29 = __toESM(require_react());

  // assets/scripts/components/affiliated-item-table.tsx
  var import_react28 = __toESM(require_react());

  // assets/scripts/components/item-table.tsx
  var import_jsx_runtime43 = __toESM(require_jsx_runtime());
  var ItemTable = ({
    children,
    hasAnotherIcon = false,
    hasPercent = false
  }) => /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)("table", { className: "item-table", cellPadding: "0", cellSpacing: "0", children: [
    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("th", { className: "cell-name", colSpan: hasAnotherIcon ? 3 : 2, children: "Name" }),
      /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("th", { className: "cell-total", children: "Total" }),
      hasPercent && /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("th", { className: "cell-percent", children: "%" })
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("tbody", { children })
  ] });
  var item_table_default = ItemTable;

  // assets/scripts/components/affiliated-item-table.tsx
  var import_jsx_runtime44 = __toESM(require_jsx_runtime());
  var AffiliatedItemTable = ({
    affiliatedItems,
    IconCell,
    TitleCell,
    TotalCell,
    label
  }) => {
    const ref = (0, import_react28.useRef)();
    const [showAll, setShowAll] = (0, import_react28.useState)(false);
    const initialCount = 5;
    const items = showAll ? affiliatedItems : affiliatedItems.slice(0, initialCount);
    const hasMoreToShow = affiliatedItems.length > initialCount;
    const hasItems = affiliatedItems.length > 0;
    const scrollToRef = () => {
      setTimeout(() => {
        ref.current?.scrollIntoView({ behavior: "smooth" });
      }, 250);
    };
    return hasItems ? /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)("div", { className: "affiliated-items", ref, children: [
      /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(item_table_default, { children: items.map((item, i) => {
        const hasTotal = Boolean(item.total);
        return /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)("tr", { children: [
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("td", { className: "cell-type", children: /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(IconCell, { item }) }),
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("td", { className: "cell-name", children: /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(TitleCell, { item }) }),
          /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("td", { className: "cell-total", children: hasTotal ? TotalCell ? /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(TotalCell, { item }) : item.total : "-" })
        ] }, i);
      }) }),
      hasMoreToShow && /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("button", { type: "button", className: "button-toggle", onClick: (e) => {
        e.preventDefault();
        scrollToRef();
        setShowAll(!showAll);
      }, children: showAll ? /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, { children: [
        "View top ",
        initialCount,
        " ",
        label
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, { children: [
        "View all ",
        affiliatedItems.length,
        " ",
        label
      ] }) })
    ] }) : /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("div", { className: "affiliated-items no-results", children: "None found" });
  };
  var affiliated_item_table_default = AffiliatedItemTable;

  // assets/scripts/components/affiliated-people-table.tsx
  var import_jsx_runtime45 = __toESM(require_jsx_runtime());
  var AffiliatedPeopleTable = ({ attendees }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(stat_box_default, { title: attendees.label, children: /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(
    affiliated_item_table_default,
    {
      affiliatedItems: attendees.records,
      label: "people",
      IconCell: ({ item }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(icon_default4, { person: item.person }),
      TitleCell: ({ item }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(LinkToPerson, { id: item.person.id, children: item.person.name }),
      TotalCell: ({ item }) => /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(FilterLink, { newParams: getWithPersonParams(item), hasIcon: true, children: item.total })
    }
  ) });
  var affiliated_people_table_default = AffiliatedPeopleTable;

  // assets/scripts/components/incident-activity-groups.tsx
  var import_jsx_runtime46 = __toESM(require_jsx_runtime());
  var IncidentActivityGroups = ({
    children,
    className,
    description,
    title
  }) => /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
    stat_section_default,
    {
      className: cx("incident-activity-stat-groups", className),
      title,
      description,
      children: /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("div", { className: "incident-activity-stat-groups-list", children })
    }
  );
  var incident_activity_groups_default = IncidentActivityGroups;

  // assets/scripts/components/incident-activity-group.tsx
  var import_jsx_runtime47 = __toESM(require_jsx_runtime());
  var IncidentActivityGroup = ({
    children,
    className,
    icon: icon2,
    title
  }) => {
    const hasIcon = Boolean(icon2);
    return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
      stat_group_default,
      {
        className: cx("incident-activity-stat-group", className),
        subtitle: /* @__PURE__ */ (0, import_jsx_runtime47.jsxs)(import_jsx_runtime47.Fragment, { children: [
          hasIcon && /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(icon_default, { name: icon2 }),
          /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("span", { className: "item-text", children: title })
        ] }),
        children: children && /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("div", { className: "item-subsection", children })
      }
    );
  };
  var incident_activity_group_default = IncidentActivityGroup;

  // assets/scripts/components/entities/attendees.tsx
  var import_jsx_runtime48 = __toESM(require_jsx_runtime());
  var Attendees2 = ({
    attendees,
    entity
  }) => {
    const [trigger] = api_default.useLazyGetEntityAttendeesByIdQuery();
    const hasAttendees = "attendees" in entity;
    (0, import_react29.useEffect)(() => {
      if (!hasAttendees) {
        trigger(entity.id);
      }
    }, [entity, hasAttendees, trigger]);
    return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(
      incident_activity_groups_default,
      {
        title: "Associated Names",
        description: `These people appear in lobbying reports related to ${entity.name}${entity.name.endsWith(".") ? "" : "."}`,
        children: attendees ? /* @__PURE__ */ (0, import_jsx_runtime48.jsxs)(
          incident_activity_group_default,
          {
            icon: "building",
            title: attendees.label,
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(affiliated_people_table_default, { attendees: attendees.officials }),
              /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(affiliated_people_table_default, { attendees: attendees.lobbyists })
            ]
          }
        ) : null
      }
    );
  };
  var attendees_default = Attendees2;

  // assets/scripts/components/entities/chart.tsx
  var import_react32 = __toESM(require_react());

  // assets/scripts/components/item-chart.tsx
  var import_react31 = __toESM(require_react());

  // node_modules/@kurkle/color/dist/color.esm.js
  function round(v) {
    return v + 0.5 | 0;
  }
  var lim = (v, l, h) => Math.max(Math.min(v, h), l);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b) => hex[b & 15];
  var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
  var eq = (b) => (b & 240) >> 4 === (b & 15);
  var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a, f) => a < 255 ? f(a) : "";
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h, s2, l) {
    const a = s2 * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h, s2, v) {
    const f = (n, k = (n + h / 60) % 6) => v - v * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h, w2, b) {
    const rgb = hsl2rgbn(h, 1, 0.5);
    let i;
    if (w2 + b > 1) {
      i = 1 / (w2 + b);
      w2 *= i;
      b *= i;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] *= 1 - w2 - b;
      rgb[i] += w2;
    }
    return rgb;
  }
  function hueValue(r2, g2, b, d, max) {
    if (r2 === max) {
      return (g2 - b) / d + (g2 < b ? 6 : 0);
    }
    if (g2 === max) {
      return (b - r2) / d + 2;
    }
    return (r2 - g2) / d + 4;
  }
  function rgb2hsl(v) {
    const range = 255;
    const r2 = v.r / range;
    const g2 = v.g / range;
    const b = v.b / range;
    const max = Math.max(r2, g2, b);
    const min = Math.min(r2, g2, b);
    const l = (max + min) / 2;
    let h, s2, d;
    if (max !== min) {
      d = max - min;
      s2 = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = hueValue(r2, g2, b, d, max);
      h = h * 60 + 0.5;
    }
    return [h | 0, s2 || 0, l];
  }
  function calln(f, a, b, c) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
  }
  function hsl2rgb(h, s2, l) {
    return calln(hsl2rgbn, h, s2, l);
  }
  function hwb2rgb(h, w2, b) {
    return calln(hwb2rgbn, h, w2, b);
  }
  function hsv2rgb(h, s2, v) {
    return calln(hsv2rgbn, h, s2, v);
  }
  function hue(h) {
    return (h % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m) {
      return;
    }
    if (m[5] !== v) {
      a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    }
    const h = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === "hwb") {
      v = hwb2rgb(h, p1, p2);
    } else if (m[1] === "hsv") {
      v = hsv2rgb(h, p1, p2);
    } else {
      v = hsl2rgb(h, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a
    };
  }
  function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a = rgb2hsl(v);
    const h = a[0];
    const s2 = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h}, ${s2}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s2}%, ${l}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i, j, k, ok, nk;
    for (i = 0; i < keys.length; i++) {
      ok = nk = keys[i];
      for (j = 0; j < tkeys.length; j++) {
        k = tkeys[j];
        nk = nk.replace(k, map[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a = names[str.toLowerCase()];
    return a && {
      r: a[0],
      g: a[1],
      b: a[2],
      a: a.length === 4 ? a[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a = 255;
    let r2, g2, b;
    if (!m) {
      return;
    }
    if (m[7] !== r2) {
      const v = +m[7];
      a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r2 = +m[1];
    g2 = +m[3];
    b = +m[5];
    r2 = 255 & (m[2] ? p2b(r2) : lim(r2, 0, 255));
    g2 = 255 & (m[4] ? p2b(g2) : lim(g2, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r: r2,
      g: g2,
      b,
      a
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  var from2 = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate(rgb1, rgb2, t2) {
    const r2 = from2(b2n(rgb1.r));
    const g2 = from2(b2n(rgb1.g));
    const b = from2(b2n(rgb1.b));
    return {
      r: n2b(to(r2 + t2 * (from2(b2n(rgb2.r)) - r2))),
      g: n2b(to(g2 + t2 * (from2(b2n(rgb2.g)) - g2))),
      b: n2b(to(b + t2 * (from2(b2n(rgb2.b)) - b))),
      a: rgb1.a + t2 * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone(v, proto2) {
    return v ? Object.assign(proto2 || {}, v) : v;
  }
  function fromObject(input) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class _Color {
    constructor(input) {
      if (input instanceof _Color) {
        return input;
      }
      const type = typeof input;
      let v;
      if (type === "object") {
        v = fromObject(input);
      } else if (type === "string") {
        v = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c2 = color2.rgb;
        let w2;
        const p2 = weight === w2 ? 0.5 : weight;
        const w3 = 2 * p2 - 1;
        const a = c1.a - c2.a;
        const w1 = ((w3 * a === -1 ? w3 : (w3 + a) / (1 + w3 * a)) + 1) / 2;
        w2 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p2 * c1.a + (1 - p2) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t2) {
      if (color2) {
        this._rgb = interpolate(this._rgb, color2._rgb, t2);
      }
      return this;
    }
    clone() {
      return new _Color(this.rgb);
    }
    alpha(a) {
      this._rgb.a = n2b(a);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };

  // node_modules/chart.js/dist/chunks/helpers.segment.js
  function noop4() {
  }
  var uid = /* @__PURE__ */ (() => {
    let id = 0;
    return () => id++;
  })();
  function isNullOrUndef(value) {
    return value === null || value === void 0;
  }
  function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject4(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
  }
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === "function") {
      return fn.apply(thisArg, args);
    }
  }
  function each2(loopable, fn, thisArg, reverse) {
    let i, len, keys;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i = len - 1; i >= 0; i--) {
          fn.call(thisArg, loopable[i], i);
        }
      } else {
        for (i = 0; i < len; i++) {
          fn.call(thisArg, loopable[i], i);
        }
      }
    } else if (isObject4(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[keys[i]], keys[i]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i = 0, ilen = a0.length; i < ilen; ++i) {
      v0 = a0[i];
      v1 = a1[i];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone2(source) {
    if (isArray(source)) {
      return source.map(clone2);
    }
    if (isObject4(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys[k]] = clone2(source[keys[k]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey2(key) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(key) === -1;
  }
  function _merger(key, target, source, options2) {
    if (!isValidKey2(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject4(tval) && isObject4(sval)) {
      merge3(tval, sval, options2);
    } else {
      target[key] = clone2(sval);
    }
  }
  function merge3(target, source, options2) {
    const sources = isArray(source) ? source : [
      source
    ];
    const ilen = sources.length;
    if (!isObject4(target)) {
      return target;
    }
    options2 = options2 || {};
    const merger = options2.merger || _merger;
    let current2;
    for (let i = 0; i < ilen; ++i) {
      current2 = sources[i];
      if (!isObject4(current2)) {
        continue;
      }
      const keys = Object.keys(current2);
      for (let k = 0, klen = keys.length; k < klen; ++k) {
        merger(keys[k], target, current2, options2);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge3(target, source, {
      merger: _mergerIf
    });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey2(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject4(tval) && isObject4(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone2(sval);
    }
  }
  var keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (v) => v,
    // default resolvers
    x: (o2) => o2.x,
    y: (o2) => o2.y
  };
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k of keys) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction2 = (value) => typeof value === "function";
  var setsEqual = (a, b) => {
    if (a.size !== b.size) {
      return false;
    }
    for (const item of a) {
      if (!b.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function almostEquals(x2, y, epsilon) {
    return Math.abs(x2 - y) < epsilon;
  }
  function niceNum(range) {
    const roundedRange = Math.round(range);
    range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
    const niceRange = Math.pow(10, Math.floor(log10(range)));
    const fraction = range / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for (i = 1; i < sqrt; i++) {
      if (value % i === 0) {
        result.push(i);
        result.push(value / i);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a, b) => a - b).pop();
    return result;
  }
  function isNonPrimitive(n) {
    return typeof n === "symbol" || typeof n === "object" && n !== null && !(Symbol.toPrimitive in n || "toString" in n || "valueOf" in n);
  }
  function isNumber(n) {
    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
  }
  function almostWhole(x2, epsilon) {
    const rounded = Math.round(x2);
    return rounded - epsilon <= x2 && rounded + epsilon >= x2;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for (i = 0, ilen = array.length; i < ilen; i++) {
      value = array[i][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x2) {
    if (!isNumberFinite(x2)) {
      return;
    }
    let e = 1;
    let p2 = 0;
    while (Math.round(x2 * e) / e !== x2) {
      e *= 10;
      p2++;
    }
    return p2;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start, end2, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s2 = _normalizeAngle(start);
    const e = _normalizeAngle(end2);
    const angleToStart = _normalizeAngle(s2 - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s2);
    const endToAngle = _normalizeAngle(a - e);
    return a === s2 || a === e || sameAngleIsFullCircle && s2 === e || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start, end2, epsilon = 1e-6) {
    return value >= Math.min(start, end2) - epsilon && value <= Math.max(start, end2) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index) => table[index] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return {
      lo,
      hi
    };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index) => {
    const ti = table[index][key];
    return ti < value || ti === value && table[index + 1][key] === value;
  } : (index) => table[index][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index) => table[index][key] >= value);
  function _filterBetween(values, min, max) {
    let start = 0;
    let end2 = values.length;
    while (start < end2 && values[start] < min) {
      start++;
    }
    while (end2 > start && values[end2 - 1] > max) {
      end2--;
    }
    return start > 0 || end2 < values.length ? values.slice(start, end2) : values;
  }
  var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function listenArrayEvents(array, listener3) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener3);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          listener3
        ]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener3) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index = listeners.indexOf(listener3);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set7 = new Set(items);
    if (set7.size === items.length) {
      return items;
    }
    return Array.from(set7);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
      argsToUse = args;
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn.apply(thisArg, argsToUse);
        });
      }
    };
  }
  function debounce2(fn, delay) {
    let timeout2;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout2);
        timeout2 = setTimeout(fn, delay, args);
      } else {
        fn.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start, end2) => align === "start" ? start : align === "end" ? end2 : (start + end2) / 2;
  var _textX = (align, left, right, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, vScale, _parsed } = meta;
      const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
      const axis = iScale.axis;
      const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start = Math.min(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, axis, min).lo,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
        );
        if (spanGaps) {
          const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          start -= Math.max(0, distanceToDefinedLo);
        }
        start = _limitValue(start, 0, pointCount - 1);
      }
      if (maxDefined) {
        let end2 = Math.max(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
        );
        if (spanGaps) {
          const distanceToDefinedHi = _parsed.slice(end2 - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          end2 += Math.max(0, distanceToDefinedHi);
        }
        count = _limitValue(end2, start, pointCount) - start;
      } else {
        count = pointCount - start;
      }
    }
    return {
      start,
      count
    };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t2) => t2 === 0 || t2 === 1;
  var elasticIn = (t2, s2, p2) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s2) * TAU / p2));
  var elasticOut = (t2, s2, p2) => Math.pow(2, -10 * t2) * Math.sin((t2 - s2) * TAU / p2) + 1;
  var effects = {
    linear: (t2) => t2,
    easeInQuad: (t2) => t2 * t2,
    easeOutQuad: (t2) => -t2 * (t2 - 2),
    easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
    easeInCubic: (t2) => t2 * t2 * t2,
    easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
    easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
    easeInQuart: (t2) => t2 * t2 * t2 * t2,
    easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
    easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
    easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
    easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
    easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
    easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
    easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
    easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
    easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
    easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
    easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
    easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
    easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
    easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
    easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
    easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
    easeInOutElastic(t2) {
      const s2 = 0.1125;
      const p2 = 0.45;
      return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s2, p2) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s2, p2);
    },
    easeInBack(t2) {
      const s2 = 1.70158;
      return t2 * t2 * ((s2 + 1) * t2 - s2);
    },
    easeOutBack(t2) {
      const s2 = 1.70158;
      return (t2 -= 1) * t2 * ((s2 + 1) * t2 + s2) + 1;
    },
    easeInOutBack(t2) {
      let s2 = 1.70158;
      if ((t2 /= 0.5) < 1) {
        return 0.5 * (t2 * t2 * (((s2 *= 1.525) + 1) * t2 - s2));
      }
      return 0.5 * ((t2 -= 2) * t2 * (((s2 *= 1.525) + 1) * t2 + s2) + 2);
    },
    easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
    easeOutBounce(t2) {
      const m = 7.5625;
      const d = 2.75;
      if (t2 < 1 / d) {
        return m * t2 * t2;
      }
      if (t2 < 2 / d) {
        return m * (t2 -= 1.5 / d) * t2 + 0.75;
      }
      if (t2 < 2.5 / d) {
        return m * (t2 -= 2.25 / d) * t2 + 0.9375;
      }
      return m * (t2 -= 2.625 / d) * t2 + 0.984375;
    },
    easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ];
  var colors = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function applyAnimationsDefaults(defaults2) {
    defaults2.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    defaults2.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
    });
    defaults2.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers
      }
    });
    defaults2.describe("animations", {
      _fallback: "animation"
    });
    defaults2.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v) => v | 0
          }
        }
      }
    });
  }
  function applyLayoutsDefaults(defaults2) {
    defaults2.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options2) {
    options2 = options2 || {};
    const cacheKey = locale + JSON.stringify(options2);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options2);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale, options2) {
    return getNumberFormat(locale, options2).format(num);
  }
  var formatters = {
    values(value) {
      return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options2 = {
        notation,
        minimumFractionDigits: numDecimal,
        maximumFractionDigits: numDecimal
      };
      Object.assign(options2, this.options.ticks.format);
      return formatNumber(tickValue, locale, options2);
    },
    logarithmic(tickValue, index, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if ([
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(remain) || index > 0.8 * ticks.length) {
        return formatters.numeric.call(this, tickValue, index, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = {
    formatters
  };
  function applyScaleDefaults(defaults2) {
    defaults2.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      clip: true,
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options2) => options2.lineWidth,
        tickColor: (_ctx, options2) => options2.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults2.route("scale.ticks", "color", "", "color");
    defaults2.route("scale.grid", "color", "", "borderColor");
    defaults2.route("scale.border", "color", "", "borderColor");
    defaults2.route("scale.title", "color", "", "color");
    defaults2.describe("scale", {
      _fallback: false,
      _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
      _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
    });
    defaults2.describe("scales", {
      _fallback: "scale"
    });
    defaults2.describe("scale.ticks", {
      _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
      _indexable: (name) => name !== "backdropPadding"
    });
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node2, key) {
    if (!key) {
      return node2;
    }
    const keys = key.split(".");
    for (let i = 0, n = keys.length; i < n; ++i) {
      const k = keys[i];
      node2 = node2[k] || (node2[k] = /* @__PURE__ */ Object.create(null));
    }
    return node2;
  }
  function set6(root, scope, values) {
    if (typeof scope === "string") {
      return merge3(getScope$1(root, scope), values);
    }
    return merge3(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2, _appliers) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options2) => getHoverColor(options2.backgroundColor);
      this.hoverBorderColor = (ctx, options2) => getHoverColor(options2.borderColor);
      this.hoverColor = (ctx, options2) => getHoverColor(options2.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
      this.apply(_appliers);
    }
    set(scope, values) {
      return set6(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set6(descriptors, scope, values);
    }
    override(scope, values) {
      return set6(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name],
          writable: true
        },
        [name]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject4(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
    apply(appliers) {
      appliers.forEach((apply) => apply(this));
    }
  };
  var defaults = /* @__PURE__ */ new Defaults({
    _scriptable: (name) => !name.startsWith("on"),
    _indexable: (name) => name !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
  ]);
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data2, gc, longest, string) {
    let textWidth = data2[string];
    if (!textWidth) {
      textWidth = data2[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache4) {
    cache4 = cache4 || {};
    let data2 = cache4.data = cache4.data || {};
    let gc = cache4.garbageCollect = cache4.garbageCollect || [];
    if (cache4.font !== font) {
      data2 = cache4.data = {};
      gc = cache4.garbageCollect = [];
      cache4.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for (i = 0; i < ilen; i++) {
      thing = arrayOfThings[i];
      if (thing !== void 0 && thing !== null && !isArray(thing)) {
        longest = _measureText(ctx, data2, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j = 0, jlen = thing.length; j < jlen; j++) {
          nestedThing = thing[j];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data2, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i = 0; i < gcLen; i++) {
        delete data2[gc[i]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    if (!ctx && !canvas) {
      return;
    }
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options2, x2, y) {
    drawPointLegend(ctx, options2, x2, y, null);
  }
  function drawPointLegend(ctx, options2, x2, y, w2) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options2.pointStyle;
    const rotation = options2.rotation;
    const radius = options2.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x2, y);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      // Default includes circle
      default:
        if (w2) {
          ctx.ellipse(x2, y, w2 / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x2, y, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        width = w2 ? w2 / 2 : radius;
        ctx.moveTo(x2 + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x2 + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x2 + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        xOffsetW = Math.cos(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        yOffsetW = Math.sin(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
        ctx.arc(x2 - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x2 + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x2 + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x2 - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w2 ? w2 / 2 : size;
          ctx.rect(x2 - width, y - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      /* falls through */
      case "rectRot":
        xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y - yOffset);
        ctx.lineTo(x2 + yOffsetW, y - xOffset);
        ctx.lineTo(x2 + xOffsetW, y + yOffset);
        ctx.lineTo(x2 - yOffsetW, y + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      /* falls through */
      case "cross":
        xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y - yOffset);
        ctx.lineTo(x2 + xOffsetW, y + yOffset);
        ctx.moveTo(x2 + yOffsetW, y - xOffset);
        ctx.lineTo(x2 - yOffsetW, y + xOffset);
        break;
      case "star":
        xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y - yOffset);
        ctx.lineTo(x2 + xOffsetW, y + yOffset);
        ctx.moveTo(x2 + yOffsetW, y - xOffset);
        ctx.lineTo(x2 - yOffsetW, y + xOffset);
        rad += QUARTER_PI;
        xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius);
        ctx.moveTo(x2 - xOffsetW, y - yOffset);
        ctx.lineTo(x2 + xOffsetW, y + yOffset);
        ctx.moveTo(x2 + yOffsetW, y - xOffset);
        ctx.lineTo(x2 - yOffsetW, y + xOffset);
        break;
      case "line":
        xOffset = w2 ? w2 / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x2 - xOffset, y - yOffset);
        ctx.lineTo(x2 + xOffset, y + yOffset);
        break;
      case "dash":
        ctx.moveTo(x2, y);
        ctx.lineTo(x2 + Math.cos(rad) * (w2 ? w2 / 2 : radius), y + Math.sin(rad) * radius);
        break;
      case false:
        ctx.closePath();
        break;
    }
    ctx.fill();
    if (options2.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x2, y, line2, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line2);
      const left = x2 - metrics.actualBoundingBoxLeft;
      const right = x2 + metrics.actualBoundingBoxRight;
      const top = y - metrics.actualBoundingBoxAscent;
      const bottom = y + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left, yDecoration);
      ctx.lineTo(right, yDecoration);
      ctx.stroke();
    }
  }
  function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
  }
  function renderText(ctx, text2, x2, y, font, opts = {}) {
    const lines = isArray(text2) ? text2 : [
      text2
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i, line2;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i = 0; i < lines.length; ++i) {
      line2 = lines[i];
      if (opts.backdrop) {
        drawBackdrop(ctx, opts.backdrop);
      }
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line2, x2, y, opts.maxWidth);
      }
      ctx.fillText(line2, x2, y, opts.maxWidth);
      decorateText(ctx, x2, y, line2, opts);
      y += Number(font.lineHeight);
    }
    ctx.restore();
  }
  function addRoundedRectPath(ctx, rect) {
    const { x: x2, y, w: w2, h, radius } = rect;
    ctx.arc(x2 + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    ctx.lineTo(x2, y + h - radius.bottomLeft);
    ctx.arc(x2 + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x2 + w2 - radius.bottomRight, y + h);
    ctx.arc(x2 + w2 - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x2 + w2, y + radius.topRight);
    ctx.arc(x2 + w2 - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x2 + radius.topLeft, y);
  }
  var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function toLineHeight(value, size) {
    const matches2 = ("" + value).match(LINE_HEIGHT);
    if (!matches2 || matches2[1] === "normal") {
      return size * 1.2;
    }
    value = +matches2[2];
    switch (matches2[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v) => +v || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject4(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject4(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options2, fallback) {
    options2 = options2 || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options2.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options2.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = void 0;
    }
    const font = {
      family: valueOrDefault(options2.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options2.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options2.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index, info) {
    let cacheable = true;
    let i, ilen, value;
    for (i = 0, ilen = inputs.length; i < ilen; ++i) {
      value = inputs[i];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index !== void 0 && isArray(value)) {
        value = value[index % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min, max } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
    return {
      min: keepZero(min, -Math.abs(change)),
      max: keepZero(max, change)
    };
  }
  function createContext5(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [
    ""
  ], rootScopes, fallback, getTarget = () => scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") {
      fallback = _resolve("_fallback", scopes);
    }
    const cache4 = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: finalRootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([
        scope,
        ...scopes
      ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache4, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache4 = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache4, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults2 = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction2(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction2(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix2, name) => prefix2 ? prefix2 + _capitalize(name) : name;
  var needsSubResolver = (prop, value) => isObject4(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction2(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) {
      return value[_context.index % value.length];
    } else if (isObject4(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction2(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set7, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set7.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
      ...parentScopes,
      ...rootScopes
    ];
    const set7 = /* @__PURE__ */ new Set();
    set7.add(value);
    let key = addScopesFromKey(set7, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (typeof fallback !== "undefined" && fallback !== prop) {
      key = addScopesFromKey(set7, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set7), [
      ""
    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set7, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set7, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject4(value)) {
      return value;
    }
    return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix2 of prefixes) {
      value = _resolve(readKey(prefix2, prop), scopes);
      if (typeof value !== "undefined") {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (typeof value !== "undefined") {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set7 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
        set7.add(key);
      }
    }
    return Array.from(set7);
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current2 = middlePoint;
    const next2 = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current2, previous);
    const d12 = distanceBetweenPoints(next2, current2);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t2 * s01;
    const fb = t2 * s12;
    return {
      previous: {
        x: current2.x - fa * (next2.x - previous.x),
        y: current2.y - fa * (next2.y - previous.y)
      },
      next: {
        x: current2.x + fb * (next2.x - previous.x),
        y: current2.y + fb * (next2.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen - 1; ++i) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i], 0, EPSILON)) {
        mK[i] = mK[i + 1] = 0;
        continue;
      }
      alphaK = mK[i] / deltaK[i];
      betaK = mK[i + 1] / deltaK[i];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i] = alphaK * tauK * deltaK[i];
      mK[i + 1] = betaK * tauK * deltaK[i];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt2, min, max) {
    return Math.max(Math.min(pt2, max), min);
  }
  function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options2, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    if (options2.spanGaps) {
      points = points.filter((pt2) => !pt2.skip);
    }
    if (options2.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev2 = loop ? points[points.length - 1] : points[0];
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        point = points[i];
        controlPoints = splineCurve(prev2, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options2.tension);
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev2 = point;
      }
    }
    if (options2.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node2, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node2.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle2(el).getPropertyValue(property);
  }
  var positions = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function getPositionedStyle(styles2, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i = 0; i < 4; i++) {
      const pos = positions[i];
      result[pos] = parseFloat(styles2[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x2, y, target) => (x2 > 0 || y > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX, offsetY } = source;
    let box = false;
    let x2, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
      x2 = offsetX;
      y = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x2 = source.clientX - rect.left;
      y = source.clientY - rect.top;
      box = true;
    }
    return {
      x: x2,
      y,
      box
    };
  }
  function getRelativePosition(event, chart) {
    if ("native" in event) {
      return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x: x2, y, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x2 - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = canvas && _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v) => Math.round(v * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
      height = containerSize.height;
      width = round1(Math.floor(height * aspectRatio));
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options2 = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      if (_isDomSupported()) {
        window.addEventListener("test", null, options2);
        window.removeEventListener("test", null, options2);
      }
    } catch (e) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches2 = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches2 ? +matches2[1] : void 0;
  }
  function _pointInLine(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: p1.y + t2 * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t2, mode) {
    return {
      x: p1.x + t2 * (p2.x - p1.x),
      y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t2, mode) {
    const cp1 = {
      x: p1.cp2x,
      y: p1.cp2y
    };
    const cp2 = {
      x: p2.cp1x,
      y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t2);
    const b = _pointInLine(cp1, cp2, t2);
    const c = _pointInLine(cp2, p2, t2);
    const d = _pointInLine(a, b, t2);
    const e = _pointInLine(b, c, t2);
    return _pointInLine(d, e, t2);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x2) {
        return rectX + rectX + width - x2;
      },
      setWidth(w2) {
        width = w2;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x2, value) {
        return x2 - value;
      },
      leftForLtr(x2, itemWidth) {
        return x2 - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x2) {
        return x2;
      },
      setWidth(w2) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x2, value) {
        return x2 + value;
      },
      leftForLtr(x2, _itemWidth) {
        return x2;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original2;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original2 = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original2;
    }
  }
  function restoreTextDirection(ctx, original2) {
    if (original2 !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original2[0], original2[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a, b) => a - b,
      normalize: (x2) => x2
    };
  }
  function normalizeSegment({ start, end: end2, count, loop, style }) {
    return {
      start: start % count,
      end: end2 % count,
      loop: loop && (end2 - start + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start, end: end2, loop } = segment;
    let i, ilen;
    if (loop) {
      start += count;
      end2 += count;
      for (i = 0, ilen = count; i < ilen; ++i) {
        if (!between(normalize(points[start % count][property]), startBound, endBound)) {
          break;
        }
        start--;
        end2--;
      }
      start %= count;
      end2 %= count;
    }
    if (end2 < start) {
      end2 += count;
    }
    return {
      start,
      end: end2,
      loop,
      style: segment.style
    };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [
        segment
      ];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start, end: end2, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i = start, prev2 = start; i <= end2; ++i) {
      point = points[i % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i : prev2;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({
          start: subStart,
          end: i,
          loop,
          count,
          style
        }));
        subStart = null;
      }
      prev2 = i;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({
        start: subStart,
        end: end2,
        loop,
        count,
        style
      }));
    }
    return result;
  }
  function _boundSegments(line2, bounds) {
    const result = [];
    const segments = line2.segments;
    for (let i = 0; i < segments.length; i++) {
      const sub = _boundSegment(segments[i], line2.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end2 = count - 1;
    if (loop && !spanGaps) {
      while (start < count && !points[start].skip) {
        start++;
      }
    }
    while (start < count && points[start].skip) {
      start++;
    }
    start %= count;
    if (loop) {
      end2 += start;
    }
    while (end2 > start && points[end2 % count].skip) {
      end2--;
    }
    end2 %= count;
    return {
      start,
      end: end2
    };
  }
  function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev2 = points[start];
    let end2;
    for (end2 = start + 1; end2 <= max; ++end2) {
      const cur = points[end2 % count];
      if (cur.skip || cur.stop) {
        if (!prev2.skip) {
          loop = false;
          result.push({
            start: start % count,
            end: (end2 - 1) % count,
            loop
          });
          start = last = cur.stop ? end2 : null;
        }
      } else {
        last = end2;
        if (prev2.skip) {
          start = end2;
        }
      }
      prev2 = cur;
    }
    if (last !== null) {
      result.push({
        start: start % count,
        end: last % count,
        loop
      });
    }
    return result;
  }
  function _computeSegments(line2, segmentOptions) {
    const points = line2.points;
    const spanGaps = line2.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line2._loop;
    const { start, end: end2 } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line2, [
        {
          start,
          end: end2,
          loop
        }
      ], points, segmentOptions);
    }
    const max = end2 < start ? end2 + count : end2;
    const completeLoop = !!line2._fullLoop && start === 0 && end2 === count - 1;
    return splitByStyles(line2, solidSegments(points, start, max, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line2, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line2, segments, points, segmentOptions);
  }
  function doSplitByStyles(line2, segments, points, segmentOptions) {
    const chartContext = line2._chart.getContext();
    const baseStyle = readStyle(line2.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line2;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i = start;
    function addStyle(s2, e, l, st) {
      const dir = spanGaps ? -1 : 1;
      if (s2 === e) {
        return;
      }
      s2 += count;
      while (points[s2 % count].skip) {
        s2 -= dir;
      }
      while (points[e % count].skip) {
        e += dir;
      }
      if (s2 % count !== e % count) {
        result.push({
          start: s2 % count,
          end: e % count,
          loop: l,
          style: st
        });
        prevStyle = st;
        start = e % count;
      }
    }
    for (const segment of segments) {
      start = spanGaps ? start : segment.start;
      let prev2 = points[start % count];
      let style;
      for (i = start + 1; i <= segment.end; i++) {
        const pt2 = points[i % count];
        style = readStyle(segmentOptions.setContext(createContext5(chartContext, {
          type: "segment",
          p0: prev2,
          p1: pt2,
          p0DataIndex: (i - 1) % count,
          p1DataIndex: i % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start, i - 1, segment.loop, prevStyle);
        }
        prev2 = pt2;
        prevStyle = style;
      }
      if (start < i - 1) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options2) {
    return {
      backgroundColor: options2.backgroundColor,
      borderCapStyle: options2.borderCapStyle,
      borderDash: options2.borderDash,
      borderDashOffset: options2.borderDashOffset,
      borderJoinStyle: options2.borderJoinStyle,
      borderWidth: options2.borderWidth,
      borderColor: options2.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    if (!prevStyle) {
      return false;
    }
    const cache4 = [];
    const replacer = function(key, value) {
      if (!isPatternOrGradient(value)) {
        return value;
      }
      if (!cache4.includes(value)) {
        cache4.push(value);
      }
      return cache4.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
  }

  // node_modules/chart.js/dist/chart.js
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn) => fn({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i = items.length - 1;
        let draw2 = false;
        let item;
        for (; i >= 0; --i) {
          item = items[i];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      for (; i >= 0; --i) {
        items[i].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = /* @__PURE__ */ new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from3, to2, factor) {
      return factor > 0.5 ? to2 : from3;
    },
    color(from3, to2, factor) {
      const c0 = color(from3 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from3, to2, factor) {
      return from3 + (to2 - from3) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      const from3 = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from3];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from3;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        this._from = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from3 = this._from;
      const loop = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from3 !== to2 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from3;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from3, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({
          res,
          rej
        });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i = 0; i < promises.length; i++) {
        promises[i][method]();
      }
    }
  };
  var Animations = class {
    constructor(chart, config2) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config2);
    }
    configure(config2) {
      if (!isObject4(config2)) {
        return;
      }
      const animationOptions = Object.keys(defaults.animation);
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config2).forEach((key) => {
        const cfg = config2[key];
        if (!isObject4(cfg)) {
          return;
        }
        const resolved = {};
        for (const option of animationOptions) {
          resolved[option] = cfg[option];
        }
        (isArray(cfg.properties) && cfg.properties || [
          key
        ]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options2 = resolveTargetOptions(target, newOptions);
      if (!options2) {
        return [];
      }
      const animations = this._createAnimations(options2, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i;
      for (i = props.length - 1; i >= 0; --i) {
        const prop = props[i];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i = 0; i < keys.length; i++) {
      const anim = animations[keys[i]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options2 = target.options;
    if (!options2) {
      target.options = newOptions;
      return;
    }
    if (options2.$shared) {
      target.options = options2 = Object.assign({}, options2, {
        $shared: false,
        $animations: {}
      });
    }
    return options2;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === void 0 ? allowedOverflow : 0;
    const max = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max : min,
      end: reverse ? min : max
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x2 = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
      top: y.end,
      right: x2.end,
      bottom: y.start,
      left: x2.start
    };
  }
  function toClip(value) {
    let t2, r2, b, l;
    if (isObject4(value)) {
      t2 = value.top;
      r2 = value.right;
      b = value.bottom;
      l = value.left;
    } else {
      t2 = r2 = b = l = value;
    }
    return {
      top: t2,
      right: r2,
      bottom: b,
      left: l,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      keys.push(metasets[i].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options2 = {}) {
    const keys = stack.keys;
    const singleMode = options2.mode === "single";
    let i, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    let found = false;
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      datasetIndex = +keys[i];
      if (datasetIndex === dsIndex) {
        found = true;
        if (options2.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
        value += otherValue;
      }
    }
    if (!found && !options2.all) {
      return 0;
    }
    return value;
  }
  function convertObjectDataToArray(data2, meta) {
    const { iScale, vScale } = meta;
    const iAxisKey = iScale.axis === "x" ? "x" : "y";
    const vAxisKey = vScale.axis === "x" ? "x" : "y";
    const keys = Object.keys(data2);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      key = keys[i];
      adata[i] = {
        [iAxisKey]: key,
        [vAxisKey]: data2[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min, max, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i = 0; i < ilen; ++i) {
      const item = parsed[i];
      const { [iAxis]: index, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      const visualValues = stack._visualValues || (stack._visualValues = {});
      visualValues[datasetIndex] = value;
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales = chart.scales;
    return Object.keys(scales).filter((key) => scales[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index) {
    return createContext5(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index,
      index,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index, element) {
    return createContext5(parent, {
      active: false,
      dataIndex: index,
      parsed: void 0,
      raw: void 0,
      element,
      index,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
      if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
        delete stacks[axis]._visualValues[datasetIndex];
      }
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
    keys: getSortedDatasetIndices(chart, true),
    values: null
  };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.datasetElementType = new.target.datasetElementType;
      this.dataElementType = new.target.dataElementType;
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
      if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
        console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x2, y, r2) => axis === "x" ? x2 : axis === "r" ? r2 : y;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta = this._cachedMeta;
      return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data2 = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject4(data2)) {
        const meta = this._cachedMeta;
        this._data = convertObjectDataToArray(data2, meta);
      } else if (_data !== data2) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data2 && Object.isExtensible(data2)) {
          listenArrayEvents(data2, this);
        }
        this._syncList = [];
        this._data = data2;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
        meta._stacked = isStacked(meta.vScale, meta);
      }
    }
    configure() {
      const config2 = this.chart.config;
      const scopeKeys = config2.datasetScopeKeys(this._type);
      const scopes = config2.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config2.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start, count) {
      const { _cachedMeta: meta, _data: data2 } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start === 0 && count === data2.length ? true : meta._sorted;
      let prev2 = start > 0 && meta._parsed[start - 1];
      let i, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data2;
        meta._sorted = true;
        parsed = data2;
      } else {
        if (isArray(data2[start])) {
          parsed = this.parseArrayData(meta, data2, start, count);
        } else if (isObject4(data2[start])) {
          parsed = this.parseObjectData(meta, data2, start, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data2, start, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev2 && cur[iAxis] < prev2[iAxis];
        for (i = 0; i < count; ++i) {
          meta._parsed[i + start] = cur = parsed[i];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev2 = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data2, start, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i, ilen, index;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index = i + start;
        parsed[i] = {
          [iAxis]: singleScale || iScale.parse(labels[index], index),
          [vAxis]: vScale.parse(data2[index], index)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data2, start, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i, ilen, index, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index = i + start;
        item = data2[index];
        parsed[i] = {
          x: xScale.parse(item[0], index),
          y: yScale.parse(item[1], index)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data2, start, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i, ilen, index, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index = i + start;
        item = data2[index];
        parsed[i] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
        };
      }
      return parsed;
    }
    getParsed(index) {
      return this._cachedMeta._parsed[index];
    }
    getDataElement(index) {
      return this._cachedMeta.data[index];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]._visualValues
      };
      return applyStack(stack, value, meta.index, {
        mode
      });
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range.min = Math.min(range.min, value);
      range.max = Math.max(range.max, value);
    }
    getMinMax(scale, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta, this.chart);
      const range = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i, parsed;
      function _skip() {
        parsed = _parsed[i];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i = 0; i < ilen; ++i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i = ilen - 1; i >= 0; --i) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range, scale, parsed, stack);
          break;
        }
      }
      return range;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i, ilen, value;
      for (i = 0, ilen = parsed.length; i < ilen; ++i) {
        value = parsed[i][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start = this._drawStart || 0;
      const count = this._drawCount || elements.length - start;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start, count);
      }
      for (i = start; i < start + count; ++i) {
        const element = elements[i];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i = 0; i < active.length; ++i) {
        active[i].draw(ctx, area);
      }
    }
    getStyle(index, active) {
      const mode = active ? "active" : "default";
      return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
    }
    getContext(index, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index >= 0 && index < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
        context.parsed = this.getParsed(index);
        context.raw = dataset.data[index];
        context.index = context.dataIndex = index;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index);
    }
    _resolveElementOptions(elementType, mode = "default", index) {
      const active = mode === "active";
      const cache4 = this._cachedDataOpts;
      const cacheKey = elementType + "-" + mode;
      const cached = cache4[cacheKey];
      const sharing = this.enableOptionSharing && defined(index);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config2 = this.chart.config;
      const scopeKeys = config2.datasetElementScopeKeys(this._type, elementType);
      const prefixes = active ? [
        `${elementType}Hover`,
        "hover",
        elementType,
        ""
      ] : [
        elementType,
        ""
      ];
      const scopes = config2.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType]);
      const context = () => this.getContext(index, active, mode);
      const values = config2.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache4[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index, transition, active) {
      const chart = this.chart;
      const cache4 = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache4[cacheKey];
      if (cached) {
        return cached;
      }
      let options2;
      if (chart.options.animation !== false) {
        const config2 = this.chart.config;
        const scopeKeys = config2.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config2.getOptionScopes(this.getDataset(), scopeKeys);
        options2 = config2.createResolver(scopes, this.getContext(index, active, transition));
      }
      const animations = new Animations(chart, options2 && options2.animations);
      if (options2 && options2._cacheable) {
        cache4[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options2) {
      if (!options2.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options2));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start, mode) {
      const firstOpts = this.resolveDataElementOptions(start, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return {
        sharedOptions,
        includeOptions
      };
    }
    updateElement(element, index, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index, mode, active) {
      element.active = active;
      const options2 = this.getStyle(index, active);
      this._resolveAnimations(index, mode, active).update(element, {
        options: !active && this.getSharedOptions(options2) || options2
      });
    }
    removeHoverStyle(element, datasetIndex, index) {
      this._setStyle(element, index, "active", false);
    }
    setHoverStyle(element, datasetIndex, index) {
      this._setStyle(element, index, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data2 = this._data;
      const elements = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements.length;
      const numData = data2.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data2 = meta.data;
      const end2 = start + count;
      let i;
      const move = (arr) => {
        arr.length += count;
        for (i = arr.length - 1; i >= end2; i--) {
          arr[i] = arr[i - count];
        }
      };
      move(data2);
      for (i = start; i < end2; ++i) {
        data2[i] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start, count);
      if (resetNewElements) {
        this.updateElements(data2, start, count, "reset");
      }
    }
    updateElements(element, start, count, mode) {
    }
    _removeElements(start, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([
        this.index,
        ...args
      ]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - count,
        count
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(start, count) {
      if (count) {
        this._sync([
          "_removeElements",
          start,
          count
        ]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync([
          "_insertElements",
          start,
          newCount
        ]);
      }
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  };
  __publicField(DatasetController, "defaults", {});
  __publicField(DatasetController, "datasetElementType", null);
  __publicField(DatasetController, "dataElementType", null);
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
        values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i, ilen, curr, prev2;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev2)) {
        min = Math.min(min, Math.abs(curr - prev2) || min);
      }
      prev2 = curr;
    };
    for (i = 0, ilen = values.length; i < ilen; ++i) {
      curr = scale.getPixelForValue(values[i]);
      updateMinAndPrev();
    }
    prev2 = void 0;
    for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
      curr = scale.getPixelForTick(i);
      updateMinAndPrev();
    }
    return min;
  }
  function computeFitCategoryTraits(index, ruler, options2, stackCount) {
    const thickness = options2.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options2.categoryPercentage;
      ratio = options2.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index] - size / 2
    };
  }
  function computeFlexCategoryTraits(index, ruler, options2, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index];
    let prev2 = index > 0 ? pixels[index - 1] : null;
    let next2 = index < pixels.length - 1 ? pixels[index + 1] : null;
    const percent = options2.categoryPercentage;
    if (prev2 === null) {
      prev2 = curr - (next2 === null ? ruler.end - ruler.start : next2 - curr);
    }
    if (next2 === null) {
      next2 = curr + curr - prev2;
    }
    const start = curr - (curr - Math.min(prev2, next2)) / 2 * percent;
    const size = Math.abs(next2 - prev2) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options2.barPercentage,
      start
    };
  }
  function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
      barStart = max;
      barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min,
      max
    };
  }
  function parseValue(entry, item, vScale, i) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i);
    } else {
      item[vScale.axis] = vScale.parse(entry, i);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data2, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      entry = data2[i];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
      parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start, end2, top, bottom;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start = "left";
      end2 = "right";
    } else {
      reverse = properties.base < properties.y;
      start = "bottom";
      end2 = "top";
    }
    if (reverse) {
      top = "end";
      bottom = "start";
    } else {
      top = "start";
      bottom = "end";
    }
    return {
      start,
      end: end2,
      reverse,
      top,
      bottom
    };
  }
  function setBorderSkipped(properties, options2, stack, index) {
    let edge = options2.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start, end: end2, reverse, top, bottom } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index) {
        edge = top;
      } else if ((stack._bottom || 0) === index) {
        edge = bottom;
      } else {
        res[parseEdge(bottom, start, end2, reverse)] = true;
        edge = top;
      }
    }
    res[parseEdge(edge, start, end2, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a, b, reverse) {
    if (reverse) {
      edge = swap(edge, a, b);
      edge = startEnd(edge, b, a);
    } else {
      edge = startEnd(edge, a, b);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start, end2) {
    return v === "start" ? start : v === "end" ? end2 : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data2, start, count) {
      return parseArrayOrPrimitive(meta, data2, start, count);
    }
    parseArrayData(meta, data2, start, count) {
      return parseArrayOrPrimitive(meta, data2, start, count);
    }
    parseObjectData(meta, data2, start, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i, ilen, item, obj;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        obj = data2[i];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
      }
      return parsed;
    }
    updateRangeFromParsed(range, scale, parsed, stack) {
      super.updateRangeFromParsed(range, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range.min = Math.min(range.min, custom.min);
        range.max = Math.max(range.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
      const reset = mode === "reset";
      const { index, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      for (let i = start; i < start + count; i++) {
        const parsed = this.getParsed(i);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
          base,
          head: base
        } : this._calculateBarValuePixels(i);
        const ipixels = this._calculateBarIndexPixels(i, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
        }
        const options2 = properties.options || bars[i].options;
        setBorderSkipped(properties, options2, stack, index);
        setInflateAmount(properties, options2, ruler.ratio);
        this.updateElement(bars[i], i, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
      const iScaleValue = currentParsed && currentParsed[iScale.axis];
      const skipNull = (meta) => {
        const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index) {
      return this._getStacks(void 0, index).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index = name !== void 0 ? stacks.indexOf(name) : -1;
      return index === -1 ? stacks.length - 1 : index;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i, ilen;
      for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
      }
      const barThickness = opts.barThickness;
      const min = barThickness || computeMinSampleSize(meta);
      return {
        min,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index) {
      const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start = 0;
      let length2 = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length2 !== value) {
        start = length2 - value;
        length2 = value;
      }
      if (floating) {
        value = custom.barStart;
        length2 = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start = 0;
        }
        start += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index)) {
        head = vScale.getPixelForValue(start + length2);
      } else {
        head = base;
      }
      size = head - base;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min = Math.min(startPixel, endPixel);
        const max = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max), min);
        head = base + size;
        if (_stacked && !floating) {
          parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
        }
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index, ruler) {
      const scale = ruler.scale;
      const options2 = this.options;
      const skipNull = options2.skipNull;
      const maxBarThickness = valueOrDefault(options2.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
        const range = options2.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options2, stackCount) : computeFitCategoryTraits(index, ruler, options2, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
        center = range.start + range.chunk * stackIndex + range.chunk / 2;
        size = Math.min(maxBarThickness, range.chunk * range.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i = 0;
      for (; i < ilen; ++i) {
        if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
          rects[i].draw(this._ctx);
        }
      }
    }
  };
  __publicField(BarController, "id", "bar");
  __publicField(BarController, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  });
  __publicField(BarController, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  });
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line2, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start = 0;
        count = points.length;
      }
      line2._chart = this.chart;
      line2._datasetIndex = this.index;
      line2._decimated = !!_dataset._decimated;
      line2.points = points;
      const options2 = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options2.borderWidth = 0;
      }
      options2.segment = this.options.segment;
      this.updateElement(line2, void 0, {
        animated: !animationsDisabled,
        options: options2
      }, mode);
      this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      const end2 = start + count;
      const pointsCount = points.length;
      let prevParsed = start > 0 && this.getParsed(start - 1);
      for (let i = 0; i < pointsCount; ++i) {
        const point = points[i];
        const properties = directUpdate ? point : {};
        if (i < start || i >= end2) {
          properties.skip = true;
          continue;
        }
        const parsed = this.getParsed(i);
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data2 = meta.data || [];
      if (!data2.length) {
        return border;
      }
      const firstPoint = data2[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data2[data2.length - 1].size(this.resolveDataElementOptions(data2.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  __publicField(LineController, "id", "line");
  __publicField(LineController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  });
  __publicField(LineController, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapterBase = class _DateAdapterBase {
    constructor(options2) {
      __publicField(this, "options");
      this.options = options2 || {};
    }
    /**
    * Override default date adapter methods.
    * Accepts type parameter to define options type.
    * @example
    * Chart._adapters._date.override<{myAdapterOption: string}>({
    *   init() {
    *     console.log(this.options.myAdapterOption);
    *   }
    * })
    */
    static override(members) {
      Object.assign(_DateAdapterBase.prototype, members);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
    }
    formats() {
      return abstract();
    }
    parse() {
      return abstract();
    }
    format() {
      return abstract();
    }
    add() {
      return abstract();
    }
    diff() {
      return abstract();
    }
    startOf() {
      return abstract();
    }
    endOf() {
      return abstract();
    }
  };
  var adapters5 = {
    _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data: data2, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data2.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        const result = lookupMethod(data2, axis, value);
        if (spanGaps) {
          const { vScale } = controller._cachedMeta;
          const { _parsed } = metaset;
          const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          result.lo -= Math.max(0, distanceToDefinedLo);
          const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          result.hi += Math.max(0, distanceToDefinedHi);
        }
        return result;
      } else if (controller._sharedOptions) {
        const el = data2[0];
        const range = typeof el.getRange === "function" && el.getRange(axis);
        if (range) {
          const start = lookupMethod(data2, axis, value - range);
          const end2 = lookupMethod(data2, axis, value + range);
          return {
            lo: start.lo,
            hi: end2.hi
          };
        }
      }
    }
    return {
      lo: 0,
      hi: data2.length - 1
    };
  }
  function evaluateInteractionItems(chart, axis, position2, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position2[axis];
    for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
      const { index, data: data2 } = metasets[i];
      const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
      for (let j = lo; j <= hi; ++j) {
        const element = data2[j];
        if (!element.skip) {
          handler(element, index, j);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position2, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position2)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position2.x, position2.y, useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index
        });
      }
    };
    evaluateInteractionItems(chart, axis, position2, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position2, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index) {
      const { startAngle, endAngle } = element.getProps([
        "startAngle",
        "endAngle"
      ], useFinalPosition);
      const { angle } = getAngleFromPoint(element, {
        x: position2.x,
        y: position2.y
      });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({
          element,
          datasetIndex,
          index
        });
      }
    }
    evaluateInteractionItems(chart, axis, position2, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position2, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index) {
      const inRange2 = element.inRange(position2.x, position2.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position2, center);
      if (distance < minDistance) {
        items = [
          {
            element,
            datasetIndex,
            index
          }
        ];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({
          element,
          datasetIndex,
          index
        });
      }
    }
    evaluateInteractionItems(chart, axis, position2, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position2, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position2)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position2, axis, useFinalPosition) : getNearestCartesianItems(chart, position2, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position2, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position2, (element, datasetIndex, index) => {
      if (element[rangeMethod] && element[rangeMethod](position2[axis], useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index
        });
        intersectsItem = intersectsItem || element.inRange(position2.x, position2.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e, options2, useFinalPosition) {
        const position2 = getRelativePosition(e, chart);
        const axis = options2.axis || "x";
        const includeInvisible = options2.includeInvisible || false;
        const items = options2.intersect ? getIntersectItems(chart, position2, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position2, axis, false, useFinalPosition, includeInvisible);
        const elements = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index = items[0].index;
          const element = meta.data[index];
          if (element && !element.skip) {
            elements.push({
              element,
              datasetIndex: meta.index,
              index
            });
          }
        });
        return elements;
      },
      dataset(chart, e, options2, useFinalPosition) {
        const position2 = getRelativePosition(e, chart);
        const axis = options2.axis || "xy";
        const includeInvisible = options2.includeInvisible || false;
        let items = options2.intersect ? getIntersectItems(chart, position2, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position2, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data2 = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i = 0; i < data2.length; ++i) {
            items.push({
              element: data2[i],
              datasetIndex,
              index: i
            });
          }
        }
        return items;
      },
      point(chart, e, options2, useFinalPosition) {
        const position2 = getRelativePosition(e, chart);
        const axis = options2.axis || "xy";
        const includeInvisible = options2.includeInvisible || false;
        return getIntersectItems(chart, position2, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e, options2, useFinalPosition) {
        const position2 = getRelativePosition(e, chart);
        const axis = options2.axis || "xy";
        const includeInvisible = options2.includeInvisible || false;
        return getNearestItems(chart, position2, axis, options2.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e, options2, useFinalPosition) {
        const position2 = getRelativePosition(e, chart);
        return getAxisItems(chart, position2, "x", options2.intersect, useFinalPosition);
      },
      y(chart, e, options2, useFinalPosition) {
        const position2 = getRelativePosition(e, chart);
        return getAxisItems(chart, position2, "y", options2.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function filterByPosition(array, position2) {
    return array.filter((v) => v.pos === position2);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a, b) => {
      const v0 = reverse ? b : a;
      const v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
      box = boxes[i];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i, ilen, layout;
    for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
      layout = layouts2[i];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left.concat(top),
      rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left.concat(right).concat(centerVertical),
      horizontal: top.concat(bottom).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject4(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || {
        size: 0,
        count: 1
      };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
      same: widthChanged,
      other: heightChanged
    } : {
      same: heightChanged,
      other: widthChanged
    };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions([
      "left",
      "right"
    ]) : marginForPositions([
      "top",
      "bottom"
    ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
      layout = boxes[i];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left, top, width, height) {
    box.top = top;
    box.left = left;
    box.right = left + width;
    box.bottom = top + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x: x2, y } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y, width, height);
        }
        stack.start = y;
        stack.placed += width;
        y = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x2 = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x2, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x2, chartArea.top + stack.placed, width, height);
        }
        stack.start = x2;
        stack.placed += height;
        x2 = box.right;
      }
    }
    chartArea.x = x2;
    chartArea.y = y;
  }
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [
          {
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }
        ];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index !== -1) {
        chart.boxes.splice(index, 1);
      }
    },
    configure(chart, item, options2) {
      item.fullSize = options2.fullSize;
      item.position = options2.position;
      item.weight = options2.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each2(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each2(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener3) {
    }
    removeEventListener(chart, type, listener3) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config2) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config2) {
      config2.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener2(node2, type, listener3) {
    if (node2) {
      node2.addEventListener(type, listener3, eventListenerOptions);
    }
  }
  function removeListener2(chart, type, listener3) {
    if (chart && chart.canvas) {
      chart.canvas.removeEventListener(type, listener3, eventListenerOptions);
    }
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x: x2, y } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x2 !== void 0 ? x2 : null,
      y: y !== void 0 ? y : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node2 of nodeList) {
      if (node2 === canvas || node2.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener3) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener3();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  function createDetachObserver(chart, type, listener3) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener3();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener3) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w2 = container.clientWidth;
      listener3(width, height);
      if (w2 < container.clientWidth) {
        listener3();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener3) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener3(fromNativeEvent(event, chart));
      }
    }, chart);
    addListener2(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial2 = canvas[EXPANDO_KEY].initial;
      [
        "height",
        "width"
      ].forEach((prop) => {
        const value = initial2[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial2.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener3) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener3);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers[type] || removeListener2;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = canvas && _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var Element2 = class {
    constructor() {
      __publicField(this, "x");
      __publicField(this, "y");
      __publicField(this, "active", false);
      __publicField(this, "options");
      __publicField(this, "$animations");
    }
    tooltipPosition(useFinalPosition) {
      const { x: x2, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x: x2,
        y
      };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  __publicField(Element2, "defaults", {});
  __publicField(Element2, "defaultRoutes");
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
        skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
      const factor = factors[i];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (ticks[i].major) {
        result.push(i);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next2 = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for (i = 0; i < ticks.length; i++) {
      if (i === next2) {
        newTicks.push(ticks[i]);
        count++;
        next2 = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = valueOrDefault(majorStart, 0);
    const end2 = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length2, i, next2;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length2 = majorEnd - majorStart;
      spacing = length2 / Math.floor(length2 / spacing);
    }
    next2 = start;
    while (next2 < 0) {
      count++;
      next2 = Math.round(start + count * spacing);
    }
    for (i = Math.max(start, 0); i < end2; i++) {
      if (i === next2) {
        newTicks.push(ticks[i]);
        count++;
        next2 = Math.round(start + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i = 1; i < len; ++i) {
      if (arr[i] - arr[i - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
  var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for (; i < len; i += increment) {
      result.push(arr[Math.floor(i)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index, offsetGridLines) {
    const length2 = scale.ticks.length;
    const validIndex2 = Math.min(index, length2 - 1);
    const start = scale._startPixel;
    const end2 = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset;
    if (offsetGridLines) {
      if (length2 === 1) {
        offset = Math.max(lineValue - start, end2 - lineValue);
      } else if (index === 0) {
        offset = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index ? offset : -offset;
      if (lineValue < start - epsilon || lineValue > end2 + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length2) {
    each2(caches, (cache4) => {
      const gc = cache4.gc;
      const gcLen = gc.length / 2;
      let i;
      if (gcLen > length2) {
        for (i = 0; i < gcLen; ++i) {
          delete cache4.data[gc[i]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options2) {
    return options2.drawTicks ? options2.tickLength : 0;
  }
  function getTitleHeight(options2, fallback) {
    if (!options2.display) {
      return 0;
    }
    const font = toFont(options2.font, fallback);
    const padding = toPadding(options2.padding);
    const lines = isArray(options2.text) ? options2.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext5(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index, tick) {
    return createContext5(parent, {
      tick,
      index,
      type: "tick"
    });
  }
  function titleAlign(align, position2, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position2 !== "right" || !reverse && position2 === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset, position2, align) {
    const { top, left, bottom, right, chart } = scale;
    const { chartArea, scales } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom - top;
    const width = right - left;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      if (isObject4(position2)) {
        const positionAxisID = Object.keys(position2)[0];
        const value = position2[positionAxisID];
        titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
      } else if (position2 === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
      } else {
        titleY = offsetFromEdge(scale, position2, offset);
      }
      maxWidth = right - left;
    } else {
      if (isObject4(position2)) {
        const positionAxisID = Object.keys(position2)[0];
        const value = position2[positionAxisID];
        titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
      } else if (position2 === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
      } else {
        titleX = offsetFromEdge(scale, position2, offset);
      }
      titleY = _alignStartEnd(align, bottom, top);
      rotation = position2 === "left" ? -HALF_PI : HALF_PI;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  var Scale = class _Scale extends Element2 {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options2) {
      this.options = options2.setContext(this.getContext());
      this.axis = options2.axis;
      this._userMin = this.parse(options2.min);
      this._userMax = this.parse(options2.max);
      this._suggestedMin = this.parse(options2.suggestedMin);
      this._suggestedMax = this.parse(options2.suggestedMax);
    }
    parse(raw, index) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      let range;
      if (minDefined && maxDefined) {
        return {
          min,
          max
        };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i = 0, ilen = metas.length; i < ilen; ++i) {
        range = metas[i].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min = Math.min(min, range.min);
        }
        if (!maxDefined) {
          max = Math.max(max, range.max);
        }
      }
      min = maxDefined && min > max ? max : min;
      max = minDefined && min > max ? min : max;
      return {
        min: finiteOrDefault(min, finiteOrDefault(max, min)),
        max: finiteOrDefault(max, finiteOrDefault(min, max))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data2 = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data2.xLabels : data2.yLabels) || data2.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      return items;
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [
        this
      ]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(name) {
      this.chart.notifyPlugins(name, this.getContext());
      callback(this.options[name], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        tick = ticks[i];
        tick.label = callback(tickOpts.callback, [
          tick.value,
          i,
          ticks
        ], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const options2 = this.options;
      const tickOpts = options2.ticks;
      const numTicks = getTicksLimit(this.ticks.length, options2.ticks.maxTicksLimit);
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options2.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options2.grid) - tickOpts.padding - getTitleHeight(options2.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last, sin, cos) {
      const { ticks: { align, padding }, position: position2 } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position2 !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis, position: position2 } = this.options;
      return position2 === "top" || position2 === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (isNullOrUndef(ticks[i].label)) {
          ticks.splice(i, 1);
          ilen--;
          i--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length2, maxTicksLimit) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      const increment = Math.floor(length2 / getTicksLimit(length2, maxTicksLimit));
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i, j, jlen, label, tickFont, fontString, cache4, lineHeight, width, height, nestedLabel;
      for (i = 0; i < length2; i += increment) {
        label = ticks[i].label;
        tickFont = this._resolveTickFontOptions(i);
        ctx.font = fontString = tickFont.string;
        cache4 = caches[fontString] = caches[fontString] || {
          data: {},
          gc: []
        };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = _measureText(ctx, cache4.data, cache4.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            nestedLabel = label[j];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = _measureText(ctx, cache4.data, cache4.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length2);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({
        width: widths[idx] || 0,
        height: heights[idx] || 0
      });
      return {
        first: valueAt(0),
        last: valueAt(length2 - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index) {
      const ticks = this.ticks;
      if (index < 0 || index > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min, max } = this;
      return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
    getContext(index) {
      const ticks = this.ticks || [];
      if (index >= 0 && index < ticks.length) {
        const tick = ticks[index];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w2 = labelSizes ? labelSizes.widest.width + padding : 0;
      const h = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h * cos > w2 * sin ? w2 / cos : h / sin : h * sin < w2 * cos ? h / cos : w2 / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options2 = this.options;
      const { grid, position: position2, border } = options2;
      const offset = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = borderOpts.display ? borderOpts.width : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
      if (position2 === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y2 = chartArea.bottom;
      } else if (position2 === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position2 === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position2 === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position2 === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject4(position2)) {
          const positionAxisID = Object.keys(position2)[0];
          const value = position2[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y2 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position2 === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject4(position2)) {
          const positionAxisID = Object.keys(position2)[0];
          const value = position2[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options2.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i = 0; i < ticksLength; i += step) {
        const context = this.getContext(i);
        const optsAtIndex = grid.setContext(context);
        const optsAtIndexBorder = border.setContext(context);
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndexBorder.dash || [];
        const borderDashOffset = optsAtIndexBorder.dashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i, offset);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y2 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options2 = this.options;
      const { position: position2, ticks: optionTicks } = options2;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options2.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i, ilen, tick, label, x2, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position2 === "top") {
        y = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position2 === "bottom") {
        y = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position2 === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x2 = ret.x;
      } else if (position2 === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x2 = ret.x;
      } else if (axis === "x") {
        if (position2 === "center") {
          y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject4(position2)) {
          const positionAxisID = Object.keys(position2)[0];
          const value = position2[positionAxisID];
          y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position2 === "center") {
          x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject4(position2)) {
          const positionAxisID = Object.keys(position2)[0];
          const value = position2[positionAxisID];
          x2 = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i));
        pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i);
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x2 = pixel;
          if (textAlign === "inner") {
            if (i === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position2 === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
          if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
            x2 += lineHeight / 2 * Math.sin(rotation);
          }
        } else {
          y = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i];
          const width = labelSizes.widths[i];
          let top = textOffset - labelPadding.top;
          let left = 0 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top -= height / 2;
              break;
            case "bottom":
              top -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left -= width / 2;
              break;
            case "right":
              left -= width;
              break;
            case "inner":
              if (i === ilen - 1) {
                left -= width;
              } else if (i > 0) {
                left -= width / 2;
              }
              break;
          }
          backdrop = {
            left,
            top,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          label,
          font,
          textOffset,
          options: {
            rotation,
            color: color2,
            strokeColor,
            strokeWidth,
            textAlign: tickTextAlign,
            textBaseline,
            translation: [
              x2,
              y
            ],
            backdrop
          }
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position: position2, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position2 === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position: position2, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x2;
      if (position2 === "left") {
        if (mirror) {
          x2 = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 += widest / 2;
          } else {
            textAlign = "right";
            x2 += widest;
          }
        } else {
          x2 = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 -= widest / 2;
          } else {
            textAlign = "left";
            x2 = this.left;
          }
        }
      } else if (position2 === "right") {
        if (mirror) {
          x2 = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 -= widest / 2;
          } else {
            textAlign = "left";
            x2 -= widest;
          }
        } else {
          x2 = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x2 += widest / 2;
          } else {
            textAlign = "right";
            x2 = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return {
        textAlign,
        x: x2
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position2 = this.options.position;
      if (position2 === "left" || position2 === "right") {
        return {
          top: 0,
          left: this.left,
          bottom: chart.height,
          right: this.right
        };
      }
      if (position2 === "top" || position2 === "bottom") {
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: chart.width
        };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left, top, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left, top, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index = ticks.findIndex((t2) => t2.value === value);
      if (index >= 0) {
        const opts = grid.setContext(this.getContext(index));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i, ilen;
      const drawLine = (p1, p2, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          const item = items[i];
          if (grid.drawOnChartArea) {
            drawLine({
              x: item.x1,
              y: item.y1
            }, {
              x: item.x2,
              y: item.y2
            }, item);
          }
          if (grid.drawTicks) {
            drawLine({
              x: item.tx1,
              y: item.ty1
            }, {
              x: item.tx2,
              y: item.ty2
            }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { border, grid } } = this;
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = border.display ? borderOpts.width : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y2;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y2 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.width;
      ctx.strokeStyle = borderOpts.color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this.getLabelItems(chartArea);
      for (const item of items) {
        const renderTextOptions = item.options;
        const tickFont = item.font;
        const label = item.label;
        const y = item.textOffset;
        renderText(ctx, label, 0, y, tickFont, renderTextOptions);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position: position2, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset = font.lineHeight / 2;
      if (position2 === "bottom" || position2 === "center" || isObject4(position2)) {
        offset += padding.bottom;
        if (isArray(title.text)) {
          offset += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position2, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position2, reverse),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      const bz = valueOrDefault(opts.border && opts.border.z, 0);
      if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
        return [
          {
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }
        ];
      }
      return [
        {
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        },
        {
          z: bz,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }
      ];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        const meta = metas[i];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index) {
      const opts = this.options.ticks.setContext(this.getContext(index));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto2 = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto2)) {
        parentScope = this.register(proto2);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults[scope]) {
        delete defaults[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge3(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope),
      item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [
        scope
      ].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto2) {
    return "id" in proto2 && "defaults" in proto2;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element2, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [
        ...args
      ].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each2(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i = 0; i < this._typedRegistries.length; i++) {
        const reg = this._typedRegistries[i];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = /* @__PURE__ */ new Registry();
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [
          chart,
          args,
          descriptor.options
        ];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config2 = chart && chart.config;
      const options2 = valueOrDefault(config2.options && config2.options.plugins, {});
      const plugins3 = allPlugins(config2);
      return options2 === false && !all ? [] : createDescriptors(chart, plugins3, options2, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a, b) => a.filter((x2) => !b.some((y) => x2.plugin.id === y.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config2) {
    const localIds = {};
    const plugins3 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i = 0; i < keys.length; i++) {
      plugins3.push(registry.getPlugin(keys[i]));
    }
    const local = config2.plugins || [];
    for (let i = 0; i < local.length; i++) {
      const plugin = local[i];
      if (plugins3.indexOf(plugin) === -1) {
        plugins3.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return {
      plugins: plugins3,
      localIds
    };
  }
  function getOpts(options2, all) {
    if (!all && options2 === false) {
      return null;
    }
    if (options2 === true) {
      return {};
    }
    return options2;
  }
  function createDescriptors(chart, { plugins: plugins3, localIds }, options2, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins3) {
      const id = plugin.id;
      const opts = getOpts(options2[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, {
          plugin,
          local: localIds[id]
        }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config2, { plugin, local }, opts, context) {
    const keys = config2.pluginScopeKeys(plugin);
    const scopes = config2.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config2.createResolver(scopes, context, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options2) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options2.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options2.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") {
      return id;
    }
  }
  function axisFromPosition(position2) {
    if (position2 === "top" || position2 === "bottom") {
      return "x";
    }
    if (position2 === "left" || position2 === "right") {
      return "y";
    }
  }
  function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
      return id;
    }
    for (const opts of scaleOptions) {
      const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
      if (axis) {
        return axis;
      }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
  }
  function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) {
      return {
        axis
      };
    }
  }
  function retrieveAxisFromDatasets(id, config2) {
    if (config2.data && config2.data.datasets) {
      const boundDs = config2.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
      if (boundDs.length) {
        return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
      }
    }
    return {};
  }
  function mergeScaleConfig(config2, options2) {
    const chartDefaults = overrides[config2.type] || {
      scales: {}
    };
    const configScales = options2.scales || {};
    const chartIndexAxis = getIndexAxis(config2.type, options2);
    const scales = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject4(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config2), defaults.scales[scaleConf.type]);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      scales[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
        {
          axis
        },
        scaleConf,
        defaultScaleOptions[axis],
        defaultScaleOptions[defaultId]
      ]);
    });
    config2.data.datasets.forEach((dataset) => {
      const type = dataset.type || config2.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options2);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || axis;
        scales[id] = scales[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales[id], [
          {
            axis
          },
          configScales[id],
          defaultScaleOptions[defaultID]
        ]);
      });
    });
    Object.keys(scales).forEach((key) => {
      const scale = scales[key];
      mergeIf(scale, [
        defaults.scales[scale.type],
        defaults.scale
      ]);
    });
    return scales;
  }
  function initOptions(config2) {
    const options2 = config2.options || (config2.options = {});
    options2.plugins = valueOrDefault(options2.plugins, {});
    options2.scales = mergeScaleConfig(config2, options2);
  }
  function initData(data2) {
    data2 = data2 || {};
    data2.datasets = data2.datasets || [];
    data2.labels = data2.labels || [];
    return data2;
  }
  function initConfig(config2) {
    config2 = config2 || {};
    config2.data = initData(config2.data);
    initOptions(config2);
    return config2;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set7, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set7.add(opts);
    }
  };
  var Config = class {
    constructor(config2) {
      this._config = initConfig(config2);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data2) {
      this._config.data = initData(data2);
    }
    get options() {
      return this._config.options;
    }
    set options(options2) {
      this._config.options = options2;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config2 = this._config;
      this.clearCache();
      initOptions(config2);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(`${datasetType}.transition.${transition}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
      return cachedKeys(`${datasetType}-${elementType}`, () => [
        [
          `datasets.${datasetType}.elements.${elementType}`,
          `datasets.${datasetType}`,
          `elements.${elementType}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(plugin) {
      const id = plugin.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id}`, () => [
        [
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache4 = _scopeCache.get(mainScope);
      if (!cache4 || resetCache) {
        cache4 = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache4);
      }
      return cache4;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options: options2, type } = this;
      const cache4 = this._cachedScopes(mainScope, resetCache);
      const cached = cache4.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options2, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache4.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options: options2, type } = this;
      return [
        options2,
        overrides[type] || {},
        defaults.datasets[type] || {},
        {
          type
        },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [
      ""
    ]) {
      const result = {
        $shared: true
      };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options2 = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction2(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options2 = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options2[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [
      ""
    ], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject4(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache4 = resolverCache.get(scopes);
    if (!cache4) {
      cache4 = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache4);
    }
    const cacheKey = prefixes.join();
    let cached = cache4.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p2) => !p2.toLowerCase().includes("hover"))
      };
      cache4.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject4(value) && Object.getOwnPropertyNames(value).some((key) => isFunction2(value[key]));
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction2(value) || hasFunction(value)) || indexable && isArray(value)) {
        return true;
      }
    }
    return false;
  }
  var version2 = "4.4.8";
  var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function positionIsHorizontal(position2, axis) {
    return position2 === "top" || position2 === "bottom" || KNOWN_POSITIONS.indexOf(position2) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a, b) {
      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [
      context
    ], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
      context
    ], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c) => c.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e;
  }
  function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
  }
  function getDatasetArea(meta, chartArea) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
      return {
        left: getSizeForArea(xScale, chartArea, "left"),
        right: getSizeForArea(xScale, chartArea, "right"),
        top: getSizeForArea(yScale, chartArea, "top"),
        bottom: getSizeForArea(yScale, chartArea, "bottom")
      };
    }
    return chartArea;
  }
  var Chart = class {
    static register(...items) {
      registry.add(...items);
      invalidatePlugins();
    }
    static unregister(...items) {
      registry.remove(...items);
      invalidatePlugins();
    }
    constructor(item, userConfig) {
      const config2 = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options2 = config2.createResolver(config2.chartOptionScopes(), this.getContext());
      this.platform = new (config2.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config2);
      const context = this.platform.acquireContext(initialCanvas, options2.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options2;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce2((mode) => this.update(mode), options2.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data2) {
      this.config.data = data2;
    }
    get options() {
      return this._options;
    }
    set options(options2) {
      this.config.options = options2;
    }
    get registry() {
      return registry;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = {
          width,
          height
        };
      }
    }
    _resize(width, height) {
      const options2 = this.options;
      const canvas = this.canvas;
      const aspectRatio = options2.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options2.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", {
        size: newSize
      });
      callback(options2.onResize, [
        this,
        newSize
      ], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options2 = this.options;
      const scalesOptions = options2.scales || {};
      each2(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options2 = this.options;
      const scaleOpts = options2.scales;
      const scales = this.scales;
      const updated = Object.keys(scales).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each2(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale = null;
        if (id in scales && scales[id].type === scaleType) {
          scale = scales[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales[scale.id] = scale;
        }
        scale.init(scaleOptions, options2);
      });
      each2(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales[id];
        }
      });
      each2(scales, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a, b) => a.index - b.index);
      if (numMeta > numData) {
        for (let i = numData; i < numMeta; ++i) {
          this._destroyDatasetMeta(i);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index) => {
        if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i, ilen;
      this._removeUnreferencedMetasets();
      for (i = 0, ilen = datasets.length; i < ilen; i++) {
        const dataset = datasets[i];
        let meta = this.getDatasetMeta(i);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i);
          meta = this.getDatasetMeta(i);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i);
        if (meta.controller) {
          meta.controller.updateIndex(i);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each2(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config2 = this.config;
      config2.update();
      const options2 = this._options = config2.createResolver(config2.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options2.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
        const { controller } = this.getDatasetMeta(i);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options2.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each2(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", {
        mode
      });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each2(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options2 = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options2.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options2.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i = 1; i < datasetCount; i++) {
        if (!setsEqual(changeSet, makeSet(i))) {
          return;
        }
      }
      return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
        method: a[1],
        start: +a[2],
        count: +a[3]
      }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each2(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index) => {
        item._idx = index;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this.getDatasetMeta(i).controller.configure();
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._updateDataset(i, isFunction2(mode) ? mode({
          datasetIndex: i
        }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", {
        mode
      });
    }
    _updateDataset(index, mode) {
      const meta = this.getDatasetMeta(index);
      const args = {
        meta,
        index,
        mode,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", {
        cancelable: true
      }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({
          chart: this
        });
      }
    }
    draw() {
      let i;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resizeBeforeDraw = null;
        this._resize(width, height);
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const layers = this._layers;
      for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
        layers[i].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i < layers.length; ++i) {
        layers[i].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        const meta = metasets[i];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        this._drawDataset(metasets[i]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const clip = meta._clip;
      const useClip = !clip.disabled;
      const area = getDatasetArea(meta, this.chartArea);
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? this.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
      }
      meta.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options2, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e, options2, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext5(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index) {
      this._hiddenIndices[index] = !this._hiddenIndices[index];
    }
    getDataVisibility(index) {
      return !this._hiddenIndices[index];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, {
          visible
        });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i, ilen;
      this.stop();
      animator.remove(this);
      for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._destroyDatasetMeta(i);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener4) => {
        platform.addEventListener(this, type, listener4);
        listeners[type] = listener4;
      };
      const listener3 = (e, x2, y) => {
        e.offsetX = x2;
        e.offsetY = y;
        this._eventHandler(e);
      };
      each2(this.options.events, (type) => _add(type, listener3));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener4) => {
        platform.addEventListener(this, type, listener4);
        listeners[type] = listener4;
      };
      const _remove = (type, listener4) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener4);
          delete listeners[type];
        }
      };
      const listener3 = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener3);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener3);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each2(this._listeners, (listener3, type) => {
        this.platform.removeEventListener(this, type, listener3);
      });
      this._listeners = {};
      each2(this._responsiveListeners, (listener3, type) => {
        this.platform.removeEventListener(this, type, listener3);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix2 = enabled ? "set" : "remove";
      let meta, item, i, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix2 + "DatasetHoverStyle"]();
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix2 + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index],
          index
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    isPluginEnabled(pluginId) {
      return this._plugins._cache.filter((p2) => p2.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a, b) => a.filter((x2) => !b.some((y) => x2.datasetIndex === y.datasetIndex && x2.index === y.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e, replay) {
      const args = {
        event: e,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e, replay, inChartArea) {
      const { _active: lastActive = [], options: options2 } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e);
      const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options2.onHover, [
          e,
          active,
          this
        ], this);
        if (isClick) {
          callback(options2.onClick, [
            e,
            active,
            this
          ], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  __publicField(Chart, "defaults", defaults);
  __publicField(Chart, "instances", instances);
  __publicField(Chart, "overrides", overrides);
  __publicField(Chart, "registry", registry);
  __publicField(Chart, "version", version2);
  __publicField(Chart, "getChart", getChart);
  function invalidatePlugins() {
    return each2(Chart.instances, (chart) => chart._plugins.invalidate());
  }
  function setStyle(ctx, options2, style = options2) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options2.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options2.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options2.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options2.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options2.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options2.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options2) {
    if (options2.stepped) {
      return _steppedLineTo;
    }
    if (options2.tension || options2.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end2 = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start,
      loop: segment.loop,
      ilen: end2 < start && !outside ? count + end2 - start : end2 - start
    };
  }
  function pathSegment(ctx, line2, segment, params) {
    const { points, options: options2 } = line2;
    const { count, start, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options2);
    let { move = true, reverse } = params || {};
    let i, point, prev2;
    for (i = 0; i <= ilen; ++i) {
      point = points[(start + (reverse ? ilen - i : i)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev2, point, reverse, options2.stepped);
      }
      prev2 = point;
    }
    if (loop) {
      point = points[(start + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev2, point, reverse, options2.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line2, segment, params) {
    const points = line2.points;
    const { count, start, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i = 0; i <= ilen; ++i) {
      point = points[pointIndex(i)];
      if (point.skip) {
        continue;
      }
      const x2 = point.x;
      const y = point.y;
      const truncX = x2 | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
        } else if (y > maxY) {
          maxY = y;
        }
        avgX = (countX * avgX + x2) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x2, y);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
      }
      lastY = y;
    }
    drawX();
  }
  function _getSegmentMethod(line2) {
    const opts = line2.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line2._decimated && !line2._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options2) {
    if (options2.stepped) {
      return _steppedInterpolation;
    }
    if (options2.tension || options2.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line2, start, count) {
    let path = line2._path;
    if (!path) {
      path = line2._path = new Path2D();
      if (line2.path(path, start, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line2.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line2, start, count) {
    const { segments, options: options2 } = line2;
    const segmentMethod = _getSegmentMethod(line2);
    for (const segment of segments) {
      setStyle(ctx, options2, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line2, segment, {
        start,
        end: start + count - 1
      })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line2, start, count) {
    if (usePath2D && !line2.options.segment) {
      strokePathWithCache(ctx, line2, start, count);
    } else {
      strokePathDirect(ctx, line2, start, count);
    }
  }
  var LineElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options2 = this.options;
      if ((options2.tension || options2.cubicInterpolationMode === "monotone") && !options2.stepped && !this._pointsUpdated) {
        const loop = options2.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options2, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options2 = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, {
        property,
        start: value,
        end: value
      });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options2);
      let i, ilen;
      for (i = 0, ilen = segments.length; i < ilen; ++i) {
        const { start, end: end2 } = segments[i];
        const p1 = points[start];
        const p2 = points[end2];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t2, options2.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start = start || 0;
      count = count || this.points.length - start;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, {
          start,
          end: start + count - 1
        });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start, count) {
      const options2 = this.options || {};
      const points = this.points || [];
      if (points.length && options2.borderWidth) {
        ctx.save();
        draw(ctx, this, start, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  __publicField(LineElement, "id", "line");
  __publicField(LineElement, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  });
  __publicField(LineElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  __publicField(LineElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash" && name !== "fill"
  });
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options2 = el.options;
    const { [axis]: value } = el.getProps([
      axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options2.radius + options2.hitRadius;
  }
  var PointElement = class extends Element2 {
    constructor(cfg) {
      super();
      __publicField(this, "parsed");
      __publicField(this, "skip");
      __publicField(this, "stop");
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options2 = this.options;
      const { x: x2, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return Math.pow(mouseX - x2, 2) + Math.pow(mouseY - y, 2) < Math.pow(options2.hitRadius + options2.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x2, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x: x2,
        y
      };
    }
    size(options2) {
      options2 = options2 || this.options || {};
      let radius = options2.radius || 0;
      radius = Math.max(radius, radius && options2.hoverRadius || 0);
      const borderWidth = radius && options2.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options2 = this.options;
      if (this.skip || options2.radius < 0.1 || !_isPointInArea(this, area, this.size(options2) / 2)) {
        return;
      }
      ctx.strokeStyle = options2.borderColor;
      ctx.lineWidth = options2.borderWidth;
      ctx.fillStyle = options2.backgroundColor;
      drawPoint(ctx, options2, this.x, this.y);
    }
    getRange() {
      const options2 = this.options || {};
      return options2.radius + options2.hitRadius;
    }
  };
  __publicField(PointElement, "id", "point");
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  });
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  function getBarBounds(bar, useFinalPosition) {
    const { x: x2, y, base, width, height } = bar.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], useFinalPosition);
    let left, right, top, bottom, half;
    if (bar.horizontal) {
      half = height / 2;
      left = Math.min(x2, base);
      right = Math.max(x2, base);
      top = y - half;
      bottom = y + half;
    } else {
      half = width / 2;
      left = x2 - half;
      right = x2 + half;
      top = Math.min(y, base);
      bottom = Math.max(y, base);
    }
    return {
      left,
      top,
      right,
      bottom
    };
  }
  function skipOrLimit(skip2, value, min, max) {
    return skip2 ? 0 : _limitValue(value, min, max);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o2 = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o2.top, 0, maxH),
      r: skipOrLimit(skip2.right, o2.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o2.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o2.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
      "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o2 = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject4(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o2.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o2.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o2.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o2.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x2, y, useFinalPosition) {
    const skipX = x2 === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x2, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x2 = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w2 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x2;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
      x: rect.x + x2,
      y: rect.y + y,
      w: rect.w + w2,
      h: rect.h + h,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element2 {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x: x2, y, base, horizontal } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], useFinalPosition);
      return {
        x: horizontal ? (x2 + base) / 2 : x2,
        y: horizontal ? y : (y + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  __publicField(BarElement, "id", "bar");
  __publicField(BarElement, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  });
  __publicField(BarElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
  var Legend = class extends Element2 {
    constructor(config2) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config2.chart;
      this.options = config2.options;
      this.ctx = config2.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [
        this.chart
      ], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options: options2, ctx } = this;
      if (!options2.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options2.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options2.maxWidth || this.maxWidth);
      this.height = Math.min(height, options2.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [
        0
      ];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top = -lineHeight;
      this.legendItems.forEach((legendItem, i) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
          top += lineHeight;
          row++;
        }
        hitboxes[i] = {
          left: 0,
          top,
          row,
          width: itemWidth,
          height: itemHeight
        };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i) => {
        const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
        if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          left += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i] = {
          left,
          top: currentColHeight,
          col,
          width: itemWidth,
          height: itemHeight
        };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({
        width: currentColWidth,
        height: currentColHeight
      });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
          left += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor2;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x2, y, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
          const centerY = y + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x2, y, legendItem) {
        renderText(ctx, legendItem.text, x2, y + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor2 = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor2 = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i) => {
        ctx.strokeStyle = legendItem.fontColor;
        ctx.fillStyle = legendItem.fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x2 = cursor2.x;
        let y = cursor2.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i > 0 && x2 + width + padding > this.right) {
            y = cursor2.y += lineHeight;
            cursor2.line++;
            x2 = cursor2.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor2.line]);
          }
        } else if (i > 0 && y + lineHeight > this.bottom) {
          x2 = cursor2.x = x2 + columnSizes[cursor2.line].width + padding;
          cursor2.line++;
          y = cursor2.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor2.line].height);
        }
        const realX = rtlHelper.x(x2);
        drawLegendBox(realX, y, legendItem);
        x2 = _textX(textAlign, x2 + boxWidth + halfFontSize, isHorizontal ? x2 + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x2), y, legendItem);
        if (isHorizontal) {
          cursor2.x += width + padding;
        } else if (typeof legendItem.text !== "string") {
          const fontLineHeight = labelFont.lineHeight;
          cursor2.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
        } else {
          cursor2.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position2 = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y;
      let left = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y = this.top + topPaddingPlusHalfFontSize;
        left = _alignStartEnd(opts.align, left, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x2 = _alignStartEnd(position2, left, left + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position2));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x2, y, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x2, y) {
      let i, hitBox, lh;
      if (_isBetween(x2, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i = 0; i < lh.length; ++i) {
          hitBox = lh[i];
          if (_isBetween(x2, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i];
          }
        }
      }
      return null;
    }
    handleEvent(e) {
      const opts = this.options;
      if (!isListened(e.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e.x, e.y);
      if (e.type === "mousemove" || e.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [
            e,
            previous,
            this
          ], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [
            e,
            hoveredItem,
            this
          ], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [
          e,
          hoveredItem,
          this
        ], this);
      }
    }
  };
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
      itemWidth,
      itemHeight
    };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
      legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
      itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options2) {
      const legend = chart.legend = new Legend({
        ctx: chart.ctx,
        options: options2,
        chart
      });
      layouts.configure(chart, legend, options2);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options2) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options2);
      legend.options = options2;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e, legendItem, legend) {
        const index = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index)) {
          ci.hide(index);
          legendItem.hidden = true;
        } else {
          ci.show(index);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name) => !name.startsWith("on"),
      labels: {
        _scriptable: (name) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(name)
      }
    }
  };
  var Title = class extends Element2 {
    constructor(config2) {
      super();
      this.chart = config2.chart;
      this.options = config2.options;
      this.ctx = config2.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset) {
      const { top, left, bottom, right, options: options2 } = this;
      const align = options2.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        titleY = top + offset;
        maxWidth = right - left;
      } else {
        if (options2.position === "left") {
          titleX = left + offset;
          titleY = _alignStartEnd(align, bottom, top);
          rotation = PI * -0.5;
        } else {
          titleX = right - offset;
          titleY = _alignStartEnd(align, top, bottom);
          rotation = PI * 0.5;
        }
        maxWidth = bottom - top;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options2) {
      createTitle(chart, options2);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options2) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options2);
      title.options = options2;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i, len;
      let xSet = /* @__PURE__ */ new Set();
      let y = 0;
      let count = 0;
      for (i = 0, len = items.length; i < len; ++i) {
        const el = items[i].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          xSet.add(pos.x);
          y += pos.y;
          ++count;
        }
      }
      if (count === 0 || xSet.size === 0) {
        return false;
      }
      const xAverage = [
        ...xSet
      ].reduce((a, b) => a + b) / xSet.size;
      return {
        x: xAverage,
        y: y / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x2 = eventPosition.x;
      let y = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i, len, nearestElement;
      for (i = 0, len = items.length; i < len; ++i) {
        const el = items[i].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d = distanceBetweenPoints(eventPosition, center);
          if (d < minDistance) {
            minDistance = d;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x2 = tp.x;
        y = tp.y;
      }
      return {
        x: x2,
        y
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index);
    return {
      chart,
      label,
      parsed: controller.getParsed(index),
      raw: chart.data.datasets[datasetIndex].data[index],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options2) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options2;
    const bodyFont = toFont(options2.bodyFont);
    const titleFont = toFont(options2.titleFont);
    const footerFont = toFont(options2.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options2.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options2.titleSpacing + options2.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options2.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options2.bodySpacing;
    }
    if (footerLineCount) {
      height += options2.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options2.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line2) {
      width = Math.max(width, ctx.measureText(line2).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each2(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each2(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options2.displayColors ? boxWidth + 2 + options2.boxPadding : 0;
    each2(body, (bodyItem) => {
      each2(bodyItem.before, maxLineWidth);
      each2(bodyItem.lines, maxLineWidth);
      each2(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each2(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
      width,
      height
    };
  }
  function determineYAlign(chart, size) {
    const { y, height } = size;
    if (y < height / 2) {
      return "top";
    } else if (y > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options2, size) {
    const { x: x2, width } = size;
    const caret2 = options2.caretSize + options2.caretPadding;
    if (xAlign === "left" && x2 + width + caret2 > chart.width) {
      return true;
    }
    if (xAlign === "right" && x2 - width - caret2 < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options2, size, yAlign) {
    const { x: x2, width } = size;
    const { width: chartWidth, chartArea: { left, right } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x2 <= (left + right) / 2 ? "left" : "right";
    } else if (x2 <= width / 2) {
      xAlign = "left";
    } else if (x2 >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options2, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options2, size) {
    const yAlign = size.yAlign || options2.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options2.xAlign || determineXAlign(chart, options2, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x: x2, width } = size;
    if (xAlign === "right") {
      x2 -= width;
    } else if (xAlign === "center") {
      x2 -= width / 2;
    }
    return x2;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y, height } = size;
    if (yAlign === "top") {
      y += paddingAndSize;
    } else if (yAlign === "bottom") {
      y -= height + paddingAndSize;
    } else {
      y -= height / 2;
    }
    return y;
  }
  function getBackgroundPoint(options2, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options2;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x2 = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x2 += paddingAndSize;
      } else if (xAlign === "right") {
        x2 -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x2 -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x2 += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x2, 0, chart.width - size.width),
      y: _limitValue(y, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options2) {
    const padding = toPadding(options2.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext5(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var defaultCallbacks = {
    beforeTitle: noop4,
    title(tooltipItems) {
      if (tooltipItems.length > 0) {
        const item = tooltipItems[0];
        const labels = item.chart.data.labels;
        const labelCount = labels ? labels.length : 0;
        if (this && this.options && this.options.mode === "dataset") {
          return item.dataset.label || "";
        } else if (item.label) {
          return item.label;
        } else if (labelCount > 0 && item.dataIndex < labelCount) {
          return labels[item.dataIndex];
        }
      }
      return "";
    },
    afterTitle: noop4,
    beforeBody: noop4,
    beforeLabel: noop4,
    label(tooltipItem) {
      if (this && this.options && this.options.mode === "dataset") {
        return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
      }
      let label = tooltipItem.dataset.label || "";
      if (label) {
        label += ": ";
      }
      const value = tooltipItem.formattedValue;
      if (!isNullOrUndef(value)) {
        label += value;
      }
      return label;
    },
    labelColor(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options2 = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        borderColor: options2.borderColor,
        backgroundColor: options2.backgroundColor,
        borderWidth: options2.borderWidth,
        borderDash: options2.borderDash,
        borderDashOffset: options2.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options2 = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        pointStyle: options2.pointStyle,
        rotation: options2.rotation
      };
    },
    afterLabel: noop4,
    afterBody: noop4,
    beforeFooter: noop4,
    footer: noop4,
    afterFooter: noop4
  };
  function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") {
      return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
  }
  var Tooltip = class extends Element2 {
    constructor(config2) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config2.chart;
      this.options = config2.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options2) {
      this.options = options2;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options2 = this.options.setContext(this.getContext());
      const opts = options2.enabled && chart.options.animation && options2.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options2) {
      const { callbacks } = options2;
      const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
      const title = invokeCallbackWithFallback(callbacks, "title", this, context);
      const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options2) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options2.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options2) {
      const { callbacks } = options2;
      const bodyItems = [];
      each2(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context);
        pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
        pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
        pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options2) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options2.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options2) {
      const { callbacks } = options2;
      const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
      const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
      const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options2) {
      const active = this._active;
      const data2 = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i, len;
      for (i = 0, len = active.length; i < len; ++i) {
        tooltipItems.push(createTooltipItem(this.chart, active[i]));
      }
      if (options2.filter) {
        tooltipItems = tooltipItems.filter((element, index, array) => options2.filter(element, index, array, data2));
      }
      if (options2.itemSort) {
        tooltipItems = tooltipItems.sort((a, b) => options2.itemSort(a, b, data2));
      }
      each2(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options2.callbacks, context);
        labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
        labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
        labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options2 = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position2 = positioners[options2.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options2);
        this.title = this.getTitle(tooltipItems, options2);
        this.beforeBody = this.getBeforeBody(tooltipItems, options2);
        this.body = this.getBody(tooltipItems, options2);
        this.afterBody = this.getAfterBody(tooltipItems, options2);
        this.footer = this.getFooter(tooltipItems, options2);
        const size = this._size = getTooltipSize(this, options2);
        const positionAndSize = Object.assign({}, position2, size);
        const alignment = determineAlignment(this.chart, options2, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options2, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position2.x,
          caretY: position2.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options2.external) {
        options2.external.call(this, {
          chart: this.chart,
          tooltip: this,
          replay
        });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options2) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options2);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options2) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options2;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x2, x3, y1, y2, y3;
      if (yAlign === "center") {
        y2 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y2 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return {
        x1,
        x2,
        x3,
        y1,
        y2,
        y3
      };
    }
    drawTitle(pt2, ctx, options2) {
      const title = this.title;
      const length2 = title.length;
      let titleFont, titleSpacing, i;
      if (length2) {
        const rtlHelper = getRtlAdapter(options2.rtl, this.x, this.width);
        pt2.x = getAlignedX(this, options2.titleAlign, options2);
        ctx.textAlign = rtlHelper.textAlign(options2.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options2.titleFont);
        titleSpacing = options2.titleSpacing;
        ctx.fillStyle = options2.titleColor;
        ctx.font = titleFont.string;
        for (i = 0; i < length2; ++i) {
          ctx.fillText(title[i], rtlHelper.x(pt2.x), pt2.y + titleFont.lineHeight / 2);
          pt2.y += titleFont.lineHeight + titleSpacing;
          if (i + 1 === length2) {
            pt2.y += options2.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt2, i, rtlHelper, options2) {
      const labelColor = this.labelColors[i];
      const labelPointStyle = this.labelPointStyles[i];
      const { boxHeight, boxWidth } = options2;
      const bodyFont = toFont(options2.bodyFont);
      const colorX = getAlignedX(this, "left", options2);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt2.y + yOffSet;
      if (options2.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options2.multiKeyBackground;
        ctx.fillStyle = options2.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColor.borderColor;
        ctx.fillStyle = labelColor.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject4(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
        ctx.strokeStyle = labelColor.borderColor;
        ctx.setLineDash(labelColor.borderDash || []);
        ctx.lineDashOffset = labelColor.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
        const borderRadius = toTRBLCorners(labelColor.borderRadius);
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options2.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options2.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt2, ctx, options2) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options2;
      const bodyFont = toFont(options2.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options2.rtl, this.x, this.width);
      const fillLineOfText = function(line2) {
        ctx.fillText(line2, rtlHelper.x(pt2.x + xLinePadding), pt2.y + bodyLineHeight / 2);
        pt2.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i, j, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt2.x = getAlignedX(this, bodyAlignForCalculation, options2);
      ctx.fillStyle = options2.bodyColor;
      each2(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i = 0, ilen = body.length; i < ilen; ++i) {
        bodyItem = body[i];
        textColor = this.labelTextColors[i];
        ctx.fillStyle = textColor;
        each2(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt2, i, rtlHelper, options2);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j = 0, jlen = lines.length; j < jlen; ++j) {
          fillLineOfText(lines[j]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each2(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each2(this.afterBody, fillLineOfText);
      pt2.y -= bodySpacing;
    }
    drawFooter(pt2, ctx, options2) {
      const footer = this.footer;
      const length2 = footer.length;
      let footerFont, i;
      if (length2) {
        const rtlHelper = getRtlAdapter(options2.rtl, this.x, this.width);
        pt2.x = getAlignedX(this, options2.footerAlign, options2);
        pt2.y += options2.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options2.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options2.footerFont);
        ctx.fillStyle = options2.footerColor;
        ctx.font = footerFont.string;
        for (i = 0; i < length2; ++i) {
          ctx.fillText(footer[i], rtlHelper.x(pt2.x), pt2.y + footerFont.lineHeight / 2);
          pt2.y += footerFont.lineHeight + options2.footerSpacing;
        }
      }
    }
    drawBackground(pt2, ctx, tooltipSize, options2) {
      const { xAlign, yAlign } = this;
      const { x: x2, y } = pt2;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options2.cornerRadius);
      ctx.fillStyle = options2.backgroundColor;
      ctx.strokeStyle = options2.borderColor;
      ctx.lineWidth = options2.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x2 + topLeft, y);
      if (yAlign === "top") {
        this.drawCaret(pt2, ctx, tooltipSize, options2);
      }
      ctx.lineTo(x2 + width - topRight, y);
      ctx.quadraticCurveTo(x2 + width, y, x2 + width, y + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt2, ctx, tooltipSize, options2);
      }
      ctx.lineTo(x2 + width, y + height - bottomRight);
      ctx.quadraticCurveTo(x2 + width, y + height, x2 + width - bottomRight, y + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt2, ctx, tooltipSize, options2);
      }
      ctx.lineTo(x2 + bottomLeft, y + height);
      ctx.quadraticCurveTo(x2, y + height, x2, y + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt2, ctx, tooltipSize, options2);
      }
      ctx.lineTo(x2, y + topLeft);
      ctx.quadraticCurveTo(x2, y, x2 + topLeft, y);
      ctx.closePath();
      ctx.fill();
      if (options2.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options2) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position2 = positioners[options2.position].call(this, this._active, this._eventPosition);
        if (!position2) {
          return;
        }
        const size = this._size = getTooltipSize(this, options2);
        const positionAndSize = Object.assign({}, position2, this._size);
        const alignment = determineAlignment(chart, options2, positionAndSize);
        const point = getBackgroundPoint(options2, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position2.x;
          this.caretY = position2.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options2 = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options2);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt2 = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options2.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options2.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt2, ctx, tooltipSize, options2);
        overrideTextDirection(ctx, options2.textDirection);
        pt2.y += padding.top;
        this.drawTitle(pt2, ctx, options2);
        this.drawBody(pt2, ctx, options2);
        this.drawFooter(pt2, ctx, options2);
        restoreTextDirection(ctx, options2.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index],
          index
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options2 = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options2.enabled || options2.external) {
          this._eventPosition = {
            x: e.x,
            y: e.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e, lastActive, replay, inChartArea) {
      const options2 = this.options;
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
      }
      const active = this.chart.getElementsAtEventForMode(e, options2.mode, options2, replay);
      if (options2.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e) {
      const { caretX, caretY, options: options2 } = this;
      const position2 = positioners[options2.position].call(this, active, e);
      return position2 !== false && (caretX !== position2.x || caretY !== position2.y);
    }
  };
  __publicField(Tooltip, "positioners", positioners);
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options2) {
      if (options2) {
        chart.tooltip = new Tooltip({
          chart,
          options: options2
        });
      }
    },
    beforeUpdate(chart, _args, options2) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options2);
      }
    },
    reset(chart, _args, options2) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options2);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", {
          ...args,
          cancelable: true
        }) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: defaultCallbacks
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  };
  var addIfString = (labels, raw, index, addedLabels) => {
    if (typeof raw === "string") {
      index = labels.push(raw) - 1;
      addedLabels.unshift({
        index,
        label: raw
      });
    } else if (isNaN(raw)) {
      index = null;
    }
    return index;
  };
  function findOrAddLabel(labels, raw, index, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index : first;
  }
  var validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
  function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  var CategoryScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index, label } of added) {
          if (labels[index] === label) {
            labels.splice(index, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
      return validIndex(index, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min = 0;
        }
        if (!maxDefined) {
          max = this.getLabels().length - 1;
        }
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const min = this.min;
      const max = this.max;
      const offset = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
      this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
      this._startValue = this.min - (offset ? 0.5 : 0);
      for (let value = min; value <= max; value++) {
        ticks.push({
          value
        });
      }
      return ticks;
    }
    getLabelForValue(value) {
      return _getLabelForValue.call(this, value);
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index) {
      const ticks = this.ticks;
      if (index < 0 || index > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  __publicField(CategoryScale, "id", "category");
  __publicField(CategoryScale, "defaults", {
    ticks: {
      callback: _getLabelForValue
    }
  });
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [
        {
          value: rmin
        },
        {
          value: rmax
        }
      ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
      spacing = (max - min) / numSpaces;
      niceMin = min;
      niceMax = max;
    } else if (countDefined) {
      niceMin = minDefined ? min : niceMin;
      niceMax = maxDefined ? max : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min) {
        ticks.push({
          value: min
        });
        if (niceMin < min) {
          j++;
        }
        if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
          j++;
        }
      } else if (niceMin < min) {
        j++;
      }
    }
    for (; j < numSpaces; ++j) {
      const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
      if (maxDefined && tickValue > max) {
        break;
      }
      ticks.push({
        value: tickValue
      });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max;
      } else {
        ticks.push({
          value: max
        });
      }
    } else if (!maxDefined || niceMax === max) {
      ticks.push({
        value: niceMax
      });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length2 = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length2);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      if (beginAtZero) {
        const minSign = sign(min);
        const maxSign = sign(max);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min === max) {
        let offset = max === 0 ? 1 : Math.abs(max * 0.05);
        setMax(max + offset);
        if (!beginAtZero) {
          setMin(min - offset);
        }
      }
      this.min = min;
      this.max = max;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start = this.min;
      let end2 = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset = (end2 - start) / Math.max(ticks.length - 1, 1) / 2;
        start -= offset;
        end2 += offset;
      }
      this._startValue = start;
      this._endValue = end2;
      this._valueRange = end2 - start;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? min : 0;
      this.max = isNumberFinite(max) ? max : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length2 = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length2 / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  __publicField(LinearScale, "id", "linear");
  __publicField(LinearScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  });
  var log10Floor = (v) => Math.floor(log10(v));
  var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
  }
  function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end2 = Math.ceil(max / rangeStep);
    return end2 - start;
  }
  function startExp(min, max) {
    const range = max - min;
    let rangeExp = log10Floor(range);
    while (steps(min, max, rangeExp) > 10) {
      rangeExp++;
    }
    while (steps(min, max, rangeExp) < 10) {
      rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
  }
  function generateTicks(generationOptions, { min, max }) {
    min = finiteOrDefault(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while (value < max) {
      ticks.push({
        value,
        major: isMajor(value),
        significand
      });
      if (significand >= 10) {
        significand = significand < 15 ? 15 : 20;
      } else {
        significand++;
      }
      if (significand >= 20) {
        exp++;
        significand = 2;
        precision = exp >= 0 ? 1 : precision;
      }
      value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
      value: lastTick,
      major: isMajor(lastTick),
      significand
    });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index) {
      const value = LinearScaleBase.prototype.parse.apply(this, [
        raw,
        index
      ]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? Math.max(0, min) : null;
      this.max = isNumberFinite(max) ? Math.max(0, max) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
        this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min = this.min;
      let max = this.max;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      if (min === max) {
        if (min <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(changeExponent(min, -1));
          setMax(changeExponent(max, 1));
        }
      }
      if (min <= 0) {
        setMin(changeExponent(max, -1));
      }
      if (max <= 0) {
        setMax(changeExponent(min, 1));
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start = this.min;
      super.configure();
      this._startValue = log10(start);
      this._valueRange = log10(this.max) - log10(start);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  __publicField(LogarithmicScale, "id", "logarithmic");
  __publicField(LogarithmicScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  });
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [
      label
    ];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i = 0; i < valueCount; i++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
      padding[i] = opts.padding;
      const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
      labelSizes[i] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x2 = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
      x2 = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x2);
    } else if (hLimits.end > orig.r) {
      x2 = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x2);
    }
    if (vLimits.start < orig.t) {
      y = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
      y = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y);
    }
  }
  function createPointLabelItem(scale, index, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra, additionalAngle, padding, size } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
      visible: true,
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    };
  }
  function isNotOverlapped(item, area) {
    if (!area) {
      return true;
    }
    const { left, top, right, bottom } = item;
    const apexesInArea = _isPointInArea({
      x: left,
      y: top
    }, area) || _isPointInArea({
      x: left,
      y: bottom
    }, area) || _isPointInArea({
      x: right,
      y: top
    }, area) || _isPointInArea({
      x: right,
      y: bottom
    }, area);
    return !apexesInArea;
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
      extra: getTickBackdropHeight(opts) / 2,
      additionalAngle: centerPointLabels ? PI / valueCount : 0
    };
    let area;
    for (let i = 0; i < valueCount; i++) {
      itemOpts.padding = padding[i];
      itemOpts.size = labelSizes[i];
      const item = createPointLabelItem(scale, i, itemOpts);
      items.push(item);
      if (display === "auto") {
        item.visible = isNotOverlapped(item, area);
        if (item.visible) {
          area = item;
        }
      }
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x2, w2, align) {
    if (align === "right") {
      x2 -= w2;
    } else if (align === "center") {
      x2 -= w2 / 2;
    }
    return x2;
  }
  function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) {
      y -= h / 2;
    } else if (angle > 270 || angle < 90) {
      y -= h;
    }
    return y;
  }
  function drawPointLabelBox(ctx, opts, item) {
    const { left, top, right, bottom } = item;
    const { backdropColor } = opts;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(opts.borderRadius);
      const padding = toPadding(opts.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom - top + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i = labelCount - 1; i >= 0; i--) {
      const item = scale._pointLabelItems[i];
      if (!item.visible) {
        continue;
      }
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
      drawPointLabelBox(ctx, optsAtIndex, item);
      const plFont = toFont(optsAtIndex.font);
      const { x: x2, y, textAlign } = item;
      renderText(ctx, scale._pointLabels[i], x2, y + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i = 1; i < labelCount; i++) {
        pointPosition = scale.getPointPosition(i, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash || []);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index, label) {
    return createContext5(parent, {
      label,
      index,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w2 = this.width = this.maxWidth - padding.width;
      const h = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w2 / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w2, h) / 2);
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(false);
      this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
      this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index) => {
        const label = callback(this.options.pointLabels.callback, [
          value,
          index
        ], this);
        return label || label === 0 ? label : "";
      }).filter((v, i) => this.chart.getDataVisibility(i));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index) {
      const pointLabels = this._pointLabels || [];
      if (index >= 0 && index < pointLabels.length) {
        const pointLabel = pointLabels[index];
        return createPointLabelContext(this.getContext(), index, pointLabel);
      }
    }
    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index, value) {
      return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index) {
      return this.getPointPositionForValue(index || 0, this.getBaseValue());
    }
    getPointLabelPosition(index) {
      const { left, top, right, bottom } = this._pointLabelItems[index];
      return {
        left,
        top,
        right,
        bottom
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid, border } = opts;
      const labelCount = this._pointLabels.length;
      let i, offset, position2;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index) => {
          if (index !== 0 || index === 0 && this.min < 0) {
            offset = this.getDistanceFromCenterForValue(tick.value);
            const context = this.getContext(index);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i = labelCount - 1; i >= 0; i--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
          position2 = this.getPointPosition(i, offset);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position2.x, position2.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index) => {
        if (index === 0 && this.min >= 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index));
        const tickFont = toFont(optsAtIndex.font);
        offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset, tickFont, {
          color: optsAtIndex.color,
          strokeColor: optsAtIndex.textStrokeColor,
          strokeWidth: optsAtIndex.textStrokeWidth
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  __publicField(RadialLinearScale, "id", "radialLinear");
  __publicField(RadialLinearScale, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  });
  __publicField(RadialLinearScale, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  });
  __publicField(RadialLinearScale, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  };
  var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
  function sorter(a, b) {
    return a - b;
  }
  function parse4(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter5 = scale._adapter;
    const { parser, round: round2, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter5.parse(value, parser) : adapter5.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round2) {
      value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter5.startOf(value, "isoWeek", isoWeekday) : adapter5.startOf(value, round2);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
      const interval = INTERVALS[UNITS[i]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
        return UNITS[i];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
      const unit = UNITS[i];
      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
      if (INTERVALS[UNITS[i]].common) {
        return UNITS[i];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map2, majorUnit) {
    const adapter5 = scale._adapter;
    const first = +adapter5.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index;
    for (major = first; major <= last; major = +adapter5.add(major, 1, majorUnit)) {
      index = map2[major];
      if (index >= 0) {
        ticks[index].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map2 = {};
    const ilen = values.length;
    let i, value;
    for (i = 0; i < ilen; ++i) {
      value = values[i];
      map2[value] = i;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
  }
  var TimeScale = class extends Scale {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter5 = this._adapter = new adapters5._date(scaleOpts.adapters.date);
      adapter5.init(opts);
      mergeIf(time.displayFormats, adapter5.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index) {
      if (raw === void 0) {
        return null;
      }
      return parse4(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options2 = this.options;
      const adapter5 = this._adapter;
      const unit = options2.time.unit || "day";
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min = Math.min(min, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max = Math.max(max, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options2.bounds !== "ticks" || options2.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min = isNumberFinite(min) && !isNaN(min) ? min : +adapter5.startOf(Date.now(), unit);
      max = isNumberFinite(max) && !isNaN(max) ? max : +adapter5.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min, max - 1);
      this.max = Math.max(min + 1, max);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min = Number.POSITIVE_INFINITY;
      let max = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min = arr[0];
        max = arr[arr.length - 1];
      }
      return {
        min,
        max
      };
    }
    buildTicks() {
      const options2 = this.options;
      const timeOpts = options2.time;
      const tickOpts = options2.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options2.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min = this.min;
      const max = this.max;
      const ticks = _filterBetween(timestamps, min, max);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options2.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps = []) {
      let start = 0;
      let end2 = 0;
      let first, last;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start = 1 - first;
        } else {
          start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end2 = last;
        } else {
          end2 = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start = _limitValue(start, 0, limit);
      end2 = _limitValue(end2, 0, limit);
      this._offsets = {
        start,
        end: end2,
        factor: 1 / (start + 1 + end2)
      };
    }
    _generate() {
      const adapter5 = this._adapter;
      const min = this.min;
      const max = this.max;
      const options2 = this.options;
      const timeOpts = options2.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
      const stepSize = valueOrDefault(options2.ticks.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first = min;
      let time, count;
      if (hasWeekday) {
        first = +adapter5.startOf(first, "isoWeek", weekday);
      }
      first = +adapter5.startOf(first, hasWeekday ? "day" : minor);
      if (adapter5.diff(max, min, minor) > 1e5 * stepSize) {
        throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options2.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max; time = +adapter5.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max || options2.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort(sorter).map((x2) => +x2);
    }
    getLabelForValue(value) {
      const adapter5 = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter5.format(value, timeOpts.tooltipFormat);
      }
      return adapter5.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
      const options2 = this.options;
      const formats = options2.time.displayFormats;
      const unit = this._unit;
      const fmt = format || formats[unit];
      return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index, ticks, format) {
      const options2 = this.options;
      const formatter = options2.ticks.callback;
      if (formatter) {
        return callback(formatter, [
          time,
          index,
          ticks
        ], this);
      }
      const formats = options2.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index];
      const major = majorUnit && majorFormat && tick && tick.major;
      return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        tick.label = this._tickFormatFunction(tick.value, i, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
        exampleTime
      ], this._majorUnit), format);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i = 0, ilen = labels.length; i < ilen; ++i) {
        timestamps.push(parse4(this, labels[i]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  __publicField(TimeScale, "id", "time");
  __publicField(TimeScale, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  });
  function interpolate2(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate2(table, this.min);
      this._tableRange = interpolate2(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min, max } = this;
      const items = [];
      const table = [];
      let i, ilen, prev2, curr, next2;
      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];
        if (curr >= min && curr <= max) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          {
            time: min,
            pos: 0
          },
          {
            time: max,
            pos: 1
          }
        ];
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next2 = items[i + 1];
        prev2 = items[i - 1];
        curr = items[i];
        if (Math.round((next2 + prev2) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }
      return table;
    }
    _generate() {
      const min = this.min;
      const max = this.max;
      let timestamps = super.getDataTimestamps();
      if (!timestamps.includes(min) || !timestamps.length) {
        timestamps.splice(0, 0, min);
      }
      if (!timestamps.includes(max) || timestamps.length === 1) {
        timestamps.push(max);
      }
      return timestamps.sort((a, b) => a - b);
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data2 = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data2.length && label.length) {
        timestamps = this.normalize(data2.concat(label));
      } else {
        timestamps = data2.length ? data2 : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  __publicField(TimeSeriesScale, "id", "timeseries");
  __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);

  // node_modules/react-chartjs-2/dist/index.js
  var import_react30 = __toESM(require_react(), 1);
  var defaultDatasetIdKey = "label";
  function reforwardRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
  }
  function setOptions(chart, nextOptions) {
    const options2 = chart.options;
    if (options2 && nextOptions) {
      Object.assign(options2, nextOptions);
    }
  }
  function setLabels(currentData, nextLabels) {
    currentData.labels = nextLabels;
  }
  function setDatasets(currentData, nextDatasets) {
    let datasetIdKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultDatasetIdKey;
    const addedDatasets = [];
    currentData.datasets = nextDatasets.map((nextDataset) => {
      const currentDataset = currentData.datasets.find((dataset) => dataset[datasetIdKey] === nextDataset[datasetIdKey]);
      if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {
        return {
          ...nextDataset
        };
      }
      addedDatasets.push(currentDataset);
      Object.assign(currentDataset, nextDataset);
      return currentDataset;
    });
  }
  function cloneData(data2) {
    let datasetIdKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultDatasetIdKey;
    const nextData = {
      labels: [],
      datasets: []
    };
    setLabels(nextData, data2.labels);
    setDatasets(nextData, data2.datasets, datasetIdKey);
    return nextData;
  }
  function ChartComponent(props, ref) {
    const { height = 150, width = 300, redraw = false, datasetIdKey, type, data: data2, options: options2, plugins: plugins3 = [], fallbackContent, updateMode, ...canvasProps } = props;
    const canvasRef = (0, import_react30.useRef)(null);
    const chartRef = (0, import_react30.useRef)(null);
    const renderChart = () => {
      if (!canvasRef.current) return;
      chartRef.current = new Chart(canvasRef.current, {
        type,
        data: cloneData(data2, datasetIdKey),
        options: options2 && {
          ...options2
        },
        plugins: plugins3
      });
      reforwardRef(ref, chartRef.current);
    };
    const destroyChart = () => {
      reforwardRef(ref, null);
      if (chartRef.current) {
        chartRef.current.destroy();
        chartRef.current = null;
      }
    };
    (0, import_react30.useEffect)(() => {
      if (!redraw && chartRef.current && options2) {
        setOptions(chartRef.current, options2);
      }
    }, [
      redraw,
      options2
    ]);
    (0, import_react30.useEffect)(() => {
      if (!redraw && chartRef.current) {
        setLabels(chartRef.current.config.data, data2.labels);
      }
    }, [
      redraw,
      data2.labels
    ]);
    (0, import_react30.useEffect)(() => {
      if (!redraw && chartRef.current && data2.datasets) {
        setDatasets(chartRef.current.config.data, data2.datasets, datasetIdKey);
      }
    }, [
      redraw,
      data2.datasets
    ]);
    (0, import_react30.useEffect)(() => {
      if (!chartRef.current) return;
      if (redraw) {
        destroyChart();
        setTimeout(renderChart);
      } else {
        chartRef.current.update(updateMode);
      }
    }, [
      redraw,
      options2,
      data2.labels,
      data2.datasets,
      updateMode
    ]);
    (0, import_react30.useEffect)(() => {
      if (!chartRef.current) return;
      destroyChart();
      setTimeout(renderChart);
    }, [
      type
    ]);
    (0, import_react30.useEffect)(() => {
      renderChart();
      return () => destroyChart();
    }, []);
    return /* @__PURE__ */ import_react30.default.createElement("canvas", {
      ref: canvasRef,
      role: "img",
      height,
      width,
      ...canvasProps
    }, fallbackContent);
  }
  var Chart2 = /* @__PURE__ */ (0, import_react30.forwardRef)(ChartComponent);
  function createTypedChart(type, registerables) {
    Chart.register(registerables);
    return /* @__PURE__ */ (0, import_react30.forwardRef)((props, ref) => /* @__PURE__ */ import_react30.default.createElement(Chart2, {
      ...props,
      ref,
      type
    }));
  }
  var Bar = /* @__PURE__ */ createTypedChart("bar", BarController);

  // assets/scripts/components/item-chart.tsx
  var import_jsx_runtime49 = __toESM(require_jsx_runtime());
  Chart.register(
    BarElement,
    CategoryScale,
    plugin_legend,
    LinearScale,
    LineController,
    LineElement,
    PointElement,
    plugin_title,
    plugin_tooltip
  );
  var colorStatLabel = "darkolivegreen";
  var options = {
    animation: false,
    elements: {
      bar: {
        borderWidth: 2
      }
    },
    maintainAspectRatio: true,
    plugins: {
      legend: {
        align: "center",
        display: false,
        position: "bottom",
        labels: {
          borderRadius: 6,
          boxHeight: 12,
          boxWidth: 12,
          color: colorStatLabel,
          useBorderRadius: true
        }
      }
    },
    responsive: true,
    scales: {
      x: {
        grid: {
          display: false
        },
        stacked: true,
        ticks: {
          align: "start",
          color: colorStatLabel
        }
      },
      y: {
        stacked: true,
        ticks: {
          color: colorStatLabel
        }
      }
    },
    type: "bar"
  };
  var itemColorStatic = "olivedrab";
  var itemColorLink = "cornflowerblue";
  var ItemChart = ({ handleClick, label, lineProps }) => {
    const [hasLineLabel, setHasLineLabel] = (0, import_react31.useState)(false);
    const sources = useSelector(getSourcesDataForChart);
    const sourceData = {
      id: "sources",
      label: "All incidents",
      data: sources.data,
      borderColor: "rgba(222, 184, 135, 0.5)",
      backgroundColor: "rgba(222, 184, 135, 0.5)",
      type: "bar"
    };
    const itemColor = handleClick ? itemColorLink : itemColorStatic;
    let itemData = null;
    if (lineProps) {
      itemData = {
        label: lineProps.label,
        data: lineProps.data,
        borderColor: itemColor,
        backgroundColor: itemColor,
        stack: "combined",
        type: "line"
      };
    }
    if (label) {
      const labelIndex = sources.labels.indexOf(label);
      sourceData.data = sources.data.map((item, i) => i === labelIndex ? 0 : item);
      itemData = {
        label,
        data: sources.data.map((item, i) => i === labelIndex ? item : 0),
        borderColor: itemColor,
        backgroundColor: itemColor,
        type: "bar"
      };
      options.scales.y.stacked = false;
    }
    const data2 = {
      labels: sources.labels,
      datasets: itemData ? [itemData, sourceData] : [sourceData]
    };
    const hasDatasets = data2.datasets.length > 1;
    if (handleClick) {
      options.onClick = (event, elements, chart) => {
        if (elements.length && chart?.tooltip?.title) {
          handleClick(chart.tooltip.title.at(0));
        }
      };
    }
    options.plugins.legend.display = hasDatasets && hasLineLabel;
    (0, import_react31.useEffect)(() => {
      setHasLineLabel(Boolean(lineProps?.label));
    }, [lineProps, setHasLineLabel]);
    return /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
      Bar,
      {
        datasetIdKey: "id",
        options,
        data: data2
      }
    );
  };
  var item_chart_default = ItemChart;

  // assets/scripts/components/entities/chart.tsx
  var import_jsx_runtime50 = __toESM(require_jsx_runtime());
  var Chart3 = ({ label }) => {
    const [trigger] = api_default.useLazyGetEntityStatsByIdQuery();
    const { id } = useParams();
    const numericId = Number(id);
    const [searchParams, setSearchParams] = useSearchParams();
    const quarterParam2 = searchParams.get("quarter");
    const [quarter, setQuarter] = (0, import_react32.useState)(quarterParam2);
    const entitiesData = useSelector(getEntitiesChartData);
    const data2 = entitiesData?.[numericId];
    const hasData = data2?.length > 0;
    const lineProps = {
      label,
      data: data2
    };
    const handleClick = (value) => {
      setQuarter(value.replace(" ", "-"));
    };
    (0, import_react32.useEffect)(() => {
      if (!hasData) {
        trigger(numericId);
      }
    }, [hasData, numericId, trigger]);
    (0, import_react32.useEffect)(() => {
      if (quarter) {
        if (!quarterParam2 || quarterParam2 && quarter && quarterParam2 !== quarter) {
          setSearchParams({ quarter });
        }
        setQuarter(null);
      }
    }, [quarterParam2, quarter, setSearchParams]);
    return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(item_chart_default, { lineProps, handleClick });
  };
  var chart_default = Chart3;

  // assets/scripts/components/detail-incidents.tsx
  var import_react34 = __toESM(require_react());

  // assets/scripts/components/incidents-header.tsx
  var import_jsx_runtime51 = __toESM(require_jsx_runtime());
  var PAGE_PARAM_KEY = "page";
  var PrimaryAssociation = ({ label }) => {
    if (!label) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(import_jsx_runtime51.Fragment, { children: [
      "associatied with",
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("span", { className: "incidents-association", children: label })
    ] });
  };
  var AssociationLabel = ({ label }) => /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("span", { className: "incidents-association", children: label });
  var AssociationLabels = ({ labels }) => labels.map((l, i) => /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(AssociationLabel, { label: l }, i)).reduce((prev2, curr) => [prev2, " and ", curr]);
  var Association = ({
    filterKey,
    filterKeys,
    intro = "and",
    label,
    labels
  }) => {
    const hasFilterKeys = filterKeys?.length > 0;
    const hasLabels = labels?.length > 0;
    const hasFilterKey = Boolean(filterKey);
    const newParamKeys = [];
    if (hasFilterKeys) {
      filterKeys.forEach((key) => {
        newParamKeys.push(key);
      });
    } else if (hasFilterKey) {
      newParamKeys.push(filterKey);
    }
    newParamKeys.push(PAGE_PARAM_KEY);
    const newParams = newParamKeys.reduce((all, key) => {
      all[key] = null;
      return all;
    }, {});
    return /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)("h5", { children: [
      intro,
      " ",
      hasLabels ? /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(AssociationLabels, { labels }) : /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(AssociationLabel, { label }),
      (hasFilterKeys || hasFilterKey) && /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(import_jsx_runtime51.Fragment, { children: [
        " ",
        /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
          LinkToQueryParams,
          {
            className: "incidents-association-remove",
            newParams,
            replace: false,
            title: "Remove this association",
            children: "\xD7"
          }
        )
      ] })
    ] });
  };
  var IncidentsHeader = ({
    children,
    label
  }) => /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
    item_subhead_default,
    {
      className: "incident-header",
      title: "Incidents",
      subtitle: /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(PrimaryAssociation, { label }),
      children
    }
  );
  var incidents_header_default = IncidentsHeader;

  // assets/scripts/components/incident-list-table.tsx
  var import_react33 = __toESM(require_react());
  var import_jsx_runtime52 = __toESM(require_jsx_runtime());
  var IncidentRow = ({ id }) => {
    const [isSelected, setIsSelected] = (0, import_react33.useState)(false);
    const incident = useSelector((state) => selectors2.selectById(state, id));
    const hasNotes = Boolean(incident?.notes);
    const deactivate = () => setIsSelected(false);
    const handleClick = (event) => {
      event.preventDefault();
      event.stopPropagation();
      if (event.target instanceof HTMLElement) {
        if (event.target.closest(".incident-list-item")) {
          setIsSelected(!isSelected);
        }
      }
    };
    if (!incident) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(import_jsx_runtime52.Fragment, { children: /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(
      "tr",
      {
        className: cx("incident-list-item is-selectable", isSelected && "is-selected"),
        onClick: handleClick,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("td", { className: "cell-date", children: hasNotes ? /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)("span", { className: "has-notes", children: [
            incident.contactDate,
            /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(icon_default, { name: "asterisk" })
          ] }) : incident.contactDate }),
          /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("td", { className: "cell-entity", children: incident.entity }),
          /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("td", { className: "cell-topic", children: incident.topic }),
          /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)("td", { className: "cell-link", children: [
            /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(LinkToIncident, { id: incident.id, "aria-label": "View", children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(icon_default, { name: "chevron-right" }) }),
            /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
              incident_modal_default,
              {
                deactivate,
                id: incident.id,
                isActive: isSelected
              }
            )
          ] })
        ]
      }
    ) });
  };
  var IncidentListTable = ({ hasSort, ids }) => {
    const hasIds = ids?.length > 0;
    if (!ids) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("div", { className: "incident-list-table-frame", children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("div", { className: "incident-list-table", children: /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)("table", { cellPadding: "0", cellSpacing: "0", children: [
      /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)("tr", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("th", { className: "cell-date", children: hasSort ? /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
          SortLink,
          {
            newParams: getSortByParam("date" /* Date */, true),
            defaultSort: "ASC" /* ASC */,
            title: "Sort this list by date",
            children: "Date"
          }
        ) : "Date" }),
        /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("th", { className: "cell-entity", children: "Entity" }),
        /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("th", { className: "cell-topic", children: "Topic" }),
        /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("th", { className: "cell-link" })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("tbody", { children: hasIds ? ids.map((id) => /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(IncidentRow, { id }, id)) : /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("tr", { className: "incident-list-item", children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("td", { colSpan: 4, children: "No results" }) }) })
    ] }) }) });
  };
  var incident_list_table_default = IncidentListTable;

  // assets/scripts/components/incident-list.tsx
  var import_jsx_runtime53 = __toESM(require_jsx_runtime());
  var IncidentList = ({
    hasSort,
    ids,
    pagination,
    scrollToRef
  }) => /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)("div", { className: "incident-list", children: [
    /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(incident_list_table_default, { hasSort, ids }),
    pagination && ids.length > 0 && /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("footer", { className: "incident-list-footer", children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(pagination_default, { pagination, onPageClick: scrollToRef }) })
  ] });
  var incident_list_default = IncidentList;

  // assets/scripts/components/detail-incidents.tsx
  var import_jsx_runtime54 = __toESM(require_jsx_runtime());
  var WithEntityId = ({ filters, filterKey }) => {
    const filter = filters?.[filterKey];
    const hasValue = Boolean(filter?.value);
    const value = hasValue && Number(filter.value);
    const entity = useSelector((state) => hasValue && selectors.selectById(state, value));
    if (!entity) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
      Association,
      {
        filterKey,
        label: entity.name
      }
    );
  };
  var WithPersonId = ({ filters, filterKey }) => {
    const filter = filters?.[filterKey];
    const hasValue = typeof filter === "object" && Boolean(filter?.value);
    const value = hasValue && Number(filter.value);
    const person = useSelector((state) => hasValue && selectors3.selectById(state, value));
    if (!person) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
      Association,
      {
        filterKey,
        label: person.name
      }
    );
  };
  var DuringQuarter = ({ filters, filterKey }) => {
    const quarterFilter = filters?.[filterKey];
    if (!quarterFilter) return null;
    const label = String(quarterFilter).match(/(Q[1-4])-(20[1-2][0-9])/).slice(1, 3).join(" of ");
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
      Association,
      {
        filterKey,
        intro: "during",
        label
      }
    );
  };
  var OnDate = ({ filters, filterKey }) => {
    const filter = filters?.[filterKey];
    const hasValue = Boolean(filter?.value);
    if (!hasValue) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
      Association,
      {
        filterKey,
        intro: "on",
        label: filter.label
      }
    );
  };
  var BetweenDates = ({ filters, filterKeys }) => {
    const filterKeyPair = [];
    const filterLabelPair = [];
    if (!filters) return null;
    filterKeys.filter((key) => key in filters).forEach((key) => {
      filterKeyPair.push(filters[key].key);
      filterLabelPair.push(filters[key].label);
    });
    if (filterKeyPair.length < filterKeys.length) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
      Association,
      {
        filterKeys: filterKeyPair,
        intro: "between",
        labels: filterLabelPair
      }
    );
  };
  var DetailIncidents = ({
    filters,
    hasSort,
    ids,
    label,
    pagination,
    ref
  }) => {
    const params = new URLSearchParams(location.search);
    const paramsString = params.toString();
    const idsRef = (0, import_react34.useRef)(null);
    const paramsStringRef = (0, import_react34.useRef)(null);
    const scrollToRef = () => {
      ref.current?.scrollIntoView({ behavior: "smooth" });
    };
    (0, import_react34.useEffect)(() => {
      if (JSON.stringify(ids) !== JSON.stringify(idsRef.current)) {
        idsRef.current = ids;
        if (paramsString.length > 0 && paramsString !== paramsStringRef.current) {
          paramsStringRef.current = paramsString;
          scrollToRef();
        }
      }
    }, [
      paramsString,
      paramsStringRef,
      ids,
      idsRef,
      scrollToRef
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)("section", { className: "activity-stat-section incident-list-section", ref, children: [
      /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)(incidents_header_default, { label, children: [
        /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(WithEntityId, { filters, filterKey: withEntityIdParam }),
        /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(WithPersonId, { filters, filterKey: withPersonIdParam }),
        /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(DuringQuarter, { filters, filterKey: quarterParam }),
        /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(OnDate, { filters, filterKey: dateOnParam }),
        /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(BetweenDates, { filters, filterKeys: [dateRangeFromParam, dateRangeToParam] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
        incident_list_default,
        {
          hasSort,
          ids,
          pagination,
          scrollToRef
        }
      )
    ] });
  };
  var detail_incidents_default = DetailIncidents;

  // assets/scripts/components/item-detail.tsx
  var import_jsx_runtime55 = __toESM(require_jsx_runtime());
  var ItemDetail = ({ children, className }) => /* @__PURE__ */ (0, import_jsx_runtime55.jsx)("section", { className: cx("item-detail", className), children });
  var item_detail_default = ItemDetail;

  // assets/scripts/components/entities/detail.tsx
  var import_jsx_runtime56 = __toESM(require_jsx_runtime());
  var Detail = () => {
    const ref = (0, import_react35.useRef)();
    const { id } = useParams();
    const numericId = Number(id);
    const entity = useSelector((state) => selectors.selectById(state, numericId));
    const hasEntity = Boolean(entity);
    const hasIncidents = Boolean(entity?.incidents?.ids?.length);
    if (!hasEntity) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)(item_detail_default, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
        detail_activity_overview_default,
        {
          overview: entity.overview,
          ref,
          children: /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(chart_default, { label: entity.name })
        }
      ),
      hasIncidents && /* @__PURE__ */ (0, import_jsx_runtime56.jsxs)(import_jsx_runtime56.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
          attendees_default,
          {
            attendees: entity.attendees,
            entity
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(
          detail_incidents_default,
          {
            ids: entity.incidents?.ids,
            filters: entity.incidents?.filters,
            hasSort: true,
            label: entity.name,
            pagination: entity.incidents?.pagination,
            ref
          }
        )
      ] })
    ] });
  };
  var detail_default = Detail;

  // assets/scripts/components/leaderboard/subsection.tsx
  var import_jsx_runtime57 = __toESM(require_jsx_runtime());
  var LeaderboardSubsection = ({ children, isGrid = false }) => /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("section", { className: cx(
    "leaderboard-subsection",
    isGrid && "is-grid"
  ), children });
  var subsection_default = LeaderboardSubsection;

  // assets/scripts/components/leaderboard/subsection-group.tsx
  var import_jsx_runtime58 = __toESM(require_jsx_runtime());
  var LeaderboardSubsectionGroup = ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime58.jsx)("div", { className: "leaderboard-subsection-group", children });
  var subsection_group_default = LeaderboardSubsectionGroup;

  // assets/scripts/components/home/chart.tsx
  var import_jsx_runtime59 = __toESM(require_jsx_runtime());
  var Chart4 = () => {
    const sources = useSelector(getSourcesDataForChart);
    const data2 = sources?.data;
    const lineProps = {
      data: data2
    };
    return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(subsection_default, { children: /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(subsection_group_default, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(item_subhead_default, { subtitle: /* @__PURE__ */ (0, import_jsx_runtime59.jsxs)(import_jsx_runtime59.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(icon_default, { name: "chart-simple" }),
        /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("span", { className: "item-text", children: "Lobbying activity over time" })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(incident_activity_chart_default, { children: /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(item_chart_default, { lineProps }) })
    ] }) });
  };
  var chart_default2 = Chart4;

  // assets/scripts/components/leaderboard/more.tsx
  var import_jsx_runtime60 = __toESM(require_jsx_runtime());
  var LeaderboardSubsectionGroup2 = ({ children }) => /* @__PURE__ */ (0, import_jsx_runtime60.jsx)("div", { className: "leaderboard-more", children });
  var more_default = LeaderboardSubsectionGroup2;

  // assets/scripts/components/people/index.tsx
  var import_jsx_runtime61 = __toESM(require_jsx_runtime());
  var PersonItem = ({ id }) => {
    const person = useSelector((state) => selectors3.selectById(state, id));
    const hasTotal = Boolean(person?.overview?.totals?.values.total.value);
    if (!person) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)("tr", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("td", { className: "cell-type", children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(icon_default4, { person }) }),
      /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("td", { className: "cell-name", children: hasTotal ? /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(LinkToPerson, { id: person.id, children: person.name }) : person.name }),
      /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("td", { className: "cell-total", children: person.overview?.totals.values.total.value ?? "-" }),
      /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("td", { className: "cell-percent", children: person.overview?.totals.values.percentage.value ?? "-" })
    ] });
  };
  var Introduction2 = () => /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)(import_jsx_runtime61.Fragment, { children: [
    /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)("p", { children: [
      "The names listed below include City officials and lobbyists whose names appear in lobbying activity reports published by the City of Portland. City Code (",
      /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("a", { href: "https://www.portland.gov/code/2/12/020", children: "2.12.020" }),
      ") defines a \u201CCity official\u201D as:"
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("blockquote", { children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("p", { children: "any City elected official; the at will staff of a City elected official; any City director as defined in this section; or appointee to the Portland Development Commission, the Planning Commission, the Design Commission, and the Fire and Police Disability and Retirement Board." }) }),
    /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("p", { children: "and a \u201CLobbyist\u201D as:" }),
    /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("blockquote", { children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("p", { children: "any individual who is authorized to lobby on behalf of a lobbying entity." }) })
  ] });
  var Index2 = () => {
    const pagination = useSelector(getPeoplePagination);
    const pageIds = useSelector(getPeoplePageIds);
    const hasPageIds = pageIds?.length > 0;
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
      section_index_default,
      {
        pagination,
        introduction: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(Introduction2, {}),
        isLoading: !hasPageIds,
        children: /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)("table", { className: "section-index-list", cellPadding: "0", cellSpacing: "0", children: [
          /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("thead", { children: /* @__PURE__ */ (0, import_jsx_runtime61.jsxs)("tr", { children: [
            /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("th", { className: "cell-name", colSpan: 2, children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
              SortLink,
              {
                newParams: getSortByParam("name" /* Name */, true),
                defaultSort: "ASC" /* ASC */,
                title: "Sort this list by name",
                children: "Name"
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("th", { className: "cell-total", children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(
              SortLink,
              {
                newParams: getSortByParam("total" /* Total */),
                defaultSort: "DESC" /* DESC */,
                title: "Sort this list by total",
                children: "Total"
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("th", { className: "cell-percent", children: "%" })
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("tbody", { children: pageIds.map((id) => /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(PersonItem, { id }, id)) })
        ] })
      }
    );
  };
  var people_default2 = Index2;

  // assets/scripts/components/leaderboard/rankings.tsx
  var import_jsx_runtime62 = __toESM(require_jsx_runtime());
  var useGetItem = (section) => {
    if (section === "entities" /* Entities */) {
      return EntityItem;
    } else if (section === "people" /* People */) {
      return PersonItem;
    }
  };
  var useGetItemsLink = (section) => {
    if (section === "entities" /* Entities */) {
      return LinkToEntities;
    } else if (section === "people" /* People */) {
      return LinkToPeople;
    }
  };
  var LeaderboardRankings = ({
    isGrid = false,
    rankings,
    section
  }) => {
    const ids = rankings?.ids;
    const labels = rankings?.labels;
    const hasIds = ids?.length > 0;
    const hasLabels = Boolean(labels);
    const Item = useGetItem(section);
    const ItemsLink = useGetItemsLink(section);
    if (!hasIds || !hasLabels) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(subsection_default, { isGrid, children: [
      /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(subsection_subhead_default, { title: labels.title, children: labels.subtitle }),
      /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(subsection_group_default, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(item_subhead_default, { subtitle: /* @__PURE__ */ (0, import_jsx_runtime62.jsxs)(import_jsx_runtime62.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(icon_default, { name: "trophy" }),
          /* @__PURE__ */ (0, import_jsx_runtime62.jsx)("span", { className: "item-text", children: labels.table.title })
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(item_table_default, { hasPercent: true, children: ids.map((id) => /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(Item, { id }, id)) }),
        /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(more_default, { children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(item_text_with_icon_default, { icon: "link", children: /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(ItemsLink, { children: labels.links.more }) }) })
      ] })
    ] });
  };
  var rankings_default = LeaderboardRankings;

  // assets/scripts/components/home/leaderboard-entities.tsx
  var import_jsx_runtime63 = __toESM(require_jsx_runtime());
  var EntitiesLeaderboard = () => {
    const result = useSelector(getEntitiesLeaderboard);
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
      rankings_default,
      {
        isGrid: true,
        rankings: result?.all,
        section: "entities" /* Entities */
      }
    );
  };
  var leaderboard_entities_default = EntitiesLeaderboard;

  // assets/scripts/components/home/leaderboard-lobbyists.tsx
  var import_jsx_runtime64 = __toESM(require_jsx_runtime());
  var LobbyistsLeaderboard = () => {
    const result = useSelector(getPeopleLeaderboard);
    return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
      rankings_default,
      {
        isGrid: true,
        rankings: result?.lobbyists,
        section: "people" /* People */
      }
    );
  };
  var leaderboard_lobbyists_default = LobbyistsLeaderboard;

  // assets/scripts/components/home/leaderboard-officials.tsx
  var import_jsx_runtime65 = __toESM(require_jsx_runtime());
  var OfficialsLeaderboard = () => {
    const result = useSelector(getPeopleLeaderboard);
    return /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
      rankings_default,
      {
        isGrid: true,
        rankings: result?.officials,
        section: "people" /* People */
      }
    );
  };
  var leaderboard_officials_default = OfficialsLeaderboard;

  // assets/scripts/components/home/index.tsx
  var import_jsx_runtime66 = __toESM(require_jsx_runtime());
  var Home = () => /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(
    section_default,
    {
      icon: "handshake",
      title: "Lobbying in Portland, Oregon",
      className: "section-home",
      children: [
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(chart_default2, {}),
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(leaderboard_entities_default, {}),
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(leaderboard_lobbyists_default, {}),
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(leaderboard_officials_default, {})
      ]
    }
  );
  var home_default = Home;

  // assets/scripts/components/incidents/index.tsx
  var import_react36 = __toESM(require_react());
  var import_jsx_runtime67 = __toESM(require_jsx_runtime());
  var Introduction3 = () => /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)("p", { children: [
    "Lobbying entities are required to register with the City Auditor and submit quarterly lobbying activity reports to the Auditor\u2019s office (",
    /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("a", { href: "https://www.portland.gov/code/2/12/040", children: "2.12.040" }),
    "). City Code identifies the information included in each report as public record (",
    /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("a", { href: "https://www.portland.gov/code/2/12/100", children: "2.12.100" }),
    "). The incidents listed below have been extracted from the published quarterly lobbying reports and sorted in chronological order. Click an incident row for more details."
  ] });
  var Index3 = () => {
    const ref = (0, import_react36.useRef)();
    const scrollToRef = () => {
      ref.current?.scrollIntoView({ behavior: "smooth" });
    };
    const pagination = useSelector(getIncidentsPagination);
    const pageIds = useSelector(getIncidentsPageIds);
    const hasPageIds = pageIds?.length > 0;
    return /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
      section_index_default,
      {
        introduction: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(Introduction3, {}),
        isLoading: !hasPageIds,
        children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("div", { className: "incident-list-anchor", ref, children: /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(
          incident_list_default,
          {
            hasSort: true,
            ids: pageIds,
            pagination,
            scrollToRef
          }
        ) })
      }
    );
  };
  var incidents_default2 = Index3;

  // assets/scripts/components/incident-source-box.tsx
  var import_react37 = __toESM(require_react());
  var import_jsx_runtime68 = __toESM(require_jsx_runtime());
  var IncidentSourceBox = ({ incident, title }) => {
    const [trigger] = api_default.useLazyGetSourceByIdQuery();
    const id = incident?.sourceId;
    const source = useSelector((state) => selectors4.selectById(state, id));
    (0, import_react37.useEffect)(() => {
      if (source || !id) return;
      trigger(id);
    }, [id, source, trigger]);
    if (!source) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
      MetaSectionBox,
      {
        className: "source-information-box",
        icon: "database",
        title,
        children: /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
          LinkToSource,
          {
            id: source.id,
            children: source.title
          }
        )
      }
    );
  };
  var incident_source_box_default = IncidentSourceBox;

  // assets/scripts/components/incidents/detail.tsx
  var import_jsx_runtime69 = __toESM(require_jsx_runtime());
  var Detail2 = () => {
    const { id } = useParams();
    const numericId = Number(id);
    const incident = useSelector((state) => selectors2.selectById(state, numericId));
    if (!incident) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime69.jsxs)(item_detail_default, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime69.jsxs)("div", { className: "item-content-section item-content-section-primary", children: [
        /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(item_subhead_default, { title: "Details" }),
        /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("div", { className: "incident-details", children: /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(incident_table_default, { incident }) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("div", { className: "item-content-section item-content-section-secondary", children: /* @__PURE__ */ (0, import_jsx_runtime69.jsxs)(meta_section_default, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
          incident_notes_box_default,
          {
            title: "Notes about this incident",
            incident
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(
          incident_source_box_default,
          {
            title: "Data source",
            incident
          }
        )
      ] }) })
    ] });
  };
  var detail_default2 = Detail2;

  // assets/scripts/components/people/detail.tsx
  var import_react42 = __toESM(require_react());

  // assets/scripts/components/people/attendees.tsx
  var import_react38 = __toESM(require_react());
  var import_jsx_runtime70 = __toESM(require_jsx_runtime());
  var Attendees3 = ({
    attendees,
    person
  }) => {
    const [trigger] = api_default.useLazyGetPersonAttendeesByIdQuery();
    const hasAttendees = "attendees" in person;
    const isLobbyist = person.roles?.includes("lobbyist" /* Lobbyist */);
    const isOfficial = person.roles?.includes("official" /* Official */);
    const hasLobbyistRecords = isLobbyist && hasAttendees && Boolean(person.attendees.asLobbyist.lobbyists.records.length || person.attendees.asLobbyist.officials.records.length);
    const hasOfficialRecords = isOfficial && hasAttendees && Boolean(person.attendees.asOfficial.lobbyists.records.length || person.attendees.asOfficial.officials.records.length);
    const hasRecords = hasLobbyistRecords || hasOfficialRecords;
    const description = [
      "According to the lobbying activity reports published by the City of Portland,",
      person.name
    ];
    const roles = [];
    if (isLobbyist) {
      roles.push("lobbied a number of City officials as a registered lobbyist");
    }
    if (isOfficial) {
      roles.push("was lobbied by a number of lobbyists as a City of Portland official");
    }
    description.push(roles.join(" and "));
    (0, import_react38.useEffect)(() => {
      if (!hasRecords) {
        trigger(person.id);
      }
    }, [hasRecords, person, trigger]);
    return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
      incident_activity_groups_default,
      {
        title: "Associated Names",
        description: `${person.name} is named in lobbying reports that also include these people.`,
        children: hasRecords ? /* @__PURE__ */ (0, import_jsx_runtime70.jsxs)(import_jsx_runtime70.Fragment, { children: [
          isLobbyist && /* @__PURE__ */ (0, import_jsx_runtime70.jsxs)(
            incident_activity_group_default,
            {
              icon: "briefcase",
              title: attendees.asLobbyist.label,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(affiliated_people_table_default, { attendees: attendees.asLobbyist.officials }),
                /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(affiliated_people_table_default, { attendees: attendees.asLobbyist.lobbyists })
              ]
            }
          ),
          isOfficial && /* @__PURE__ */ (0, import_jsx_runtime70.jsxs)(
            incident_activity_group_default,
            {
              icon: "landmark",
              title: attendees.asOfficial.label,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(affiliated_people_table_default, { attendees: attendees.asOfficial.lobbyists }),
                /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(affiliated_people_table_default, { attendees: attendees.asOfficial.officials })
              ]
            }
          )
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(
          incident_activity_group_default,
          {
            title: "No record of associated names was found."
          }
        )
      }
    );
  };
  var attendees_default2 = Attendees3;

  // assets/scripts/components/people/chart.tsx
  var import_react39 = __toESM(require_react());
  var import_jsx_runtime71 = __toESM(require_jsx_runtime());
  var Chart5 = ({ label }) => {
    const [trigger] = api_default.useLazyGetPersonStatsByIdQuery();
    const { id } = useParams();
    const numericId = Number(id);
    const [searchParams, setSearchParams] = useSearchParams();
    const quarterParam2 = searchParams.get("quarter");
    const [quarter, setQuarter] = (0, import_react39.useState)(quarterParam2);
    const peopleData = useSelector(getPeopleChartData);
    const data2 = peopleData?.[numericId];
    const hasData = data2?.length > 0;
    const lineProps = {
      label,
      data: data2
    };
    const handleClick = (value) => {
      setQuarter(value.replace(" ", "-"));
    };
    (0, import_react39.useEffect)(() => {
      if (!hasData) {
        trigger(numericId);
      }
    }, [hasData, numericId, trigger]);
    (0, import_react39.useEffect)(() => {
      if (quarter) {
        if (!quarterParam2 || quarterParam2 && quarter && quarterParam2 !== quarter) {
          setSearchParams({ quarter });
        }
        setQuarter(null);
      }
    }, [quarterParam2, quarter, setSearchParams]);
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(item_chart_default, { lineProps, handleClick });
  };
  var chart_default3 = Chart5;

  // assets/scripts/components/people/entities.tsx
  var import_react41 = __toESM(require_react());

  // assets/scripts/components/affiliated-entities-table.tsx
  var import_react40 = __toESM(require_react());
  var import_jsx_runtime72 = __toESM(require_jsx_runtime());
  var RegisteredIcon = () => /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(icon_default, { name: "check", className: "icon-registered" });
  var AffiliatedEntitiesTable = ({
    entities,
    hasLobbyist,
    person,
    title
  }) => {
    const ref = (0, import_react40.useRef)();
    const hasPerson = Boolean(person);
    return /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(stat_box_default, { title, children: /* @__PURE__ */ (0, import_jsx_runtime72.jsx)("div", { className: "affiliated-items", ref, children: /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(item_table_default, { hasAnotherIcon: hasPerson && hasLobbyist, children: entities.map((item, i) => {
      const hasTotal = Boolean(item.total);
      return /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)("tr", { children: [
        hasPerson ? hasLobbyist ? /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)(import_jsx_runtime72.Fragment, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime72.jsx)("td", { className: "cell-type", children: item.entity.isRegistered ? /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)(
            "div",
            {
              className: "icons",
              title: `${item.entity.name} is or was registered to lobby the City`,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(icon_default2, {}),
                /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(RegisteredIcon, {})
              ]
            }
          ) : /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(icon_default2, {}) }),
          /* @__PURE__ */ (0, import_jsx_runtime72.jsx)("td", { className: "cell-type", children: item.isRegistered ? /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)(
            "div",
            {
              className: "icons",
              title: `${person.name} is or was registered to lobby the City on behalf of ${item.entity.name}`,
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(icon_default4, {}),
                /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(RegisteredIcon, {})
              ]
            }
          ) : /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(icon_default4, {}) })
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime72.jsx)("td", { className: "cell-type", children: /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(icon_default2, {}) }) : /* @__PURE__ */ (0, import_jsx_runtime72.jsx)("td", { className: "cell-type", children: /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(icon_default2, {}) }),
        /* @__PURE__ */ (0, import_jsx_runtime72.jsxs)("td", { className: "cell-name", children: [
          /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(LinkToEntity, { id: item.entity.id, className: "item-entity", children: item.entity.name }),
          /* @__PURE__ */ (0, import_jsx_runtime72.jsx)("div", { className: "item-description", children: item.registrations })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime72.jsx)("td", { className: "cell-total", children: hasTotal ? /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(FilterLink, { newParams: getWithEntityParams(item), hasIcon: true, children: item.total }) : "-" })
      ] }, i);
    }) }) }) });
  };
  var affiliated_entities_table_default = AffiliatedEntitiesTable;

  // assets/scripts/components/people/entities.tsx
  var import_jsx_runtime73 = __toESM(require_jsx_runtime());
  var Entities = ({ entities, person }) => {
    const [trigger] = api_default.useLazyGetPersonEntitiesByIdQuery();
    const hasEntities = "entities" in person;
    const isLobbyist = person.roles?.includes("lobbyist" /* Lobbyist */);
    const isOfficial = person.roles?.includes("official" /* Official */);
    const hasLobbyistRecords = isLobbyist && hasEntities && Boolean(person.entities.asLobbyist.length || person.entities.asLobbyist.length);
    const hasOfficialRecords = isOfficial && hasEntities && Boolean(person.entities.asOfficial.length || person.entities.asOfficial.length);
    const hasRecords = hasLobbyistRecords || hasOfficialRecords;
    (0, import_react41.useEffect)(() => {
      if (!hasRecords) {
        trigger(person.id);
      }
    }, [hasRecords, person, trigger]);
    return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
      incident_activity_groups_default,
      {
        title: "Associated Entities",
        description: `${person.name} is named in lobbying reports related to these entities.`,
        children: hasRecords ? /* @__PURE__ */ (0, import_jsx_runtime73.jsxs)(import_jsx_runtime73.Fragment, { children: [
          isLobbyist && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
            incident_activity_group_default,
            {
              icon: "briefcase",
              title: `As a lobbyist, ${person.name} interacted with City officials on behalf of these entities`,
              children: /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
                affiliated_entities_table_default,
                {
                  entities: entities.asLobbyist,
                  hasLobbyist: true,
                  person
                }
              )
            }
          ),
          isOfficial && /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
            incident_activity_group_default,
            {
              icon: "landmark",
              title: `As a City official, ${person.name} was lobbied by representatives of these entities`,
              children: /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(affiliated_entities_table_default, { entities: entities.asOfficial })
            }
          )
        ] }) : /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(
          incident_activity_group_default,
          {
            title: "No record of associated entities was found."
          }
        )
      }
    );
  };
  var entities_default3 = Entities;

  // assets/scripts/components/people/detail.tsx
  var import_jsx_runtime74 = __toESM(require_jsx_runtime());
  var Detail3 = () => {
    const ref = (0, import_react42.useRef)();
    const { id } = useParams();
    const numericId = Number(id);
    const person = useSelector((state) => selectors3.selectById(state, numericId));
    const hasPerson = Boolean(person);
    const hasIncidents = Boolean(person?.incidents?.ids?.length);
    if (!hasPerson) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime74.jsxs)(item_detail_default, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
        detail_activity_overview_default,
        {
          overview: person.overview,
          ref,
          children: /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(chart_default3, { label: person.name })
        }
      ),
      hasIncidents && /* @__PURE__ */ (0, import_jsx_runtime74.jsxs)(import_jsx_runtime74.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
          entities_default3,
          {
            entities: person.entities,
            person
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
          attendees_default2,
          {
            attendees: person.attendees,
            person
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(
          detail_incidents_default,
          {
            ids: person.incidents?.ids,
            filters: person.incidents?.filters,
            hasSort: true,
            label: person.name,
            pagination: person.incidents?.pagination,
            ref
          }
        )
      ] })
    ] });
  };
  var detail_default3 = Detail3;

  // assets/scripts/components/sources/item.tsx
  var import_react43 = __toESM(require_react());
  var import_jsx_runtime75 = __toESM(require_jsx_runtime());
  var Source = ({ id }) => {
    const [trigger] = api_default.useLazyGetSourceByIdQuery();
    const source = useSelector((state) => selectors4.selectById(state, id));
    const hasTotals = Boolean(source?.overview?.totals.values.total.value);
    (0, import_react43.useEffect)(() => {
      if (source) return;
      trigger(id);
    }, [id, source, trigger]);
    if (!source) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(
      LinkToSource,
      {
        className: "item-source-quarter",
        id: source.id,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "item-source-quarter-icon", children: /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(icon_default, { name: "database" }) }),
          /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)("div", { className: "item-source-quarter-description", children: [
            /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("h6", { children: source.title }),
            hasTotals && /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)("p", { children: [
              source?.overview?.totals.values.total.value,
              " incidents"
            ] })
          ] })
        ]
      },
      `${source.year}-${source.quarter}`
    );
  };
  var item_default = Source;

  // assets/scripts/components/sources/index.tsx
  var import_jsx_runtime76 = __toESM(require_jsx_runtime());
  var Index4 = () => {
    const byYear = useSelector(getSourcesByYear);
    const hasSources = byYear.length > 0;
    return /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(section_index_default, { isLoading: !hasSources, children: byYear.map((sources) => /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)("div", { className: "item-index-group", children: [
      /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(item_subhead_default, { title: sources.year }),
      /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("div", { className: "section-index-list", children: sources.items.map((source) => /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(item_default, { id: source.id }, source.id)) })
    ] }, sources.year)) });
  };
  var sources_default2 = Index4;

  // assets/scripts/components/sources/detail.tsx
  var import_react46 = __toESM(require_react());

  // assets/scripts/components/sources/attendees.tsx
  var import_react44 = __toESM(require_react());
  var import_jsx_runtime77 = __toESM(require_jsx_runtime());
  var Attendees4 = ({ attendees }) => {
    const [trigger] = api_default.useLazyGetSourceAttendeesByIdQuery();
    const { id } = useParams();
    const numericId = Number(id);
    const hasAttendees = Boolean(attendees);
    (0, import_react44.useEffect)(() => {
      if (!hasAttendees) {
        trigger(numericId);
      }
    }, [hasAttendees, numericId, trigger]);
    return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(incident_activity_groups_default, { title: "Associated Names", children: attendees ? /* @__PURE__ */ (0, import_jsx_runtime77.jsxs)(
      incident_activity_group_default,
      {
        icon: "user-group",
        title: attendees.label,
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(affiliated_people_table_default, { attendees: attendees.officials }),
          /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(affiliated_people_table_default, { attendees: attendees.lobbyists })
        ]
      }
    ) : null });
  };
  var attendees_default3 = Attendees4;

  // assets/scripts/components/sources/chart.tsx
  var import_jsx_runtime78 = __toESM(require_jsx_runtime());
  var Chart6 = ({ label }) => /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(item_chart_default, { label });
  var chart_default4 = Chart6;

  // assets/scripts/components/sources/entities.tsx
  var import_react45 = __toESM(require_react());
  var import_jsx_runtime79 = __toESM(require_jsx_runtime());
  var Entities2 = ({ entities, source }) => {
    const [trigger] = api_default.useLazyGetSourceEntitiesByIdQuery();
    const hasEntities = entities?.length > 0;
    (0, import_react45.useEffect)(() => {
      if (!hasEntities) {
        trigger(source.id);
      }
    }, [hasEntities, source, trigger]);
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(incident_activity_groups_default, { title: "Associated Entities", children: entities ? /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(
      incident_activity_group_default,
      {
        icon: "briefcase",
        title: `These entities appear in ${source.title}`,
        children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(affiliated_entities_table_default, { entities })
      }
    ) : null });
  };
  var entities_default4 = Entities2;

  // assets/scripts/components/source-information-box.tsx
  var import_jsx_runtime80 = __toESM(require_jsx_runtime());
  var DataFormatIcon = /* @__PURE__ */ ((DataFormatIcon2) => {
    DataFormatIcon2["csv"] = "file-csv";
    return DataFormatIcon2;
  })(DataFormatIcon || {});
  var SourceDisclaimers = /* @__PURE__ */ ((SourceDisclaimers2) => {
    SourceDisclaimers2["activity"] = "Other than light formatting performed to facilitate database input, indexing to accommodate a modern API, and editing to address obvious typos and improve readability, data from this source remains as downloaded.";
    SourceDisclaimers2["registration"] = "Data has been condensed and edited to facilitate database input, address obvious typos, and improve readability.";
    return SourceDisclaimers2;
  })(SourceDisclaimers || {});
  var SourceInformationBox = ({ source, title }) => {
    const disclaimers = SourceDisclaimers[source.type];
    const format = DataFormat[source.format];
    const icon2 = DataFormatIcon[source.format];
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsxs)(
      MetaSectionBox,
      {
        className: "source-information-box",
        icon: icon2,
        title,
        children: [
          "Data was retrieved on",
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("strong", { children: source.retrievedDate }),
          " ",
          "in",
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("strong", { children: format }),
          " format",
          " ",
          "from",
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("strong", { children: /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("a", { href: source.publicUrl, target: "_blank", rel: "noreferrer", children: source.publicUrl }) }),
          " ",
          "as published by the City of Portland\u2019s Auditor\u2019s Office in accordance with the City\u2019s",
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime80.jsx)("a", { href: "https://www.portland.gov/what-works-cities/making-data-publicly-accessible", children: "Open Data Policy" }),
          ".",
          " ",
          disclaimers
        ]
      }
    );
  };
  var source_information_box_default = SourceInformationBox;

  // assets/scripts/components/sources/detail.tsx
  var import_jsx_runtime81 = __toESM(require_jsx_runtime());
  var Detail4 = () => {
    const ref = (0, import_react46.useRef)();
    const { id } = useParams();
    const numericId = Number(id);
    const source = useSelector((state) => selectors4.selectById(state, numericId));
    const hasSource = Boolean(source);
    const label = source ? `Q${source.quarter} ${source.year}` : null;
    const isActivity = source?.type === "activity";
    const hasIncidents = isActivity && Boolean(source?.incidents?.ids?.length);
    if (!hasSource) return null;
    return /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(item_detail_default, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(meta_section_default, { children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
        source_information_box_default,
        {
          title: "Source Information",
          source
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
        detail_activity_overview_default,
        {
          overview: source.overview,
          ref,
          children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(chart_default4, { label })
        }
      ),
      hasIncidents && /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(import_jsx_runtime81.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          entities_default4,
          {
            entities: source.entities,
            source
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(attendees_default3, { attendees: source.attendees }),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          detail_incidents_default,
          {
            ids: source.incidents?.ids,
            filters: source.incidents?.filters,
            hasSort: true,
            label: source.title,
            pagination: source.incidents?.pagination,
            ref
          }
        )
      ] })
    ] });
  };
  var detail_default4 = Detail4;

  // assets/scripts/index.tsx
  var import_jsx_runtime82 = __toESM(require_jsx_runtime());
  var rootTarget = document.getElementById("root");
  var router = createBrowserRouter([
    {
      path: "/",
      element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(app_default, {}),
      errorElement: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(alert_error_default, {}),
      children: [
        {
          path: "",
          element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(home_default, {})
        },
        {
          path: "entities/*",
          children: [
            {
              path: "",
              element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(entities_default2, {})
            },
            {
              path: ":id",
              element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(detail_default, {})
            }
          ]
        },
        {
          path: "incidents/*",
          children: [
            {
              path: "",
              element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(incidents_default2, {})
            },
            {
              path: ":id",
              element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(detail_default2, {})
            }
          ]
        },
        {
          path: "people/*",
          children: [
            {
              path: "",
              element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(people_default2, {})
            },
            {
              path: ":id",
              element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(detail_default3, {})
            }
          ]
        },
        {
          path: "sources/*",
          children: [
            {
              path: "",
              element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(sources_default2, {})
            },
            {
              path: ":id",
              element: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(detail_default4, {})
            }
          ]
        }
      ]
    }
  ]);
  var createTarget = (id) => {
    const target = document.createElement("div");
    target.id = id;
    target.className = id;
    return target;
  };
  var appendTarget = (target) => {
    document.body.appendChild(target);
  };
  if (rootTarget) {
    try {
      const modal = createTarget(modalRootId);
      const alert = createTarget(alertRootId);
      appendTarget(modal);
      appendTarget(alert);
      (0, import_client.createRoot)(modal).render(
        /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(Provider_default, { store, children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("div", { id: modalPortalId }) })
      );
      (0, import_client.createRoot)(alert).render(
        /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(Provider_default, { store, children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)("div", { id: alertPortalId }) })
      );
      (0, import_client.createRoot)(rootTarget).render(
        /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(Provider_default, { store, children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(RouterProvider, { router }) })
      );
    } catch (error) {
      console.log(error);
    }
  }
})();
/*! Bundled license information:

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.development.js:
  (**
   * @license React
   * react-dom-client.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

react/cjs/react-jsx-runtime.development.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-router/dist/development/chunk-GNGMS2XR.mjs:
  (**
   * react-router v7.4.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/development/index.mjs:
  (**
   * react-router v7.4.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

@fortawesome/fontawesome-svg-core/index.mjs:
  (*!
   * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2024 Fonticons, Inc.
   *)

@fortawesome/free-solid-svg-icons/index.mjs:
  (*!
   * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2024 Fonticons, Inc.
   *)

@fortawesome/free-regular-svg-icons/index.mjs:
  (*!
   * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2024 Fonticons, Inc.
   *)

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.2
   * https://github.com/kurkle/color#readme
   * (c) 2023 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.8
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.8
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)
*/
